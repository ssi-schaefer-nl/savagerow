{"version":3,"sources":["../src/shaker.ts"],"names":["shakeNode","node","alive","keys","changes","isNodeAlive","n","has","key","subNode","Array","isArray","list","hasChanges","i","length","child","isAlive","shaken","push","undefined","Object","shake","rootPath","exports","join","code","depsGraph","Set","deps","getLeafs","map","forEach","d","add","getDependencies","filter","imports","Map","source","members","entries","defaultMembers","importTypes","get","aliveMembers","name","set","size","from"],"mappings":"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","sourcesContent":["import type { Node, Program } from '@babel/types';\nimport generator from '@babel/generator';\nimport { debug } from '@linaria/logger';\nimport { isNode, getVisitorKeys } from '@linaria/babel-preset';\nimport build from './graphBuilder';\nimport dumpNode from './dumpNode';\n\n/*\n * Returns new tree without dead nodes\n */\nfunction shakeNode<TNode extends Node>(node: TNode, alive: Set<Node>): Node {\n  const keys = getVisitorKeys(node) as Array<keyof TNode>;\n  const changes: Partial<TNode> = {};\n  const isNodeAlive = (n: Node) => alive.has(n);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      const list: any = [];\n      let hasChanges = false;\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        const isAlive = isNodeAlive(child);\n        hasChanges = hasChanges || !isAlive;\n        if (child && isAlive) {\n          const shaken = shakeNode(child, alive);\n          if (shaken) {\n            list.push(shaken);\n          }\n\n          hasChanges = hasChanges || shaken !== child;\n        }\n      }\n      if (hasChanges) {\n        changes[key] = list;\n      }\n    } else if (isNode(subNode)) {\n      if (isNodeAlive(subNode)) {\n        const shaken = shakeNode(subNode, alive);\n        if (shaken && shaken !== subNode) {\n          changes[key] = shaken as any;\n        }\n      } else {\n        changes[key] = undefined;\n      }\n    }\n  }\n\n  return Object.keys(changes).length ? { ...node, ...changes } : node;\n}\n\n/*\n * Gets AST and a list of nodes for evaluation\n * Removes unrelated “dead” code.\n * Adds to the end of module export of array of evaluated values or evaluation errors.\n * Returns new AST and an array of external dependencies.\n */\nexport default function shake(\n  rootPath: Program,\n  exports: string[] | null\n): [Program, Map<string, string[]>] {\n  debug(\n    'evaluator:shaker:shake',\n    () =>\n      `source (exports: ${(exports || []).join(', ')}):\\n${\n        generator(rootPath).code\n      }`\n  );\n\n  const depsGraph = build(rootPath);\n  const alive = new Set<Node>();\n  let deps: Node[] = depsGraph.getLeafs(exports).map((i) => i) as Node[];\n  while (deps.length > 0) {\n    // Mark all dependencies as alive\n    deps.forEach((d) => alive.add(d));\n\n    // Collect new dependencies of dependencies\n    deps = depsGraph.getDependencies(deps).filter((d) => !alive.has(d));\n  }\n\n  const shaken = shakeNode(rootPath, alive) as Program;\n  /*\n   * If we want to know what is really happen with our code tree,\n   * we can print formatted tree here by setting env variable LINARIA_LOG=debug\n   */\n  debug('evaluator:shaker:shake', () => dumpNode(rootPath, alive));\n\n  const imports = new Map<string, string[]>();\n  for (let [source, members] of depsGraph.imports.entries()) {\n    const defaultMembers =\n      depsGraph.importTypes.get(source) === 'wildcard' ? ['*'] : [];\n    const aliveMembers = new Set(\n      members.filter((i) => alive.has(i)).map((i) => i.name)\n    );\n\n    imports.set(\n      source,\n      aliveMembers.size > 0 ? Array.from(aliveMembers) : defaultMembers\n    );\n  }\n\n  return [shaken, imports];\n}\n"],"file":"shaker.js"}