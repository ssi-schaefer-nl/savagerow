{"version":3,"sources":["../../src/langs/core.ts"],"names":["types","t","peek","ScopeManager","isIdentifier","node","name","undefined","Array","isArray","includes","sideEffects","callee","isMemberExpression","property","state","graph","addEdge","arguments","getCallee","isSequenceExpression","expressions","length","first","second","isNumericLiteral","value","getAffectedNodes","isCallExpression","object","obj","scope","getDeclaration","globalExportsIdentifier","isStringLiteral","addExport","visitors","ExpressionStatement","baseVisit","expression","Function","unsubscribe","onVisit","descendant","body","params","forEach","param","isFunctionDeclaration","id","isFunctionExpression","Block","isProgram","exportsDeclaration","directives","directive","exp","Directive","TryStatement","handler","finalizer","statement","block","IfStatement","consequent","alternate","test","WhileStatement","SwitchCase","SwitchStatement","cases","c","discriminant","ForStatement","init","update","child","ForInStatement","left","right","Terminatorless","isBreakStatement","isContinueStatement","argument","closestFunctionNode","fnStack","ObjectExpression","context","push","properties","prop","isObjectMethod","key","isObjectProperty","isSpreadElement","pop","MemberExpression","declaration","importAliases","has","source","get","imports","AssignmentExpression","visit","VariableDeclarator","declared","meta","set","unregister","addDeclareHandler","identifier","from","delete","VariableDeclaration","kind","declarations","CallExpression","parent","scopeId","whereIsDeclared","firstArg","local","_imported","startsWith","importTypes","conditions","callback","affectedNode","SequenceExpression","identifierHandlers","declare","keep","refer"],"mappings":"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","sourcesContent":["import { types as t } from '@babel/core';\nimport type {\n  AssignmentExpression,\n  Block,\n  CallExpression,\n  Directive,\n  ExpressionStatement,\n  ForInStatement,\n  ForStatement,\n  Function,\n  Identifier,\n  IfStatement,\n  MemberExpression,\n  Node,\n  ObjectExpression,\n  SequenceExpression,\n  SwitchCase,\n  SwitchStatement,\n  Terminatorless,\n  TryStatement,\n  VariableDeclaration,\n  VariableDeclarator,\n  WhileStatement,\n} from '@babel/types';\n\nimport { peek } from '@linaria/babel-preset';\nimport type { IdentifierHandlers, Visitors } from '../types';\nimport GraphBuilderState from '../GraphBuilderState';\nimport ScopeManager from '../scope';\n\nfunction isIdentifier(\n  node: Node,\n  name?: string | string[]\n): node is Identifier {\n  return (\n    t.isIdentifier(node) &&\n    (name === undefined ||\n      (Array.isArray(name) ? name.includes(node.name) : node.name === name))\n  );\n}\n\ntype SideEffect = [\n  {\n    callee?: (child: CallExpression['callee']) => boolean;\n    arguments?: (child: CallExpression['arguments']) => boolean;\n  },\n  (node: CallExpression, state: GraphBuilderState) => void\n];\n\nconst sideEffects: SideEffect[] = [\n  [\n    // if the first argument of forEach is required, mark forEach as required\n    {\n      callee: (node) =>\n        t.isMemberExpression(node) &&\n        t.isIdentifier(node.property) &&\n        node.property.name === 'forEach',\n    },\n    (node, state) => state.graph.addEdge(node.arguments[0], node),\n  ],\n];\n\nfunction getCallee(node: CallExpression): Node {\n  if (\n    t.isSequenceExpression(node.callee) &&\n    node.callee.expressions.length === 2\n  ) {\n    const [first, second] = node.callee.expressions;\n    if (t.isNumericLiteral(first) && first.value === 0) {\n      return second;\n    }\n  }\n\n  return node.callee;\n}\n\n/*\n * Returns nodes which are implicitly affected by specified node\n */\nfunction getAffectedNodes(node: Node, state: GraphBuilderState): Node[] {\n  // FIXME: this method should be generalized\n  const callee = t.isCallExpression(node) ? getCallee(node) : null;\n  if (\n    t.isCallExpression(node) &&\n    t.isMemberExpression(callee) &&\n    isIdentifier(callee.object, 'Object') &&\n    isIdentifier(callee.property, [\n      'assign',\n      'defineProperty',\n      'defineProperties',\n      'freeze',\n      'observe',\n    ])\n  ) {\n    const [obj, property] = node.arguments;\n    if (!t.isIdentifier(obj)) {\n      return [];\n    }\n\n    if (\n      state.scope.getDeclaration(obj) !== ScopeManager.globalExportsIdentifier\n    ) {\n      return [node.arguments[0]];\n    }\n\n    if (t.isStringLiteral(property)) {\n      if (property.value === '__esModule') {\n        return [node.arguments[0]];\n      }\n\n      state.graph.addExport(property.value, node);\n    }\n  }\n\n  return [];\n}\n\nexport const visitors: Visitors = {\n  /*\n   * ExpressionStatement\n   * This is one of the rare cases when a child defines a dependency on a parent.\n   * Suppose we have a code like this:\n   * const fn = () => {\n   *   let a = 2;\n   *   a *= 2;\n   *   return a;\n   * };\n   *\n   * `a *= 2` here is an ExpressionStatement node which contains an expression AssignmentExpression `a *= 2`.\n   * The result of AssignmentExpression here depends on the fact of ExpressionStatement execution,\n   * that's why we need to mark the statement as a dependency of the expression.\n   * If we don't mark it, it will be cut as a useless statement.\n   */\n  ExpressionStatement(this: GraphBuilderState, node: ExpressionStatement) {\n    this.baseVisit(node);\n\n    this.graph.addEdge(node.expression, node);\n  },\n\n  /*\n   * FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod;\n   * Functions can be either a statement or an expression.\n   * That's why we need to disable default dependency resolving strategy for expressions by passing `ignoreDeps` flag.\n   * Every function must have a body. Without a body, it becomes invalid.\n   * In general, a body depends on parameters of a function.\n   * In real life, some of the parameters can be omitted, but it's not trivial to implement that type of tree shaking.\n   */\n  Function(this: GraphBuilderState, node: Function) {\n    const unsubscribe = this.onVisit((descendant) =>\n      this.graph.addEdge(node, descendant)\n    );\n    this.baseVisit(node, true); // ignoreDeps=true prevents default dependency resolving\n    unsubscribe();\n\n    this.graph.addEdge(node, node.body);\n    this.graph.addEdge(node.body, node);\n\n    node.params.forEach((param) => this.graph.addEdge(node.body, param));\n    if (t.isFunctionDeclaration(node) && node.id !== null) {\n      // `id` is an identifier which depends on the function declaration\n      this.graph.addEdge(node.id, node);\n    }\n\n    if (t.isFunctionExpression(node) && node.id !== null) {\n      // keep function name in expressions like `const a = function a();`\n      this.graph.addEdge(node, node.id);\n    }\n  },\n\n  /*\n   * BlockStatement | Program\n   * The same situation as in ExpressionStatement: if one of the expressions is required, the block itself is also required.\n   * Whereas a block doesn't depend on its children.\n   * Example:\n   * 1. let c;\n   * 2. { // BlockStatement begin\n   * 3.   let a = 1;\n   * 4.   let b = 2;\n   * 5.   a++;\n   * 6.   a = c;\n   * 7. } // BlockStatement end\n   *\n   * If we want to evaluate the value of `c`, we need to evaluate lines 1, 3, 5 and 6,\n   * but we don't need line 4, even though it's a child of the block.\n   */\n  Block(this: GraphBuilderState, node: Block) {\n    this.baseVisit(node);\n\n    if (t.isProgram(node)) {\n      const exportsDeclaration = this.scope.getDeclaration('global:exports')!;\n      this.graph.addEdge(node, exportsDeclaration);\n      node.directives.forEach((directive) =>\n        this.graph.addEdge(node, directive)\n      );\n    }\n\n    node.body.forEach((exp) => {\n      this.graph.addEdge(exp, node);\n    });\n  },\n\n  Directive(this: GraphBuilderState, node: Directive) {\n    this.baseVisit(node);\n    this.graph.addEdge(node, node.value);\n  },\n\n  /*\n   * TryStatement\n   * try { /* block *\\/ } catch() {/* handler *\\/} finalize {/* finalizer *\\/}\n   * `handler` and `finalizer` do not make sense without `block`\n   * `block` depends on the whole node.\n   */\n  TryStatement(this: GraphBuilderState, node: TryStatement) {\n    this.baseVisit(node);\n    [node.handler, node.finalizer].forEach((statement) => {\n      if (statement) {\n        this.graph.addEdge(node.block, statement);\n        this.graph.addEdge(statement, node.block);\n      }\n    });\n\n    this.graph.addEdge(node.block, node);\n  },\n\n  IfStatement(this: GraphBuilderState, node: IfStatement) {\n    this.baseVisit(node);\n    [node.consequent, node.alternate].forEach((statement) => {\n      if (statement) {\n        this.graph.addEdge(statement, node);\n      }\n    });\n\n    this.graph.addEdge(node, node.consequent);\n    this.graph.addEdge(node, node.test);\n  },\n\n  /*\n   * WhileStatement\n   * Pretty simple behaviour here:\n   * • if body is required, the statement is required\n   * • if the statement is required, the condition is also required.\n   */\n  WhileStatement(this: GraphBuilderState, node: WhileStatement) {\n    this.baseVisit(node);\n    this.graph.addEdge(node.body, node);\n    this.graph.addEdge(node, node.test);\n  },\n\n  SwitchCase(this: GraphBuilderState, node: SwitchCase) {\n    this.baseVisit(node);\n    node.consequent.forEach((statement) => this.graph.addEdge(statement, node));\n    if (node.test) {\n      this.graph.addEdge(node, node.test);\n    }\n  },\n\n  SwitchStatement(this: GraphBuilderState, node: SwitchStatement) {\n    this.baseVisit(node);\n    node.cases.forEach((c) => this.graph.addEdge(c, node));\n    this.graph.addEdge(node, node.discriminant);\n  },\n\n  ForStatement(this: GraphBuilderState, node: ForStatement) {\n    this.baseVisit(node);\n\n    if (node.body) {\n      this.graph.addEdge(node.body, node);\n    }\n\n    [node.init, node.test, node.update, node.body].forEach((child) => {\n      if (child) {\n        this.graph.addEdge(node, child);\n      }\n    });\n  },\n\n  /*\n   * ForInStatement\n   * for (const k in o) { body }\n   */\n  ForInStatement(this: GraphBuilderState, node: ForInStatement) {\n    this.baseVisit(node);\n\n    if (node.body) {\n      this.graph.addEdge(node.body, node);\n      this.graph.addEdge(node, node.body);\n      this.graph.addEdge(node.body, node.left);\n    }\n\n    this.graph.addEdge(node.left, node.right);\n  },\n\n  /*\n   * BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement | YieldExpression | AwaitExpression\n   * All these nodes are required to evaluate the value of a function in which they are defined.\n   * Also, the value of these nodes depends on the argument if it is presented.\n   */\n  Terminatorless(this: GraphBuilderState, node: Terminatorless) {\n    this.baseVisit(node);\n\n    if (\n      !(t.isBreakStatement(node) || t.isContinueStatement(node)) &&\n      node.argument\n    ) {\n      this.graph.addEdge(node, node.argument);\n    }\n\n    const closestFunctionNode = peek(this.fnStack);\n    this.graph.addEdge(closestFunctionNode, node);\n  },\n\n  /*\n   * ObjectExpression\n   * Objects are… complicated. Especially because similarly looking code can be either an expression or a pattern.\n   * In this case we work with an expression like:\n   * const obj = {\n   *   method() {}, // ObjectMethod\n   *   property: \"value\", // ObjectProperty\n   *   ...rest, // SpreadElement\n   * }\n   */\n  ObjectExpression(this: GraphBuilderState, node: ObjectExpression) {\n    this.context.push('expression');\n    this.baseVisit(node);\n    node.properties.forEach((prop) => {\n      this.graph.addEdge(node, prop);\n      if (t.isObjectMethod(prop)) {\n        this.graph.addEdge(prop, prop.key);\n        this.graph.addEdge(prop, prop.body);\n      } else if (t.isObjectProperty(prop)) {\n        this.graph.addEdge(prop, prop.key);\n        this.graph.addEdge(prop, prop.value);\n      } else if (t.isSpreadElement(prop)) {\n        this.graph.addEdge(prop, prop.argument);\n      }\n    });\n    this.context.pop();\n  },\n\n  /*\n   * MemberExpression\n   * It's about a simple expression like `obj.foo` or `obj['foo']`.\n   * In addition to default behaviour (an expression depends on all its children),\n   * we add a backward dependency from an object to a node for processing member\n   * expressions in assignments.\n   *\n   * Example:\n   * let obj = { a: 1 };\n   * obj.b = 2;\n   *\n   * If we try to evaluate `obj` without backward dependency,\n   * `obj.b = 2` will be cut and we will get just `{ a: 1 }`.\n   */\n  MemberExpression(this: GraphBuilderState, node: MemberExpression) {\n    this.baseVisit(node);\n    this.graph.addEdge(node.object, node);\n\n    if (t.isIdentifier(node.object) && t.isIdentifier(node.property)) {\n      // It's simple `foo.bar` expression. Is it a usage of a required library?\n      const declaration = this.scope.getDeclaration(node.object);\n      if (declaration && this.graph.importAliases.has(declaration)) {\n        // It is. We can remember what exactly we use from it.\n        const source = this.graph.importAliases.get(declaration)!;\n        this.graph.imports.get(source)!.push(node.property);\n      }\n    }\n  },\n\n  /*\n   * AssignmentExpression\n   * `a = b`, `{ ...rest } = obj`, `obj.a = 3`, etc.\n   * It's not a declaration, it's just an assignment, but it affects\n   * the value of declared variable if the variable it mentioned in the left part.\n   * So, we apply some context-magic here in order to catch reference of variables in the left part.\n   * We switch the context to `lval` and continue traversing through the left branch.\n   * If we then meet some identifier, we mark it as a dependency of its declaration.\n   */\n  AssignmentExpression(this: GraphBuilderState, node: AssignmentExpression) {\n    this.context.push('lval');\n    this.visit<AssignmentExpression['left'], AssignmentExpression>(\n      node.left,\n      node,\n      'left'\n    );\n    this.context.pop();\n\n    this.visit(node.right, node, 'right');\n\n    // THe value of an expression depends on the left part.\n    this.graph.addEdge(node, node.left);\n    // this.graph.addEdge(node, node.right);\n\n    // The left part of an assignment depends on the right part.\n    this.graph.addEdge(node.left, node.right);\n\n    // At the same time, the left part doesn't make any sense without the whole expression.\n    this.graph.addEdge(node.left, node);\n  },\n\n  /*\n   * VariableDeclarator\n   * It would be pretty simple if it weren't used to declare variables from other modules.\n   */\n  VariableDeclarator(this: GraphBuilderState, node: VariableDeclarator) {\n    /*\n     * declared is used for detecting external dependencies in cases like\n     * const { a, b, c } = require('module');\n     *\n     * We are remembering all declared variables in order to use it later in CallExpression visitor\n     */\n    const declared: Array<[Identifier, Identifier | null]> = [];\n    this.meta.set('declared', declared);\n    const unregister = this.scope.addDeclareHandler((identifier, from) =>\n      declared.push([identifier, from])\n    );\n    this.baseVisit(node);\n    this.meta.delete('declared');\n    unregister();\n\n    if (node.init) {\n      // If there is an initialization part, the identifier depends on it.\n      this.graph.addEdge(node.id, node.init);\n    }\n\n    // If we want to evaluate the value of a declared identifier,\n    // we need to evaluate the whole expression.\n    this.graph.addEdge(node.id, node);\n\n    // If a statement is required itself, an id is also required\n    this.graph.addEdge(node, node.id);\n  },\n\n  /*\n   * VariableDeclaration\n   * It's just a wrapper for group of VariableDeclarator.\n   * If one of the declarators is required, the wrapper itself is also required.\n   */\n  VariableDeclaration(this: GraphBuilderState, node: VariableDeclaration) {\n    this.meta.set('kind-of-declaration', node.kind);\n    this.baseVisit(node);\n    node.declarations.forEach((declaration) =>\n      this.graph.addEdge(declaration, node)\n    );\n    this.meta.delete('kind-of-declaration');\n  },\n\n  /*\n   * CallExpression\n   * Do you remember that we have already mentioned it in VariableDeclarator?\n   * It is a simple expression with default behaviour unless it is a `require`.\n   *\n   * Another tricky use case here is functions with side effects (e.g. `Object.defineProperty`).\n   */\n  CallExpression(\n    this: GraphBuilderState,\n    node: CallExpression,\n    parent: Node | null\n  ) {\n    this.baseVisit(node);\n\n    if (t.isIdentifier(node.callee) && node.callee.name === 'require') {\n      // It looks like a module import …\n      const scopeId = this.scope.whereIsDeclared(node.callee);\n      if (scopeId && scopeId !== 'global') {\n        // … but it is just a user defined function\n        return;\n      }\n\n      const [firstArg] = node.arguments;\n      if (!t.isStringLiteral(firstArg)) {\n        // dynamic import? Maybe someday we can do something about it\n        return;\n      }\n\n      const { value: source } = firstArg;\n      const declared = this.meta.get('declared') as Array<\n        [Identifier, Identifier | null]\n      >;\n      if (!declared) {\n        // This is a standalone `require`\n        return;\n      }\n\n      // Define all declared variables as external dependencies.\n      declared.forEach(([local, _imported]) =>\n        // FIXME: var slugify = require('../slugify').default;\n        {\n          if (!this.graph.imports.has(source)) {\n            this.graph.imports.set(source, []);\n          }\n\n          if (\n            parent &&\n            t.isMemberExpression(parent) &&\n            t.isIdentifier(parent.property)\n          ) {\n            // An imported function is specified right here.\n            // eg. require('../slugify').default\n            this.graph.imports.get(source)!.push(parent.property);\n          } else {\n            if (\n              t.isCallExpression(parent) &&\n              t.isIdentifier(parent.callee) &&\n              typeof parent.callee.name === 'string'\n            ) {\n              if (parent.callee.name.startsWith('_interopRequireDefault')) {\n                this.graph.importTypes.set(source, 'default');\n              } else if (\n                parent.callee.name.startsWith('_interopRequireWildcard')\n              ) {\n                this.graph.importTypes.set(source, 'wildcard');\n              } else {\n                // What I've missed?\n              }\n            }\n\n            // The whole namespace was imported. We will know later, what exactly we need.\n            // eg. const slugify = require('../slugify');\n            this.graph.importAliases.set(local, source);\n          }\n        }\n      );\n\n      return;\n    }\n\n    sideEffects.forEach(([conditions, callback]) => {\n      if (\n        (conditions.callee && !conditions.callee(node.callee)) ||\n        (conditions.arguments && !conditions.arguments(node.arguments))\n      ) {\n        return;\n      }\n\n      return callback(node, this);\n    });\n\n    getAffectedNodes(node, this).forEach((affectedNode) => {\n      this.graph.addEdge(affectedNode, node);\n      if (t.isIdentifier(affectedNode)) {\n        this.graph.addEdge(\n          this.scope.getDeclaration(affectedNode)!,\n          affectedNode\n        );\n      }\n    });\n  },\n\n  /*\n   * SequenceExpression\n   * It is a special case of expression in which the value of the whole\n   * expression depends only on the last subexpression in the list.\n   * The rest of the subexpressions can be omitted if they don't have dependent nodes.\n   *\n   * Example:\n   * const a = (1, 2, b = 3, 4, b + 2); // `a` will be equal 5\n   */\n  SequenceExpression(this: GraphBuilderState, node: SequenceExpression) {\n    // Sequence value depends on only last expression in the list\n    this.baseVisit(node, true);\n    if (node.expressions.length > 0) {\n      this.graph.addEdge(node, node.expressions[node.expressions.length - 1]);\n    }\n  },\n};\n\nexport const identifierHandlers: IdentifierHandlers = {\n  declare: [\n    ['CatchClause', 'param'],\n    ['Function', 'params'],\n    ['FunctionExpression', 'id'],\n    ['RestElement', 'argument'],\n    ['ThrowStatement', 'argument'],\n    ['VariableDeclarator', 'id'],\n  ],\n  keep: [['ObjectProperty', 'key']],\n  refer: [\n    ['ArrayExpression', 'elements'],\n    ['AssignmentExpression', 'left', 'right'],\n    ['BinaryExpression', 'left', 'right'],\n    ['CallExpression', 'arguments', 'callee'],\n    ['ConditionalExpression', 'test', 'consequent', 'alternate'],\n    ['ForInStatement', 'right'],\n    ['Function', 'body'],\n    ['IfStatement', 'test'],\n    ['LogicalExpression', 'left', 'right'],\n    ['NewExpression', 'arguments', 'callee'],\n    ['ObjectProperty', 'value'],\n    ['ReturnStatement', 'argument'],\n    ['SequenceExpression', 'expressions'],\n    ['SwitchStatement', 'discriminant'],\n    ['UnaryExpression', 'argument'],\n    ['UpdateExpression', 'argument'],\n    ['VariableDeclarator', 'init'],\n  ],\n};\n"],"file":"core.js"}