function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { types as t } from '@babel/core';
const ResolvedNode = Symbol('ResolvedNode');
const functionScopes = new WeakSet();
export class PromisedNode {
  constructor() {
    _defineProperty(this, ResolvedNode, void 0);
  }

  static is(obj) {
    return obj && ResolvedNode in obj;
  }

  get identifier() {
    return this[ResolvedNode];
  }

}
export const resolveNode = obj => PromisedNode.is(obj) ? obj.identifier : obj;
const scopeIds = new WeakMap();

const getId = (scope, identifier) => `${scopeIds.get(scope)}:${identifier.name}`;

export default class ScopeManager {
  get global() {
    return this.map.get('global');
  }

  constructor() {
    _defineProperty(this, "nextId", 0);

    _defineProperty(this, "stack", []);

    _defineProperty(this, "map", new Map());

    _defineProperty(this, "handlers", new Map());

    _defineProperty(this, "declarations", new Map());

    this.new(true, 'global');
    this.declare(ScopeManager.globalExportsIdentifier, false);
    this.declare(ScopeManager.globalModuleIdentifier, false);
  }

  new(isFunction, scopeId = this.nextId++) {
    const scope = new Map();

    if (isFunction) {
      functionScopes.add(scope);
    }

    scopeIds.set(scope, scopeId);
    this.map.set(scopeId, scope);
    this.handlers.set(scopeId, []);
    this.stack.unshift(scope);
    return scope;
  }

  dispose() {
    const disposed = this.stack.shift();

    if (disposed) {
      this.map.delete(scopeIds.get(disposed));
    }

    return disposed;
  }

  declare(identifier, isHoistable, from = null, stack = 0) {
    const idName = identifier.name;
    const scope = this.stack.slice(stack).find(s => !isHoistable || functionScopes.has(s));

    if (this.global.has(idName)) {
      // It's probably a declaration of a previous referenced identifier
      // Let's use naÃ¯ve implementation of hoisting
      const promise = this.declarations.get(getId(this.global, identifier));
      promise[ResolvedNode] = identifier;
      scope.set(idName, new Set([identifier, ...Array.from(this.global.get(idName))]));
      this.global.delete(idName);
    } else {
      scope.set(idName, new Set([identifier]));
    }

    this.declarations.set(getId(scope, identifier), identifier);
    const handlers = this.handlers.get(scopeIds.get(scope));
    handlers.forEach(handler => handler(identifier, from));
  }

  addReference(identifier) {
    const name = identifier.name;
    const scope = this.stack.find(s => s.has(name)) || this.global;
    const id = getId(scope, identifier);

    if (scope === this.global && !scope.has(name)) {
      scope.set(name, new Set());
      this.declarations.set(getId(scope, identifier), new PromisedNode());
    }

    scope.get(name).add(identifier);
    return this.declarations.get(id);
  }

  whereIsDeclared(identifier) {
    const name = identifier.name;
    const scope = this.stack.find(s => s.has(name) && s.get(name).has(identifier));

    if (scope) {
      return scopeIds.get(scope);
    }

    if (this.global.has(name)) {
      return 'global';
    }

    return undefined;
  }

  getDeclaration(identifierOrName) {
    let name;

    if (typeof identifierOrName === 'string') {
      name = identifierOrName;
    } else {
      const scopeId = this.whereIsDeclared(identifierOrName);

      if (scopeId === undefined) {
        return undefined;
      }

      name = getId(this.map.get(scopeId), identifierOrName);
    }

    return resolveNode(this.declarations.get(name));
  }

  addDeclareHandler(handler) {
    const scopeId = scopeIds.get(this.stack[0]);
    this.handlers.get(scopeId).push(handler);
    return () => {
      const handlers = this.handlers.get(scopeId).filter(h => h !== handler);
      this.handlers.set(scopeId, handlers);
    };
  }

}

_defineProperty(ScopeManager, "globalExportsIdentifier", t.identifier('exports'));

_defineProperty(ScopeManager, "globalModuleIdentifier", t.identifier('module'));
//# sourceMappingURL=scope.js.map