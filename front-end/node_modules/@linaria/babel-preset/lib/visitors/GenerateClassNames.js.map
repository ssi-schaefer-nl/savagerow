{"version":3,"sources":["../../src/visitors/GenerateClassNames.ts"],"names":["GenerateClassNames","babel","path","state","options","types","t","styledOrCss","expressions","get","length","index","slug","displayName","predefinedClassName","parent","findParent","p","isObjectProperty","isJSXOpeningElement","isVariableDeclarator","parentNode","node","key","name","value","toString","keyPath","getSource","isJSXIdentifier","isIdentifier","id","file","opts","filename","test","replace","buildCodeFrameError","charAt","toLowerCase","root","className","classNameSlug","Error","classNameSlugVars","hash","title","optionVariables","match","cnSlug","i","l","v","slice","addComment"],"mappings":"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","sourcesContent":["/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it generates a slug that will be used as a CSS class for particular Template Expression,\n * and generates a display name for class or styled components.\n * It saves that meta data as comment above the template, to be later used in templateProcessor.\n */\n\nimport { basename, dirname, relative } from 'path';\nimport type { ObjectProperty, TaggedTemplateExpression } from '@babel/types';\nimport type { NodePath } from '@babel/traverse';\nimport { debug } from '@linaria/logger';\nimport type { State, StrictOptions } from '../types';\nimport toValidCSSIdentifier from '../utils/toValidCSSIdentifier';\nimport slugify from '../utils/slugify';\nimport getLinariaComment from '../utils/getLinariaComment';\nimport isStyledOrCss from '../utils/isStyledOrCss';\nimport { Core } from '../babel';\n\nexport default function GenerateClassNames(\n  babel: Core,\n  path: NodePath<TaggedTemplateExpression>,\n  state: State,\n  options: StrictOptions\n) {\n  const { types: t } = babel;\n  const styledOrCss = isStyledOrCss(babel, path, state);\n  if (!styledOrCss) {\n    return;\n  }\n\n  const expressions = path.get('quasi').get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  // Increment the index of the style we're processing\n  // This is used for slug generation to prevent collision\n  // Also used for display name if it couldn't be determined\n  state.index++;\n\n  let [slug, displayName, predefinedClassName] = getLinariaComment(path);\n\n  const parent = path.findParent(\n    (p) =>\n      t.isObjectProperty(p) ||\n      t.isJSXOpeningElement(p) ||\n      t.isVariableDeclarator(p)\n  );\n\n  if (!displayName && parent) {\n    const parentNode = parent.node;\n    if (t.isObjectProperty(parentNode)) {\n      if ('name' in parentNode.key) {\n        displayName = parentNode.key.name;\n      } else if ('value' in parentNode.key) {\n        displayName = parentNode.key.value.toString();\n      } else {\n        const keyPath = (parent as NodePath<ObjectProperty>).get('key');\n        displayName = keyPath.getSource();\n      }\n    } else if (\n      t.isJSXOpeningElement(parentNode) &&\n      t.isJSXIdentifier(parentNode.name)\n    ) {\n      displayName = parentNode.name.name;\n    } else if (\n      t.isVariableDeclarator(parentNode) &&\n      t.isIdentifier(parentNode.id)\n    ) {\n      displayName = parentNode.id.name;\n    }\n  }\n\n  if (!displayName) {\n    // Try to derive the path from the filename\n    displayName = basename(state.file.opts.filename);\n\n    if (/^index\\.[a-z0-9]+$/.test(displayName)) {\n      // If the file name is 'index', better to get name from parent folder\n      displayName = basename(dirname(state.file.opts.filename));\n    }\n\n    // Remove the file extension\n    displayName = displayName.replace(/\\.[a-z0-9]+$/, '');\n\n    if (displayName) {\n      displayName += state.index;\n    } else {\n      throw path.buildCodeFrameError(\n        \"Couldn't determine a name for the component. Ensure that it's either:\\n\" +\n          '- Assigned to a variable\\n' +\n          '- Is an object property\\n' +\n          '- Is a prop in a JSX element\\n'\n      );\n    }\n  }\n\n  // Custom properties need to start with a letter, so we prefix the slug\n  // Also use append the index of the class to the filename for uniqueness in the file\n  slug =\n    slug ||\n    toValidCSSIdentifier(\n      `${displayName.charAt(0).toLowerCase()}${slugify(\n        `${relative(state.file.opts.root, state.file.opts.filename)}:${\n          state.index\n        }`\n      )}`\n    );\n\n  let className = predefinedClassName\n    ? predefinedClassName\n    : options.displayName\n    ? `${toValidCSSIdentifier(displayName!)}_${slug!}`\n    : slug!;\n\n  // The className can be defined by the user either as fn or a string\n  if (typeof options.classNameSlug === 'function') {\n    try {\n      className = toValidCSSIdentifier(\n        options.classNameSlug(slug, displayName)\n      );\n    } catch {\n      throw new Error(`classNameSlug option must return a string`);\n    }\n  }\n\n  if (typeof options.classNameSlug === 'string') {\n    const { classNameSlug } = options;\n\n    // Available variables for the square brackets used in `classNameSlug` options\n    const classNameSlugVars: Record<string, string | null> = {\n      hash: slug,\n      title: displayName,\n    };\n\n    // Variables that were used in the config for `classNameSlug`\n    const optionVariables = classNameSlug.match(/\\[.*?]/g) || [];\n    let cnSlug = classNameSlug;\n\n    for (let i = 0, l = optionVariables.length; i < l; i++) {\n      const v = optionVariables[i].slice(1, -1); // Remove the brackets around the variable name\n\n      // Replace the var if it key and value exist otherwise place an empty string\n      cnSlug = cnSlug.replace(`[${v}]`, classNameSlugVars[v] || '');\n    }\n\n    className = toValidCSSIdentifier(cnSlug);\n  }\n\n  debug(\n    'template-parse:generated-meta',\n    `slug: ${slug}, displayName: ${displayName}, className: ${className}`\n  );\n\n  // Save evaluated slug and displayName for future usage in templateProcessor\n  path.addComment('leading', `linaria ${slug} ${displayName} ${className}`);\n}\n"],"file":"GenerateClassNames.js"}