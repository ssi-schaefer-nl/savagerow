{"version":3,"sources":["../../src/visitors/CollectDependencies.ts"],"names":["hoist","babel","ex","Identifier","idPath","isReferencedIdentifier","binding","scope","getBinding","node","name","path","bindingPath","referencePaths","parent","isVariableDeclarator","initPath","get","isIdentifier","forEach","referencePath","replaceWith","types","identifier","traverse","CollectDependencies","state","options","t","styledOrCss","expressions","length","expressionValues","map","result","evaluate","confident","value","kind","ValueType","VALUE","isFunctionExpression","isArrowFunctionExpression","originalExNode","cloneNode","hoistedExNode","LAZY","originalEx","FUNCTION","expressionValue","component","push","queue","styled","undefined"],"mappings":"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","sourcesContent":["/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.\n */\n\nimport type {\n  Expression,\n  Identifier as IdentifierNode,\n  TaggedTemplateExpression,\n} from '@babel/types';\nimport type { NodePath } from '@babel/traverse';\nimport { debug } from '@linaria/logger';\nimport throwIfInvalid from '../utils/throwIfInvalid';\nimport type { State, StrictOptions, ExpressionValue } from '../types';\nimport { ValueType } from '../types';\nimport isStyledOrCss from '../utils/isStyledOrCss';\nimport { Core } from '../babel';\n\n/**\n * Hoist the node and its dependencies to the highest scope possible\n */\nfunction hoist(babel: Core, ex: NodePath<Expression | null>) {\n  const Identifier = (idPath: NodePath<IdentifierNode>) => {\n    if (!idPath.isReferencedIdentifier()) {\n      return;\n    }\n    const binding = idPath.scope.getBinding(idPath.node.name);\n    if (!binding) return;\n    const { scope, path: bindingPath, referencePaths } = binding;\n    // parent here can be null or undefined in different versions of babel\n    if (!scope.parent) {\n      // It's a variable from global scope\n      return;\n    }\n\n    if (bindingPath.isVariableDeclarator()) {\n      const initPath = bindingPath.get('init') as NodePath<Expression | null>;\n      hoist(babel, initPath);\n      initPath.hoist(scope);\n      if (initPath.isIdentifier()) {\n        referencePaths.forEach((referencePath) => {\n          referencePath.replaceWith(babel.types.identifier(initPath.node.name));\n        });\n      }\n    }\n  };\n\n  if (ex.isIdentifier()) {\n    return Identifier(ex);\n  }\n\n  ex.traverse({\n    Identifier,\n  });\n}\n\nexport default function CollectDependencies(\n  babel: Core,\n  path: NodePath<TaggedTemplateExpression>,\n  state: State,\n  options: StrictOptions\n) {\n  const { types: t } = babel;\n  const styledOrCss = isStyledOrCss(babel, path, state);\n  if (!styledOrCss) {\n    return;\n  }\n  const expressions = path.get('quasi').get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  const expressionValues: ExpressionValue[] = expressions.map(\n    (ex: NodePath<Expression>) => {\n      const result = ex.evaluate();\n      if (result.confident) {\n        throwIfInvalid(result.value, ex);\n        return { kind: ValueType.VALUE, value: result.value };\n      }\n      if (\n        options.evaluate &&\n        !(t.isFunctionExpression(ex) || t.isArrowFunctionExpression(ex))\n      ) {\n        // save original expression that may be changed during hoisting\n        const originalExNode = t.cloneNode(ex.node);\n\n        hoist(babel, ex as NodePath<Expression | null>);\n\n        // save hoisted expression to be used to evaluation\n        const hoistedExNode = t.cloneNode(ex.node);\n\n        // get back original expression to the tree\n        ex.replaceWith(originalExNode);\n\n        return { kind: ValueType.LAZY, ex: hoistedExNode, originalEx: ex };\n      }\n\n      return { kind: ValueType.FUNCTION, ex };\n    }\n  );\n\n  debug(\n    'template-parse:evaluate-expressions',\n    expressionValues.map((expressionValue) =>\n      expressionValue.kind === ValueType.VALUE ? expressionValue.value : 'lazy'\n    )\n  );\n\n  if (styledOrCss !== 'css' && 'name' in styledOrCss.component.node) {\n    // It's not a real dependency.\n    // It can be simplified because we need just a className.\n    expressionValues.push({\n      // kind: ValueType.COMPONENT,\n      kind: ValueType.LAZY,\n      ex: styledOrCss.component.node.name,\n      originalEx: styledOrCss.component.node.name,\n    });\n  }\n\n  state.queue.push({\n    styled: styledOrCss !== 'css' ? styledOrCss : undefined,\n    path,\n    expressionValues,\n  });\n}\n"],"file":"CollectDependencies.js"}