"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isStyledOrCss;

var _hasImport = _interopRequireDefault(require("./hasImport"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const cache = new WeakMap();

function isStyledOrCss({
  types: t
}, path, state) {
  var _cache$get;

  if (!cache.has(path)) {
    const {
      tag
    } = path.node;
    const localName = state.file.metadata.localName || 'styled';

    if (t.isCallExpression(tag) && t.isIdentifier(tag.callee) && tag.arguments.length === 1 && tag.callee.name === localName && (0, _hasImport.default)(t, path.scope, state.file.opts.filename, localName, ['@linaria/react', 'linaria/react'])) {
      const tagPath = path.get('tag');
      cache.set(path, {
        component: tagPath.get('arguments')[0]
      });
    } else if (t.isMemberExpression(tag) && t.isIdentifier(tag.object) && t.isIdentifier(tag.property) && tag.object.name === localName && (0, _hasImport.default)(t, path.scope, state.file.opts.filename, localName, ['@linaria/react', 'linaria/react'])) {
      cache.set(path, {
        component: {
          node: t.stringLiteral(tag.property.name)
        }
      });
    } else if ((0, _hasImport.default)(t, path.scope, state.file.opts.filename, 'css', ['@linaria/core', 'linaria']) && t.isIdentifier(tag) && tag.name === 'css') {
      cache.set(path, 'css');
    } else {
      cache.set(path, null);
    }
  }

  return (_cache$get = cache.get(path)) !== null && _cache$get !== void 0 ? _cache$get : null;
}
//# sourceMappingURL=isStyledOrCss.js.map