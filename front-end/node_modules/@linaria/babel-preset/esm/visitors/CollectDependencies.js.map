{"version":3,"sources":["../../src/visitors/CollectDependencies.ts"],"names":["debug","throwIfInvalid","ValueType","isStyledOrCss","hoist","babel","ex","Identifier","idPath","isReferencedIdentifier","binding","scope","getBinding","node","name","path","bindingPath","referencePaths","parent","isVariableDeclarator","initPath","get","isIdentifier","forEach","referencePath","replaceWith","types","identifier","traverse","CollectDependencies","state","options","t","styledOrCss","expressions","length","expressionValues","map","result","evaluate","confident","value","kind","VALUE","isFunctionExpression","isArrowFunctionExpression","originalExNode","cloneNode","hoistedExNode","LAZY","originalEx","FUNCTION","expressionValue","component","push","queue","styled","undefined"],"mappings":"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","sourcesContent":["/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.\n */\n\nimport type {\n  Expression,\n  Identifier as IdentifierNode,\n  TaggedTemplateExpression,\n} from '@babel/types';\nimport type { NodePath } from '@babel/traverse';\nimport { debug } from '@linaria/logger';\nimport throwIfInvalid from '../utils/throwIfInvalid';\nimport type { State, StrictOptions, ExpressionValue } from '../types';\nimport { ValueType } from '../types';\nimport isStyledOrCss from '../utils/isStyledOrCss';\nimport { Core } from '../babel';\n\n/**\n * Hoist the node and its dependencies to the highest scope possible\n */\nfunction hoist(babel: Core, ex: NodePath<Expression | null>) {\n  const Identifier = (idPath: NodePath<IdentifierNode>) => {\n    if (!idPath.isReferencedIdentifier()) {\n      return;\n    }\n    const binding = idPath.scope.getBinding(idPath.node.name);\n    if (!binding) return;\n    const { scope, path: bindingPath, referencePaths } = binding;\n    // parent here can be null or undefined in different versions of babel\n    if (!scope.parent) {\n      // It's a variable from global scope\n      return;\n    }\n\n    if (bindingPath.isVariableDeclarator()) {\n      const initPath = bindingPath.get('init') as NodePath<Expression | null>;\n      hoist(babel, initPath);\n      initPath.hoist(scope);\n      if (initPath.isIdentifier()) {\n        referencePaths.forEach((referencePath) => {\n          referencePath.replaceWith(babel.types.identifier(initPath.node.name));\n        });\n      }\n    }\n  };\n\n  if (ex.isIdentifier()) {\n    return Identifier(ex);\n  }\n\n  ex.traverse({\n    Identifier,\n  });\n}\n\nexport default function CollectDependencies(\n  babel: Core,\n  path: NodePath<TaggedTemplateExpression>,\n  state: State,\n  options: StrictOptions\n) {\n  const { types: t } = babel;\n  const styledOrCss = isStyledOrCss(babel, path, state);\n  if (!styledOrCss) {\n    return;\n  }\n  const expressions = path.get('quasi').get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  const expressionValues: ExpressionValue[] = expressions.map(\n    (ex: NodePath<Expression>) => {\n      const result = ex.evaluate();\n      if (result.confident) {\n        throwIfInvalid(result.value, ex);\n        return { kind: ValueType.VALUE, value: result.value };\n      }\n      if (\n        options.evaluate &&\n        !(t.isFunctionExpression(ex) || t.isArrowFunctionExpression(ex))\n      ) {\n        // save original expression that may be changed during hoisting\n        const originalExNode = t.cloneNode(ex.node);\n\n        hoist(babel, ex as NodePath<Expression | null>);\n\n        // save hoisted expression to be used to evaluation\n        const hoistedExNode = t.cloneNode(ex.node);\n\n        // get back original expression to the tree\n        ex.replaceWith(originalExNode);\n\n        return { kind: ValueType.LAZY, ex: hoistedExNode, originalEx: ex };\n      }\n\n      return { kind: ValueType.FUNCTION, ex };\n    }\n  );\n\n  debug(\n    'template-parse:evaluate-expressions',\n    expressionValues.map((expressionValue) =>\n      expressionValue.kind === ValueType.VALUE ? expressionValue.value : 'lazy'\n    )\n  );\n\n  if (styledOrCss !== 'css' && 'name' in styledOrCss.component.node) {\n    // It's not a real dependency.\n    // It can be simplified because we need just a className.\n    expressionValues.push({\n      // kind: ValueType.COMPONENT,\n      kind: ValueType.LAZY,\n      ex: styledOrCss.component.node.name,\n      originalEx: styledOrCss.component.node.name,\n    });\n  }\n\n  state.queue.push({\n    styled: styledOrCss !== 'css' ? styledOrCss : undefined,\n    path,\n    expressionValues,\n  });\n}\n"],"file":"CollectDependencies.js"}