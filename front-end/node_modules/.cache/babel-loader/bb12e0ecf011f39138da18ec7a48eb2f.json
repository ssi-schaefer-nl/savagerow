{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.END_DRAG = exports.DROP = exports.HOVER = exports.PUBLISH_DRAG_SOURCE = exports.BEGIN_DRAG = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.beginDrag = beginDrag;\nexports.publishDragSource = publishDragSource;\nexports.hover = hover;\nexports.drop = drop;\nexports.endDrag = endDrag;\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _isObject = require('lodash/isObject');\n\nvar _isObject2 = _interopRequireDefault(_isObject);\n\nvar _matchesType = require('../utils/matchesType');\n\nvar _matchesType2 = _interopRequireDefault(_matchesType);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar BEGIN_DRAG = exports.BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';\nvar PUBLISH_DRAG_SOURCE = exports.PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';\nvar HOVER = exports.HOVER = 'dnd-core/HOVER';\nvar DROP = exports.DROP = 'dnd-core/DROP';\nvar END_DRAG = exports.END_DRAG = 'dnd-core/END_DRAG';\n\nfunction beginDrag(sourceIds) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    publishSource: true,\n    clientOffset: null\n  };\n  var publishSource = options.publishSource,\n      clientOffset = options.clientOffset,\n      getSourceClientOffset = options.getSourceClientOffset;\n  (0, _invariant2.default)((0, _isArray2.default)(sourceIds), 'Expected sourceIds to be an array.');\n  var monitor = this.getMonitor();\n  var registry = this.getRegistry();\n  (0, _invariant2.default)(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');\n\n  for (var i = 0; i < sourceIds.length; i++) {\n    (0, _invariant2.default)(registry.getSource(sourceIds[i]), 'Expected sourceIds to be registered.');\n  }\n\n  var sourceId = null;\n\n  for (var _i = sourceIds.length - 1; _i >= 0; _i--) {\n    if (monitor.canDragSource(sourceIds[_i])) {\n      sourceId = sourceIds[_i];\n      break;\n    }\n  }\n\n  if (sourceId === null) {\n    return;\n  }\n\n  var sourceClientOffset = null;\n\n  if (clientOffset) {\n    (0, _invariant2.default)(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');\n    sourceClientOffset = getSourceClientOffset(sourceId);\n  }\n\n  var source = registry.getSource(sourceId);\n  var item = source.beginDrag(monitor, sourceId);\n  (0, _invariant2.default)((0, _isObject2.default)(item), 'Item must be an object.');\n  registry.pinSource(sourceId);\n  var itemType = registry.getSourceType(sourceId);\n  return {\n    type: BEGIN_DRAG,\n    itemType: itemType,\n    item: item,\n    sourceId: sourceId,\n    clientOffset: clientOffset,\n    sourceClientOffset: sourceClientOffset,\n    isSourcePublic: publishSource\n  };\n}\n\nfunction publishDragSource() {\n  var monitor = this.getMonitor();\n\n  if (!monitor.isDragging()) {\n    return;\n  }\n\n  return {\n    type: PUBLISH_DRAG_SOURCE\n  };\n}\n\nfunction hover(targetIdsArg) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$clientOffset = _ref.clientOffset,\n      clientOffset = _ref$clientOffset === undefined ? null : _ref$clientOffset;\n\n  (0, _invariant2.default)((0, _isArray2.default)(targetIdsArg), 'Expected targetIds to be an array.');\n  var targetIds = targetIdsArg.slice(0);\n  var monitor = this.getMonitor();\n  var registry = this.getRegistry();\n  (0, _invariant2.default)(monitor.isDragging(), 'Cannot call hover while not dragging.');\n  (0, _invariant2.default)(!monitor.didDrop(), 'Cannot call hover after drop.'); // First check invariants.\n\n  for (var i = 0; i < targetIds.length; i++) {\n    var targetId = targetIds[i];\n    (0, _invariant2.default)(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n    var target = registry.getTarget(targetId);\n    (0, _invariant2.default)(target, 'Expected targetIds to be registered.');\n  }\n\n  var draggedItemType = monitor.getItemType(); // Remove those targetIds that don't match the targetType.  This\n  // fixes shallow isOver which would only be non-shallow because of\n  // non-matching targets.\n\n  for (var _i2 = targetIds.length - 1; _i2 >= 0; _i2--) {\n    var _targetId = targetIds[_i2];\n    var targetType = registry.getTargetType(_targetId);\n\n    if (!(0, _matchesType2.default)(targetType, draggedItemType)) {\n      targetIds.splice(_i2, 1);\n    }\n  } // Finally call hover on all matching targets.\n\n\n  for (var _i3 = 0; _i3 < targetIds.length; _i3++) {\n    var _targetId2 = targetIds[_i3];\n\n    var _target = registry.getTarget(_targetId2);\n\n    _target.hover(monitor, _targetId2);\n  }\n\n  return {\n    type: HOVER,\n    targetIds: targetIds,\n    clientOffset: clientOffset\n  };\n}\n\nfunction drop() {\n  var _this = this;\n\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var monitor = this.getMonitor();\n  var registry = this.getRegistry();\n  (0, _invariant2.default)(monitor.isDragging(), 'Cannot call drop while not dragging.');\n  (0, _invariant2.default)(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');\n  var targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n  targetIds.reverse();\n  targetIds.forEach(function (targetId, index) {\n    var target = registry.getTarget(targetId);\n    var dropResult = target.drop(monitor, targetId);\n    (0, _invariant2.default)(typeof dropResult === 'undefined' || (0, _isObject2.default)(dropResult), 'Drop result must either be an object or undefined.');\n\n    if (typeof dropResult === 'undefined') {\n      dropResult = index === 0 ? {} : monitor.getDropResult();\n    }\n\n    _this.store.dispatch({\n      type: DROP,\n      dropResult: _extends({}, options, dropResult)\n    });\n  });\n}\n\nfunction endDrag() {\n  var monitor = this.getMonitor();\n  var registry = this.getRegistry();\n  (0, _invariant2.default)(monitor.isDragging(), 'Cannot call endDrag while not dragging.');\n  var sourceId = monitor.getSourceId();\n  var source = registry.getSource(sourceId, true);\n  source.endDrag(monitor, sourceId);\n  registry.unpinSource();\n  return {\n    type: END_DRAG\n  };\n}","map":{"version":3,"sources":["C:/Users/vincent/git/savagerow/front-end/node_modules/dnd-core/lib/actions/dragDrop.js"],"names":["Object","defineProperty","exports","value","END_DRAG","DROP","HOVER","PUBLISH_DRAG_SOURCE","BEGIN_DRAG","undefined","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","beginDrag","publishDragSource","hover","drop","endDrag","_invariant","require","_invariant2","_interopRequireDefault","_isArray","_isArray2","_isObject","_isObject2","_matchesType","_matchesType2","obj","__esModule","default","sourceIds","options","publishSource","clientOffset","getSourceClientOffset","monitor","getMonitor","registry","getRegistry","isDragging","getSource","sourceId","_i","canDragSource","sourceClientOffset","item","pinSource","itemType","getSourceType","type","isSourcePublic","targetIdsArg","_ref","_ref$clientOffset","targetIds","slice","didDrop","targetId","lastIndexOf","getTarget","draggedItemType","getItemType","_i2","_targetId","targetType","getTargetType","splice","_i3","_targetId2","_target","_this","getTargetIds","filter","canDropOnTarget","reverse","forEach","index","dropResult","getDropResult","store","dispatch","getSourceId","unpinSource"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.END_DRAG = exports.DROP = exports.HOVER = exports.PUBLISH_DRAG_SOURCE = exports.BEGIN_DRAG = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.beginDrag = beginDrag;\nexports.publishDragSource = publishDragSource;\nexports.hover = hover;\nexports.drop = drop;\nexports.endDrag = endDrag;\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _isObject = require('lodash/isObject');\n\nvar _isObject2 = _interopRequireDefault(_isObject);\n\nvar _matchesType = require('../utils/matchesType');\n\nvar _matchesType2 = _interopRequireDefault(_matchesType);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar BEGIN_DRAG = exports.BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';\nvar PUBLISH_DRAG_SOURCE = exports.PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';\nvar HOVER = exports.HOVER = 'dnd-core/HOVER';\nvar DROP = exports.DROP = 'dnd-core/DROP';\nvar END_DRAG = exports.END_DRAG = 'dnd-core/END_DRAG';\n\nfunction beginDrag(sourceIds) {\n\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { publishSource: true, clientOffset: null };\n\tvar publishSource = options.publishSource,\n\t    clientOffset = options.clientOffset,\n\t    getSourceClientOffset = options.getSourceClientOffset;\n\n\t(0, _invariant2.default)((0, _isArray2.default)(sourceIds), 'Expected sourceIds to be an array.');\n\n\tvar monitor = this.getMonitor();\n\tvar registry = this.getRegistry();\n\t(0, _invariant2.default)(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');\n\n\tfor (var i = 0; i < sourceIds.length; i++) {\n\t\t(0, _invariant2.default)(registry.getSource(sourceIds[i]), 'Expected sourceIds to be registered.');\n\t}\n\n\tvar sourceId = null;\n\tfor (var _i = sourceIds.length - 1; _i >= 0; _i--) {\n\t\tif (monitor.canDragSource(sourceIds[_i])) {\n\t\t\tsourceId = sourceIds[_i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (sourceId === null) {\n\t\treturn;\n\t}\n\n\tvar sourceClientOffset = null;\n\tif (clientOffset) {\n\t\t(0, _invariant2.default)(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');\n\t\tsourceClientOffset = getSourceClientOffset(sourceId);\n\t}\n\n\tvar source = registry.getSource(sourceId);\n\tvar item = source.beginDrag(monitor, sourceId);\n\t(0, _invariant2.default)((0, _isObject2.default)(item), 'Item must be an object.');\n\n\tregistry.pinSource(sourceId);\n\n\tvar itemType = registry.getSourceType(sourceId);\n\treturn {\n\t\ttype: BEGIN_DRAG,\n\t\titemType: itemType,\n\t\titem: item,\n\t\tsourceId: sourceId,\n\t\tclientOffset: clientOffset,\n\t\tsourceClientOffset: sourceClientOffset,\n\t\tisSourcePublic: publishSource\n\t};\n}\n\nfunction publishDragSource() {\n\tvar monitor = this.getMonitor();\n\tif (!monitor.isDragging()) {\n\t\treturn;\n\t}\n\n\treturn { type: PUBLISH_DRAG_SOURCE };\n}\n\nfunction hover(targetIdsArg) {\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$clientOffset = _ref.clientOffset,\n\t    clientOffset = _ref$clientOffset === undefined ? null : _ref$clientOffset;\n\n\t(0, _invariant2.default)((0, _isArray2.default)(targetIdsArg), 'Expected targetIds to be an array.');\n\tvar targetIds = targetIdsArg.slice(0);\n\n\tvar monitor = this.getMonitor();\n\tvar registry = this.getRegistry();\n\t(0, _invariant2.default)(monitor.isDragging(), 'Cannot call hover while not dragging.');\n\t(0, _invariant2.default)(!monitor.didDrop(), 'Cannot call hover after drop.');\n\n\t// First check invariants.\n\tfor (var i = 0; i < targetIds.length; i++) {\n\t\tvar targetId = targetIds[i];\n\t\t(0, _invariant2.default)(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n\n\t\tvar target = registry.getTarget(targetId);\n\t\t(0, _invariant2.default)(target, 'Expected targetIds to be registered.');\n\t}\n\n\tvar draggedItemType = monitor.getItemType();\n\n\t// Remove those targetIds that don't match the targetType.  This\n\t// fixes shallow isOver which would only be non-shallow because of\n\t// non-matching targets.\n\tfor (var _i2 = targetIds.length - 1; _i2 >= 0; _i2--) {\n\t\tvar _targetId = targetIds[_i2];\n\t\tvar targetType = registry.getTargetType(_targetId);\n\t\tif (!(0, _matchesType2.default)(targetType, draggedItemType)) {\n\t\t\ttargetIds.splice(_i2, 1);\n\t\t}\n\t}\n\n\t// Finally call hover on all matching targets.\n\tfor (var _i3 = 0; _i3 < targetIds.length; _i3++) {\n\t\tvar _targetId2 = targetIds[_i3];\n\t\tvar _target = registry.getTarget(_targetId2);\n\t\t_target.hover(monitor, _targetId2);\n\t}\n\n\treturn {\n\t\ttype: HOVER,\n\t\ttargetIds: targetIds,\n\t\tclientOffset: clientOffset\n\t};\n}\n\nfunction drop() {\n\tvar _this = this;\n\n\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\tvar monitor = this.getMonitor();\n\tvar registry = this.getRegistry();\n\t(0, _invariant2.default)(monitor.isDragging(), 'Cannot call drop while not dragging.');\n\t(0, _invariant2.default)(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');\n\n\tvar targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n\n\ttargetIds.reverse();\n\ttargetIds.forEach(function (targetId, index) {\n\t\tvar target = registry.getTarget(targetId);\n\n\t\tvar dropResult = target.drop(monitor, targetId);\n\t\t(0, _invariant2.default)(typeof dropResult === 'undefined' || (0, _isObject2.default)(dropResult), 'Drop result must either be an object or undefined.');\n\t\tif (typeof dropResult === 'undefined') {\n\t\t\tdropResult = index === 0 ? {} : monitor.getDropResult();\n\t\t}\n\n\t\t_this.store.dispatch({\n\t\t\ttype: DROP,\n\t\t\tdropResult: _extends({}, options, dropResult)\n\t\t});\n\t});\n}\n\nfunction endDrag() {\n\tvar monitor = this.getMonitor();\n\tvar registry = this.getRegistry();\n\t(0, _invariant2.default)(monitor.isDragging(), 'Cannot call endDrag while not dragging.');\n\n\tvar sourceId = monitor.getSourceId();\n\tvar source = registry.getSource(sourceId, true);\n\tsource.endDrag(monitor, sourceId);\n\n\tregistry.unpinSource();\n\n\treturn { type: END_DRAG };\n}"]},"metadata":{},"sourceType":"script"}