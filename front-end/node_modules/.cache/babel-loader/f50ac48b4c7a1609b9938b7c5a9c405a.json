{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNodeClientOffset = getNodeClientOffset;\nexports.getEventClientOffset = getEventClientOffset;\nexports.getDragPreviewOffset = getDragPreviewOffset;\n\nvar _BrowserDetector = require('./BrowserDetector');\n\nvar _MonotonicInterpolant = require('./MonotonicInterpolant');\n\nvar _MonotonicInterpolant2 = _interopRequireDefault(_MonotonicInterpolant);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint\n   no-mixed-operators: off\n*/\n\n\nvar ELEMENT_NODE = 1;\n\nfunction getNodeClientOffset(node) {\n  var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n\n  if (!el) {\n    return null;\n  }\n\n  var _el$getBoundingClient = el.getBoundingClientRect(),\n      top = _el$getBoundingClient.top,\n      left = _el$getBoundingClient.left;\n\n  return {\n    x: left,\n    y: top\n  };\n}\n\nfunction getEventClientOffset(e) {\n  return {\n    x: e.clientX,\n    y: e.clientY\n  };\n}\n\nfunction isImageNode(node) {\n  return node.nodeName === 'IMG' && ((0, _BrowserDetector.isFirefox)() || !document.documentElement.contains(node));\n}\n\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n  var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n  var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight; // Work around @2x coordinate discrepancies in browsers\n\n  if ((0, _BrowserDetector.isSafari)() && isImage) {\n    dragPreviewHeight /= window.devicePixelRatio;\n    dragPreviewWidth /= window.devicePixelRatio;\n  }\n\n  return {\n    dragPreviewWidth: dragPreviewWidth,\n    dragPreviewHeight: dragPreviewHeight\n  };\n}\n\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n  // The browsers will use the image intrinsic size under different conditions.\n  // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n  var isImage = isImageNode(dragPreview);\n  var dragPreviewNode = isImage ? sourceNode : dragPreview;\n  var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n  var offsetFromDragPreview = {\n    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n  };\n  var sourceWidth = sourceNode.offsetWidth,\n      sourceHeight = sourceNode.offsetHeight;\n  var anchorX = anchorPoint.anchorX,\n      anchorY = anchorPoint.anchorY;\n\n  var _getDragPreviewSize = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight),\n      dragPreviewWidth = _getDragPreviewSize.dragPreviewWidth,\n      dragPreviewHeight = _getDragPreviewSize.dragPreviewHeight;\n\n  var calculateYOffset = function calculateYOffset() {\n    var interpolantY = new _MonotonicInterpolant2.default([0, 0.5, 1], [// Dock to the top\n    offsetFromDragPreview.y, // Align at the center\n    offsetFromDragPreview.y / sourceHeight * dragPreviewHeight, // Dock to the bottom\n    offsetFromDragPreview.y + dragPreviewHeight - sourceHeight]);\n    var y = interpolantY.interpolate(anchorY); // Work around Safari 8 positioning bug\n\n    if ((0, _BrowserDetector.isSafari)() && isImage) {\n      // We'll have to wait for @3x to see if this is entirely correct\n      y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n    }\n\n    return y;\n  };\n\n  var calculateXOffset = function calculateXOffset() {\n    // Interpolate coordinates depending on anchor point\n    // If you know a simpler way to do this, let me know\n    var interpolantX = new _MonotonicInterpolant2.default([0, 0.5, 1], [// Dock to the left\n    offsetFromDragPreview.x, // Align at the center\n    offsetFromDragPreview.x / sourceWidth * dragPreviewWidth, // Dock to the right\n    offsetFromDragPreview.x + dragPreviewWidth - sourceWidth]);\n    return interpolantX.interpolate(anchorX);\n  }; // Force offsets if specified in the options.\n\n\n  var offsetX = offsetPoint.offsetX,\n      offsetY = offsetPoint.offsetY;\n  var isManualOffsetX = offsetX === 0 || offsetX;\n  var isManualOffsetY = offsetY === 0 || offsetY;\n  return {\n    x: isManualOffsetX ? offsetX : calculateXOffset(),\n    y: isManualOffsetY ? offsetY : calculateYOffset()\n  };\n}","map":{"version":3,"sources":["C:/Users/vincent/git/savagerow/front-end/node_modules/react-dnd-html5-backend/lib/OffsetUtils.js"],"names":["Object","defineProperty","exports","value","getNodeClientOffset","getEventClientOffset","getDragPreviewOffset","_BrowserDetector","require","_MonotonicInterpolant","_MonotonicInterpolant2","_interopRequireDefault","obj","__esModule","default","ELEMENT_NODE","node","el","nodeType","parentElement","_el$getBoundingClient","getBoundingClientRect","top","left","x","y","e","clientX","clientY","isImageNode","nodeName","isFirefox","document","documentElement","contains","getDragPreviewSize","isImage","dragPreview","sourceWidth","sourceHeight","dragPreviewWidth","width","dragPreviewHeight","height","isSafari","window","devicePixelRatio","sourceNode","clientOffset","anchorPoint","offsetPoint","dragPreviewNode","dragPreviewNodeOffsetFromClient","offsetFromDragPreview","offsetWidth","offsetHeight","anchorX","anchorY","_getDragPreviewSize","calculateYOffset","interpolantY","interpolate","calculateXOffset","interpolantX","offsetX","offsetY","isManualOffsetX","isManualOffsetY"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.getNodeClientOffset = getNodeClientOffset;\nexports.getEventClientOffset = getEventClientOffset;\nexports.getDragPreviewOffset = getDragPreviewOffset;\n\nvar _BrowserDetector = require('./BrowserDetector');\n\nvar _MonotonicInterpolant = require('./MonotonicInterpolant');\n\nvar _MonotonicInterpolant2 = _interopRequireDefault(_MonotonicInterpolant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint\n   no-mixed-operators: off\n*/\nvar ELEMENT_NODE = 1;\n\nfunction getNodeClientOffset(node) {\n\tvar el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n\n\tif (!el) {\n\t\treturn null;\n\t}\n\n\tvar _el$getBoundingClient = el.getBoundingClientRect(),\n\t    top = _el$getBoundingClient.top,\n\t    left = _el$getBoundingClient.left;\n\n\treturn { x: left, y: top };\n}\n\nfunction getEventClientOffset(e) {\n\treturn {\n\t\tx: e.clientX,\n\t\ty: e.clientY\n\t};\n}\n\nfunction isImageNode(node) {\n\treturn node.nodeName === 'IMG' && ((0, _BrowserDetector.isFirefox)() || !document.documentElement.contains(node));\n}\n\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n\tvar dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n\tvar dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n\n\t// Work around @2x coordinate discrepancies in browsers\n\tif ((0, _BrowserDetector.isSafari)() && isImage) {\n\t\tdragPreviewHeight /= window.devicePixelRatio;\n\t\tdragPreviewWidth /= window.devicePixelRatio;\n\t}\n\treturn { dragPreviewWidth: dragPreviewWidth, dragPreviewHeight: dragPreviewHeight };\n}\n\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n\t// The browsers will use the image intrinsic size under different conditions.\n\t// Firefox only cares if it's an image, but WebKit also wants it to be detached.\n\tvar isImage = isImageNode(dragPreview);\n\tvar dragPreviewNode = isImage ? sourceNode : dragPreview;\n\tvar dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n\tvar offsetFromDragPreview = {\n\t\tx: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n\t\ty: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n\t};\n\tvar sourceWidth = sourceNode.offsetWidth,\n\t    sourceHeight = sourceNode.offsetHeight;\n\tvar anchorX = anchorPoint.anchorX,\n\t    anchorY = anchorPoint.anchorY;\n\n\tvar _getDragPreviewSize = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight),\n\t    dragPreviewWidth = _getDragPreviewSize.dragPreviewWidth,\n\t    dragPreviewHeight = _getDragPreviewSize.dragPreviewHeight;\n\n\tvar calculateYOffset = function calculateYOffset() {\n\t\tvar interpolantY = new _MonotonicInterpolant2.default([0, 0.5, 1], [\n\t\t// Dock to the top\n\t\toffsetFromDragPreview.y,\n\t\t// Align at the center\n\t\toffsetFromDragPreview.y / sourceHeight * dragPreviewHeight,\n\t\t// Dock to the bottom\n\t\toffsetFromDragPreview.y + dragPreviewHeight - sourceHeight]);\n\t\tvar y = interpolantY.interpolate(anchorY);\n\t\t// Work around Safari 8 positioning bug\n\t\tif ((0, _BrowserDetector.isSafari)() && isImage) {\n\t\t\t// We'll have to wait for @3x to see if this is entirely correct\n\t\t\ty += (window.devicePixelRatio - 1) * dragPreviewHeight;\n\t\t}\n\t\treturn y;\n\t};\n\n\tvar calculateXOffset = function calculateXOffset() {\n\t\t// Interpolate coordinates depending on anchor point\n\t\t// If you know a simpler way to do this, let me know\n\t\tvar interpolantX = new _MonotonicInterpolant2.default([0, 0.5, 1], [\n\t\t// Dock to the left\n\t\toffsetFromDragPreview.x,\n\t\t// Align at the center\n\t\toffsetFromDragPreview.x / sourceWidth * dragPreviewWidth,\n\t\t// Dock to the right\n\t\toffsetFromDragPreview.x + dragPreviewWidth - sourceWidth]);\n\t\treturn interpolantX.interpolate(anchorX);\n\t};\n\n\t// Force offsets if specified in the options.\n\tvar offsetX = offsetPoint.offsetX,\n\t    offsetY = offsetPoint.offsetY;\n\n\tvar isManualOffsetX = offsetX === 0 || offsetX;\n\tvar isManualOffsetY = offsetY === 0 || offsetY;\n\treturn {\n\t\tx: isManualOffsetX ? offsetX : calculateXOffset(),\n\t\ty: isManualOffsetY ? offsetY : calculateYOffset()\n\t};\n}"]},"metadata":{},"sourceType":"script"}