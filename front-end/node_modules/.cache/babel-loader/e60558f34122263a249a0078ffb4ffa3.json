{"ast":null,"code":"import { __values } from \"tslib\";\nimport Resolver from './RowGrouperResolver';\n\nvar RowGrouper =\n/** @class */\nfunction () {\n  function RowGrouper(columns, expandedRows) {\n    this.columns = columns.slice(0);\n    this.expandedRows = expandedRows;\n    this.resolver = new Resolver();\n  }\n\n  RowGrouper.prototype.isRowExpanded = function (columnName, name) {\n    var expandedRowGroup = this.expandedRows[columnName];\n\n    if (expandedRowGroup && expandedRowGroup[name]) {\n      return expandedRowGroup[name].isExpanded;\n    }\n\n    return true;\n  };\n\n  RowGrouper.prototype.groupRowsByColumn = function (rows, columnIndex) {\n    var e_1, _a;\n\n    if (columnIndex === void 0) {\n      columnIndex = 0;\n    }\n\n    var nextColumnIndex = columnIndex;\n    var columnName = this.columns.length > 0 && typeof this.columns[columnIndex] === 'string' ? this.columns[columnIndex] : this.columns[columnIndex].key;\n    var columnGroupDisplayName = this.columns.length > 0 && typeof this.columns[columnIndex] === 'string' ? this.columns[columnIndex] : this.columns[columnIndex].name;\n    var groupedRows = this.resolver.getGroupedRows(rows, columnName);\n    var keys = this.resolver.getGroupKeys(groupedRows);\n    var dataviewRows = this.resolver.initRowsCollection();\n\n    try {\n      for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n        var key = keys_1_1.value;\n        var isExpanded = this.isRowExpanded(columnName, key);\n        var rowGroupHeader = {\n          name: key,\n          __metaData: {\n            isGroup: true,\n            treeDepth: columnIndex,\n            isExpanded: isExpanded,\n            columnGroupName: columnName,\n            columnGroupDisplayName: columnGroupDisplayName\n          }\n        };\n        dataviewRows = this.resolver.addHeaderRow(rowGroupHeader, dataviewRows);\n\n        if (isExpanded) {\n          nextColumnIndex = columnIndex + 1;\n\n          if (this.columns.length > nextColumnIndex) {\n            dataviewRows = dataviewRows.concat(this.groupRowsByColumn(groupedRows[key], nextColumnIndex));\n            nextColumnIndex = columnIndex - 1;\n          } else {\n            dataviewRows = dataviewRows.concat(groupedRows[key]);\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return dataviewRows;\n  };\n\n  return RowGrouper;\n}();\n\nvar groupRows = function (rows, groupedColumns, expandedRows) {\n  var rowGrouper = new RowGrouper(groupedColumns, expandedRows);\n  return rowGrouper.groupRowsByColumn(rows, 0);\n};\n\nexport default groupRows;","map":{"version":3,"sources":["../../src/data/RowGrouper.js"],"names":[],"mappings":"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","sourcesContent":["import Resolver from './RowGrouperResolver';\n\nclass RowGrouper {\n  constructor(columns, expandedRows) {\n    this.columns = columns.slice(0);\n    this.expandedRows = expandedRows;\n    this.resolver = new Resolver();\n  }\n\n  isRowExpanded(columnName, name) {\n    const expandedRowGroup = this.expandedRows[columnName];\n    if (expandedRowGroup && expandedRowGroup[name]) {\n      return expandedRowGroup[name].isExpanded;\n    }\n    return true;\n  }\n\n  groupRowsByColumn(rows, columnIndex = 0) {\n    let nextColumnIndex = columnIndex;\n    const columnName = this.columns.length > 0 && typeof this.columns[columnIndex] === 'string' ? this.columns[columnIndex] : this.columns[columnIndex].key;\n    const columnGroupDisplayName = this.columns.length > 0 && typeof this.columns[columnIndex] === 'string' ? this.columns[columnIndex] : this.columns[columnIndex].name;\n    const groupedRows = this.resolver.getGroupedRows(rows, columnName);\n    const keys = this.resolver.getGroupKeys(groupedRows);\n    let dataviewRows = this.resolver.initRowsCollection();\n\n    for (const key of keys) {\n      const isExpanded = this.isRowExpanded(columnName, key);\n      const rowGroupHeader = { name: key, __metaData: { isGroup: true, treeDepth: columnIndex, isExpanded, columnGroupName: columnName, columnGroupDisplayName } };\n\n      dataviewRows = this.resolver.addHeaderRow(rowGroupHeader, dataviewRows);\n\n      if (isExpanded) {\n        nextColumnIndex = columnIndex + 1;\n        if (this.columns.length > nextColumnIndex) {\n          dataviewRows = dataviewRows.concat(this.groupRowsByColumn(groupedRows[key], nextColumnIndex));\n          nextColumnIndex = columnIndex - 1;\n        } else {\n          dataviewRows = dataviewRows.concat(groupedRows[key]);\n        }\n      }\n    }\n    return dataviewRows;\n  }\n}\n\nconst groupRows = (rows, groupedColumns, expandedRows) => {\n  const rowGrouper = new RowGrouper(groupedColumns, expandedRows);\n  return rowGrouper.groupRowsByColumn(rows, 0);\n};\n\nexport default groupRows;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}