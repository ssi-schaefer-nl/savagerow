{"ast":null,"code":"import { useRef, useEffect, useState, useLayoutEffect, useMemo, useCallback, memo, forwardRef, useImperativeHandle } from 'react';\nimport clsx from 'clsx';\nimport { jsxs, jsx, Fragment } from 'react/jsx-runtime';\nimport { createPortal } from 'react-dom';\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z$c = \".c1wupbe700-canary38{contain:strict;contain:size layout style paint;padding:0 8px;border-right:1px solid var(--border-color);border-bottom:1px solid var(--border-color);background-color:inherit;white-space:nowrap;overflow:hidden;overflow:clip;text-overflow:ellipsis}.cd0kgiy700-canary38{position:-webkit-sticky;position:sticky;z-index:1}.c1730fa4700-canary38{box-shadow:2px 0 5px -2px hsla(0,0%,53.3%,.3)}.c9dpaye700-canary38{box-shadow:inset 0 0 0 2px var(--selection-color)}\";\nstyleInject(css_248z$c);\nconst cell = \"c1wupbe700-canary38\";\nconst cellClassname = `rdg-cell ${cell}`;\nconst cellFrozen = \"cd0kgiy700-canary38\";\nconst cellFrozenClassname = `rdg-cell-frozen ${cellFrozen}`;\nconst cellFrozenLast = \"c1730fa4700-canary38\";\nconst cellFrozenLastClassname = `rdg-cell-frozen-last ${cellFrozenLast}`;\nconst cellSelected = \"c9dpaye700-canary38\";\nconst cellSelectedClassname = `rdg-cell-selected ${cellSelected}`;\nvar css_248z$b = \".r104f42s700-canary38{--color:#000;--border-color:#ddd;--summary-border-color:#aaa;--background-color:hsl(0deg 0% 100%);--header-background-color:hsl(0deg 0% 97.5%);--row-hover-background-color:hsl(0deg 0% 96%);--row-selected-background-color:hsl(207deg 76% 92%);--row-selected-hover-background-color:hsl(207deg 76% 88%);--checkbox-color:hsl(207deg 100% 29%);--checkbox-focus-color:hsl(207deg 100% 69%);--checkbox-disabled-border-color:#ccc;--checkbox-disabled-background-color:#ddd;--selection-color:#66afe9;--font-size:14px;contain:strict;contain:size layout style paint;content-visibility:auto;height:350px;border:1px solid var(--border-color);box-sizing:border-box;overflow:auto;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:var(--background-color);color:var(--color);font-size:var(--font-size)}@supports not (contain:strict){.r104f42s700-canary38{position:relative;z-index:0}}.r104f42s700-canary38 *,.r104f42s700-canary38 :after,.r104f42s700-canary38 :before{box-sizing:inherit}.r104f42s700-canary38.rdg-dark{--color:#ddd;--border-color:#444;--summary-border-color:#555;--background-color:hsl(0deg 0% 13%);--header-background-color:hsl(0deg 0% 10.5%);--row-hover-background-color:hsl(0deg 0% 9%);--row-selected-background-color:hsl(207deg 76% 42%);--row-selected-hover-background-color:hsl(207deg 76% 38%);--checkbox-color:hsl(207deg 100% 79%);--checkbox-focus-color:hsl(207deg 100% 89%);--checkbox-disabled-border-color:#000;--checkbox-disabled-background-color:#333}@media (prefers-color-scheme:dark){.r104f42s700-canary38:not(.rdg-light){--color:#ddd;--border-color:#444;--summary-border-color:#555;--background-color:hsl(0deg 0% 13%);--header-background-color:hsl(0deg 0% 10.5%);--row-hover-background-color:hsl(0deg 0% 9%);--row-selected-background-color:hsl(207deg 76% 42%);--row-selected-hover-background-color:hsl(207deg 76% 38%);--checkbox-color:hsl(207deg 100% 79%);--checkbox-focus-color:hsl(207deg 100% 89%);--checkbox-disabled-border-color:#000;--checkbox-disabled-background-color:#333}}.f7ly7s700-canary38{position:-webkit-sticky;position:sticky;top:0;left:0;height:0;width:0;outline:0}.vc4f4zb700-canary38.r1otpg64700-canary38{cursor:move}\";\nstyleInject(css_248z$b);\nconst root = \"r104f42s700-canary38\";\nconst rootClassname = `rdg ${root}`;\nconst focusSink = \"f7ly7s700-canary38\";\nconst focusSinkClassname = `rdg-focus-sink ${focusSink}`;\nconst viewportDragging = \"vc4f4zb700-canary38\";\nconst viewportDraggingClassname = `rdg-viewport-dragging ${viewportDragging}`;\nvar css_248z$a = \".g1cvx5us700-canary38:not(.rel5gk2700-canary38){background-color:var(--header-background-color)}.g1cvx5us700-canary38>.c1wupbe700-canary38:not(:last-child):not(.c1730fa4700-canary38){border-right:none}.g1j2w62i700-canary38:after{content:\\\"\\\";position:absolute;top:0;right:0;bottom:0;left:0;box-shadow:inset 0 0 0 2px var(--selection-color);pointer-events:none;z-index:2}.g1j2w62i700-canary38>.c1wupbe700-canary38:first-child{box-shadow:inset 2px 0 0 0 var(--selection-color)}\";\nstyleInject(css_248z$a);\nconst groupRow = \"g1cvx5us700-canary38\";\nconst groupRowClassname = `rdg-group-row ${groupRow}`;\nconst groupRowSelected = \"g1j2w62i700-canary38\";\nconst groupRowSelectedClassname = `rdg-group-row-selected ${groupRowSelected}`;\nvar css_248z$9 = \".h1fquj5h700-canary38{contain:strict;contain:size layout style paint;display:grid;grid-template-columns:var(--template-columns);width:var(--row-width);position:-webkit-sticky;position:sticky;background-color:var(--header-background-color);font-weight:700;z-index:3}.h19m9p7h700-canary38{grid-template-rows:var(--header-row-height);height:var(--header-row-height);line-height:var(--header-row-height);top:0;touch-action:none}.fkdzs1h700-canary38{grid-template-rows:var(--filter-row-height);height:var(--filter-row-height);line-height:var(--filter-row-height);top:var(--header-row-height)}\";\nstyleInject(css_248z$9);\nconst headerRowAndFilterRow = \"h1fquj5h700-canary38\";\nconst headerRow = \"h19m9p7h700-canary38\";\nconst headerRowClassname = `rdg-header-row ${headerRowAndFilterRow} ${headerRow}`;\nconst filterRow = \"fkdzs1h700-canary38\";\nconst filterRowClassname = `rdg-filter-row ${headerRowAndFilterRow} ${filterRow}`;\nvar css_248z$8 = \".r1otpg64700-canary38{contain:strict;contain:size layout style paint;display:grid;grid-template-rows:var(--row-height);grid-template-columns:var(--template-columns);position:absolute;left:0;width:var(--row-width);height:var(--row-height);line-height:var(--row-height);background-color:var(--background-color)}.r1otpg64700-canary38:hover{background-color:var(--row-hover-background-color)}.rel5gk2700-canary38{background-color:var(--row-selected-background-color)}.rel5gk2700-canary38:hover{background-color:var(--row-selected-hover-background-color)}.s1qymf1z700-canary38{position:-webkit-sticky;position:sticky;z-index:3;grid-template-rows:var(--summary-row-height);height:var(--summary-row-height);line-height:var(--summary-row-height)}.s1qymf1z700-canary38>.c1wupbe700-canary38{border-top:2px solid var(--summary-border-color)}\";\nstyleInject(css_248z$8);\nconst row = \"r1otpg64700-canary38\";\nconst rowClassname = `rdg-row ${row}`;\nconst rowSelected = \"rel5gk2700-canary38\";\nconst rowSelectedClassname = `rdg-row-selected ${rowSelected}`;\nconst summaryRow = \"s1qymf1z700-canary38\";\nconst summaryRowClassname = `rdg-summary-row ${summaryRow}`;\n\nfunction useClickOutside(onClick) {\n  const frameRequestRef = useRef();\n\n  function cancelAnimationFrameRequest() {\n    if (typeof frameRequestRef.current === 'number') {\n      cancelAnimationFrame(frameRequestRef.current);\n      frameRequestRef.current = undefined;\n    }\n  }\n\n  const onClickRef = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n  useEffect(() => {\n    onClickRef.current = onClick;\n  });\n  useEffect(() => {\n    function onOutsideClick() {\n      frameRequestRef.current = undefined;\n      onClickRef.current();\n    }\n\n    function onWindowCaptureClick() {\n      cancelAnimationFrameRequest();\n      frameRequestRef.current = requestAnimationFrame(onOutsideClick);\n    }\n\n    window.addEventListener('click', onWindowCaptureClick, {\n      capture: true\n    });\n    return () => {\n      window.removeEventListener('click', onWindowCaptureClick, {\n        capture: true\n      });\n      cancelAnimationFrameRequest();\n    };\n  }, []);\n  return cancelAnimationFrameRequest;\n}\n\nfunction useGridDimensions() {\n  const gridRef = useRef(null);\n  const [gridWidth, setGridWidth] = useState(1);\n  const [gridHeight, setGridHeight] = useState(1);\n  useLayoutEffect(() => {\n    const {\n      ResizeObserver\n    } = window;\n    if (ResizeObserver == null) return;\n    const resizeObserver = new ResizeObserver(() => {\n      const {\n        clientWidth,\n        clientHeight\n      } = gridRef.current;\n      setGridWidth(clientWidth);\n      setGridHeight(clientHeight);\n    });\n    resizeObserver.observe(gridRef.current);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n  return [gridRef, gridWidth, gridHeight];\n}\n\nfunction useFocusRef(isCellSelected) {\n  const ref = useRef(null);\n  useLayoutEffect(() => {\n    var _ref$current;\n\n    if (!isCellSelected) return;\n    (_ref$current = ref.current) == null ? void 0 : _ref$current.focus({\n      preventScroll: true\n    });\n  }, [isCellSelected]);\n  return ref;\n}\n\nvar css_248z$7 = \".c1w6d5eo700-canary38{cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;position:absolute;top:0;right:0;bottom:0;left:0;margin-right:1px}.c1h7iz8d700-canary38{all:unset;width:0;margin:0}.cc79ydj700-canary38{content:\\\"\\\";width:20px;height:20px;border:2px solid var(--border-color);background-color:var(--background-color)}.c1h7iz8d700-canary38:checked+.cc79ydj700-canary38{background-color:var(--checkbox-color);box-shadow:inset 0 0 0 4px var(--background-color)}.c1h7iz8d700-canary38:focus+.cc79ydj700-canary38{border-color:var(--checkbox-focus-color)}.c1e5jt0b700-canary38{cursor:default}.c1e5jt0b700-canary38 .cc79ydj700-canary38{border-color:var(--checkbox-disabled-border-color);background-color:var(--checkbox-disabled-background-color)}\";\nstyleInject(css_248z$7);\nconst checkboxLabel = \"c1w6d5eo700-canary38\";\nconst checkboxLabelClassname = `rdg-checkbox-label ${checkboxLabel}`;\nconst checkboxInput = \"c1h7iz8d700-canary38\";\nconst checkboxInputClassname = `rdg-checkbox-input ${checkboxInput}`;\nconst checkbox = \"cc79ydj700-canary38\";\nconst checkboxClassname = `rdg-checkbox ${checkbox}`;\nconst checkboxLabelDisabled = \"c1e5jt0b700-canary38\";\nconst checkboxLabelDisabledClassname = `rdg-checkbox-label-disabled ${checkboxLabelDisabled}`;\n\nfunction SelectCellFormatter({\n  value,\n  tabIndex,\n  isCellSelected,\n  disabled,\n  onClick,\n  onChange,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy\n}) {\n  const inputRef = useFocusRef(isCellSelected);\n\n  function handleChange(e) {\n    onChange(e.target.checked, e.nativeEvent.shiftKey);\n  }\n\n  return /*#__PURE__*/jsxs(\"label\", {\n    className: clsx(checkboxLabelClassname, disabled && checkboxLabelDisabledClassname),\n    children: [/*#__PURE__*/jsx(\"input\", {\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      tabIndex: tabIndex,\n      ref: inputRef,\n      type: \"checkbox\",\n      className: checkboxInputClassname,\n      disabled: disabled,\n      checked: value,\n      onChange: handleChange,\n      onClick: onClick\n    }), /*#__PURE__*/jsx(\"div\", {\n      className: checkboxClassname\n    })]\n  });\n}\n\nfunction ValueFormatter(props) {\n  try {\n    return /*#__PURE__*/jsx(Fragment, {\n      children: props.row[props.column.key]\n    });\n  } catch {\n    return null;\n  }\n}\n\nvar css_248z$6 = \".gch972y700-canary38{outline:none}.cz2qf0d700-canary38{margin-left:4px;stroke:currentColor;stroke-width:1.5px;fill:transparent;vertical-align:middle}.cz2qf0d700-canary38>path{-webkit-transition:d .1s;transition:d .1s}\";\nstyleInject(css_248z$6);\nconst groupCellContent = \"gch972y700-canary38\";\nconst groupCellContentClassname = `rdg-group-cell-content ${groupCellContent}`;\nconst caret = \"cz2qf0d700-canary38\";\nconst caretClassname = `rdg-caret ${caret}`;\n\nfunction ToggleGroupFormatter({\n  groupKey,\n  isExpanded,\n  isCellSelected,\n  toggleGroup\n}) {\n  const cellRef = useFocusRef(isCellSelected);\n\n  function handleKeyDown({\n    key\n  }) {\n    if (key === 'Enter') {\n      toggleGroup();\n    }\n  }\n\n  const d = isExpanded ? 'M1 1 L 7 7 L 13 1' : 'M1 7 L 7 1 L 13 7';\n  return /*#__PURE__*/jsxs(\"span\", {\n    ref: cellRef,\n    className: groupCellContentClassname,\n    tabIndex: -1,\n    onKeyDown: handleKeyDown,\n    children: [groupKey, /*#__PURE__*/jsx(\"svg\", {\n      viewBox: \"0 0 14 8\",\n      width: \"14\",\n      height: \"8\",\n      className: caretClassname,\n      children: /*#__PURE__*/jsx(\"path\", {\n        d: d\n      })\n    })]\n  });\n}\n\nfunction stopPropagation(event) {\n  event.stopPropagation();\n}\n\nconst SELECT_COLUMN_KEY = 'select-row';\nconst SelectColumn = {\n  key: SELECT_COLUMN_KEY,\n  name: '',\n  width: 35,\n  maxWidth: 35,\n  resizable: false,\n  sortable: false,\n  frozen: true,\n\n  headerRenderer(props) {\n    return /*#__PURE__*/jsx(SelectCellFormatter, {\n      \"aria-label\": \"Select All\",\n      value: props.allRowsSelected,\n      onChange: props.onAllRowsSelectionChange\n    });\n  },\n\n  formatter(props) {\n    return /*#__PURE__*/jsx(SelectCellFormatter, {\n      \"aria-label\": \"Select\",\n      tabIndex: -1,\n      isCellSelected: props.isCellSelected,\n      value: props.isRowSelected,\n      onClick: stopPropagation,\n      onChange: props.onRowSelectionChange\n    });\n  },\n\n  groupFormatter(props) {\n    return /*#__PURE__*/jsx(SelectCellFormatter, {\n      \"aria-label\": \"Select Group\",\n      tabIndex: -1,\n      isCellSelected: props.isCellSelected,\n      value: props.isRowSelected,\n      onChange: props.onRowSelectionChange,\n      onClick: stopPropagation\n    });\n  }\n\n};\n\nfunction useViewportColumns({\n  rawColumns,\n  columnWidths,\n  viewportWidth,\n  scrollLeft,\n  defaultColumnOptions,\n  rawGroupBy\n}) {\n  var _defaultColumnOptions, _defaultColumnOptions2, _defaultColumnOptions3, _defaultColumnOptions4;\n\n  const minColumnWidth = (_defaultColumnOptions = defaultColumnOptions == null ? void 0 : defaultColumnOptions.minWidth) != null ? _defaultColumnOptions : 80;\n  const defaultFormatter = (_defaultColumnOptions2 = defaultColumnOptions == null ? void 0 : defaultColumnOptions.formatter) != null ? _defaultColumnOptions2 : ValueFormatter;\n  const defaultSortable = (_defaultColumnOptions3 = defaultColumnOptions == null ? void 0 : defaultColumnOptions.sortable) != null ? _defaultColumnOptions3 : false;\n  const defaultResizable = (_defaultColumnOptions4 = defaultColumnOptions == null ? void 0 : defaultColumnOptions.resizable) != null ? _defaultColumnOptions4 : false;\n  const {\n    columns,\n    lastFrozenColumnIndex,\n    groupBy\n  } = useMemo(() => {\n    const groupBy = [];\n    let lastFrozenColumnIndex = -1;\n    const columns = rawColumns.map(rawColumn => {\n      var _rawGroupBy$includes, _rawColumn$sortable, _rawColumn$resizable, _rawColumn$formatter;\n\n      const rowGroup = (_rawGroupBy$includes = rawGroupBy == null ? void 0 : rawGroupBy.includes(rawColumn.key)) != null ? _rawGroupBy$includes : false;\n      const frozen = rowGroup || rawColumn.frozen || false;\n      const column = { ...rawColumn,\n        idx: 0,\n        frozen,\n        isLastFrozenColumn: false,\n        rowGroup,\n        sortable: (_rawColumn$sortable = rawColumn.sortable) != null ? _rawColumn$sortable : defaultSortable,\n        resizable: (_rawColumn$resizable = rawColumn.resizable) != null ? _rawColumn$resizable : defaultResizable,\n        formatter: (_rawColumn$formatter = rawColumn.formatter) != null ? _rawColumn$formatter : defaultFormatter\n      };\n\n      if (rowGroup) {\n        var _column$groupFormatte;\n\n        (_column$groupFormatte = column.groupFormatter) != null ? _column$groupFormatte : column.groupFormatter = ToggleGroupFormatter;\n      }\n\n      if (frozen) {\n        lastFrozenColumnIndex++;\n      }\n\n      return column;\n    });\n    columns.sort(({\n      key: aKey,\n      frozen: frozenA\n    }, {\n      key: bKey,\n      frozen: frozenB\n    }) => {\n      if (aKey === SELECT_COLUMN_KEY) return -1;\n      if (bKey === SELECT_COLUMN_KEY) return 1;\n\n      if (rawGroupBy != null && rawGroupBy.includes(aKey)) {\n        if (rawGroupBy.includes(bKey)) {\n          return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n        }\n\n        return -1;\n      }\n\n      if (rawGroupBy != null && rawGroupBy.includes(bKey)) return 1;\n\n      if (frozenA) {\n        if (frozenB) return 0;\n        return -1;\n      }\n\n      if (frozenB) return 1;\n      return 0;\n    });\n    columns.forEach((column, idx) => {\n      column.idx = idx;\n\n      if (column.rowGroup) {\n        groupBy.push(column.key);\n      }\n    });\n\n    if (lastFrozenColumnIndex !== -1) {\n      columns[lastFrozenColumnIndex].isLastFrozenColumn = true;\n    }\n\n    return {\n      columns,\n      lastFrozenColumnIndex,\n      groupBy\n    };\n  }, [rawColumns, defaultFormatter, defaultResizable, defaultSortable, rawGroupBy]);\n  const {\n    layoutCssVars,\n    totalColumnWidth,\n    totalFrozenColumnWidth,\n    columnMetrics\n  } = useMemo(() => {\n    const columnMetrics = new Map();\n    let left = 0;\n    let totalColumnWidth = 0;\n    let totalFrozenColumnWidth = 0;\n    let templateColumns = '';\n    let allocatedWidth = 0;\n    let unassignedColumnsCount = 0;\n\n    for (const column of columns) {\n      let width = getSpecifiedWidth(column, columnWidths, viewportWidth);\n\n      if (width === undefined) {\n        unassignedColumnsCount++;\n      } else {\n        width = clampColumnWidth(width, column, minColumnWidth);\n        allocatedWidth += width;\n        columnMetrics.set(column, {\n          width,\n          left: 0\n        });\n      }\n    }\n\n    const unallocatedWidth = viewportWidth - allocatedWidth;\n    const unallocatedColumnWidth = unallocatedWidth / unassignedColumnsCount;\n\n    for (const column of columns) {\n      let width;\n\n      if (columnMetrics.has(column)) {\n        const columnMetric = columnMetrics.get(column);\n        columnMetric.left = left;\n        ({\n          width\n        } = columnMetric);\n      } else {\n        width = clampColumnWidth(unallocatedColumnWidth, column, minColumnWidth);\n        columnMetrics.set(column, {\n          width,\n          left\n        });\n      }\n\n      totalColumnWidth += width;\n      left += width;\n      templateColumns += `${width}px `;\n    }\n\n    if (lastFrozenColumnIndex !== -1) {\n      const columnMetric = columnMetrics.get(columns[lastFrozenColumnIndex]);\n      totalFrozenColumnWidth = columnMetric.left + columnMetric.width;\n    }\n\n    const layoutCssVars = {\n      '--template-columns': templateColumns\n    };\n\n    for (let i = 0; i <= lastFrozenColumnIndex; i++) {\n      const column = columns[i];\n      layoutCssVars[`--frozen-left-${column.key}`] = `${columnMetrics.get(column).left}px`;\n    }\n\n    return {\n      layoutCssVars,\n      totalColumnWidth,\n      totalFrozenColumnWidth,\n      columnMetrics\n    };\n  }, [columnWidths, columns, viewportWidth, minColumnWidth, lastFrozenColumnIndex]);\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo(() => {\n    const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    const viewportRight = scrollLeft + viewportWidth;\n    const lastColIdx = columns.length - 1;\n    const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    }\n\n    let colVisibleStartIdx = firstUnfrozenColumnIdx;\n\n    while (colVisibleStartIdx < lastColIdx) {\n      const {\n        left,\n        width\n      } = columnMetrics.get(columns[colVisibleStartIdx]);\n\n      if (left + width > viewportLeft) {\n        break;\n      }\n\n      colVisibleStartIdx++;\n    }\n\n    let colVisibleEndIdx = colVisibleStartIdx;\n\n    while (colVisibleEndIdx < lastColIdx) {\n      const {\n        left,\n        width\n      } = columnMetrics.get(columns[colVisibleEndIdx]);\n\n      if (left + width >= viewportRight) {\n        break;\n      }\n\n      colVisibleEndIdx++;\n    }\n\n    const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [columns, columnMetrics, lastFrozenColumnIndex, scrollLeft, totalFrozenColumnWidth, viewportWidth]);\n  const viewportColumns = useMemo(() => {\n    const viewportColumns = [];\n\n    for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      const column = columns[colIdx];\n      if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n  return {\n    columns,\n    viewportColumns,\n    layoutCssVars,\n    columnMetrics,\n    totalColumnWidth,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    groupBy\n  };\n}\n\nfunction getSpecifiedWidth({\n  key,\n  width\n}, columnWidths, viewportWidth) {\n  if (columnWidths.has(key)) {\n    return columnWidths.get(key);\n  }\n\n  if (typeof width === 'number') {\n    return width;\n  }\n\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n\n  return undefined;\n}\n\nfunction clampColumnWidth(width, {\n  minWidth,\n  maxWidth\n}, minColumnWidth) {\n  width = Math.max(width, minWidth != null ? minWidth : minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n}\n\nconst RENDER_BACTCH_SIZE = 8;\n\nfunction isReadonlyArray(arr) {\n  return Array.isArray(arr);\n}\n\nfunction useViewportRows({\n  rawRows,\n  rowHeight,\n  clientHeight,\n  scrollTop,\n  groupBy,\n  rowGrouper,\n  expandedGroupIds\n}) {\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0 || !rowGrouper) return [undefined, rawRows.length];\n\n    const groupRows = (rows, [groupByKey, ...remainingGroupByKeys], startRowIndex) => {\n      let groupRowsCount = 0;\n      const groups = {};\n\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0 ? [childRows, childRows.length] : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1);\n        groups[key] = {\n          childRows,\n          childGroups,\n          startRowIndex: startRowIndex + groupRowsCount\n        };\n        groupRowsCount += childRowsCount + 1;\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n  const [rows, allGroupRows] = useMemo(() => {\n    const allGroupRows = new Set();\n    if (!groupedRows) return [rawRows, allGroupRows];\n    const flattenedRows = [];\n\n    const expandGroup = (rows, parentId, level) => {\n      if (isReadonlyArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        var _expandedGroupIds$has;\n\n        const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n        const isExpanded = (_expandedGroupIds$has = expandedGroupIds == null ? void 0 : expandedGroupIds.has(id)) != null ? _expandedGroupIds$has : false;\n        const {\n          childRows,\n          childGroups,\n          startRowIndex\n        } = rows[groupKey];\n        const groupRow = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, allGroupRows];\n  }, [expandedGroupIds, groupedRows, rawRows]);\n\n  const isGroupRow = row => allGroupRows.has(row);\n\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rows.length - 1, Math.floor((scrollTop + clientHeight) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rows.length - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  return {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    isGroupRow\n  };\n}\n\nfunction useLatestFunc(fn) {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  });\n  return useCallback((...args) => {\n    ref.current(...args);\n  }, []);\n}\n\nvar css_248z$5 = \".h13yq3r8700-canary38{cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.ht6rdyl700-canary38{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;overflow:hidden;overflow:clip;text-overflow:ellipsis}\";\nstyleInject(css_248z$5);\nconst headerSortCell = \"h13yq3r8700-canary38\";\nconst headerSortCellClassname = `rdg-header-sort-cell ${headerSortCell}`;\nconst headerSortName = \"ht6rdyl700-canary38\";\nconst headerSortNameClassname = `rdg-header-sort-name ${headerSortName}`;\n\nfunction SortableHeaderCell({\n  column,\n  onSort,\n  sortColumn,\n  sortDirection,\n  children\n}) {\n  sortDirection = sortColumn === column.key && sortDirection || 'NONE';\n  let sortText = '';\n\n  if (sortDirection === 'ASC') {\n    sortText = '\\u25B2';\n  } else if (sortDirection === 'DESC') {\n    sortText = '\\u25BC';\n  }\n\n  function onClick() {\n    if (!onSort) return;\n    const {\n      sortDescendingFirst\n    } = column;\n    let direction;\n\n    switch (sortDirection) {\n      case 'ASC':\n        direction = sortDescendingFirst ? 'NONE' : 'DESC';\n        break;\n\n      case 'DESC':\n        direction = sortDescendingFirst ? 'ASC' : 'NONE';\n        break;\n\n      default:\n        direction = sortDescendingFirst ? 'DESC' : 'ASC';\n        break;\n    }\n\n    onSort(column.key, direction);\n  }\n\n  return /*#__PURE__*/jsxs(\"span\", {\n    className: headerSortCellClassname,\n    onClick: onClick,\n    children: [/*#__PURE__*/jsx(\"span\", {\n      className: headerSortNameClassname,\n      children: children\n    }), /*#__PURE__*/jsx(\"span\", {\n      children: sortText\n    })]\n  });\n}\n\nconst nonInputKeys = new Set(['Unidentified', 'Alt', 'AltGraph', 'CapsLock', 'Control', 'Fn', 'FnLock', 'Meta', 'NumLock', 'ScrollLock', 'Shift', 'Tab', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Home', 'PageDown', 'PageUp', 'Insert', 'ContextMenu', 'Escape', 'Pause', 'Play', 'PrintScreen', 'F1', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12']);\n\nfunction isCtrlKeyHeldDown(e) {\n  return (e.ctrlKey || e.metaKey) && e.key !== 'Control';\n}\n\nfunction isDefaultCellInput(event) {\n  return !nonInputKeys.has(event.key);\n}\n\nfunction onEditorNavigation({\n  key,\n  target\n}) {\n  if (key === 'Tab' && (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement)) {\n    return target.matches('.rdg-editor-container > :only-child, .rdg-editor-container > label:only-child > :only-child');\n  }\n\n  return false;\n}\n\nfunction isSelectedCellEditable({\n  selectedPosition,\n  columns,\n  rows,\n  isGroupRow\n}) {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  return column.editor != null && !column.rowGroup && !isGroupRow(row) && (typeof column.editable === 'function' ? column.editable(row) : column.editable) !== false;\n}\n\nfunction getNextSelectedCellPosition({\n  cellNavigationMode,\n  columns,\n  rowsCount,\n  nextPosition\n}) {\n  if (cellNavigationMode !== 'NONE') {\n    const {\n      idx,\n      rowIdx\n    } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isLastRow = rowIdx === rowsCount - 1;\n\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else {\n        return {\n          rowIdx,\n          idx: 0\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isFirstRow = rowIdx === 0;\n\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else {\n        return {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n  }\n\n  return nextPosition;\n}\n\nfunction canExitGrid({\n  cellNavigationMode,\n  columns,\n  rowsCount,\n  selectedPosition: {\n    rowIdx,\n    idx\n  },\n  shiftKey\n}) {\n  if (cellNavigationMode === 'NONE' || cellNavigationMode === 'CHANGE_ROW') {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n\nfunction assertIsValidKeyGetter(keyGetter) {\n  if (typeof keyGetter !== 'function') {\n    throw new Error('Please specify the rowKeyGetter prop to use selection');\n  }\n}\n\nfunction getCellStyle(column) {\n  return column.frozen ? {\n    left: `var(--frozen-left-${column.key})`\n  } : {\n    gridColumnStart: column.idx + 1\n  };\n}\n\nfunction getCellClassname(column, ...extraClasses) {\n  return clsx(cellClassname, ...extraClasses, column.frozen && cellFrozenClassname, column.isLastFrozenColumn && cellFrozenLastClassname);\n}\n\nvar css_248z$4 = \".celq7o9700-canary38:after{content:\\\"\\\";cursor:col-resize;position:absolute;top:0;right:0;bottom:0;width:10px}\";\nstyleInject(css_248z$4);\nconst cellResizable = \"celq7o9700-canary38\";\nconst cellResizableClassname = `rdg-cell-resizable ${cellResizable}`;\n\nfunction getAriaSort(sortDirection) {\n  switch (sortDirection) {\n    case 'ASC':\n      return 'ascending';\n\n    case 'DESC':\n      return 'descending';\n\n    default:\n      return 'none';\n  }\n}\n\nfunction HeaderCell({\n  column,\n  onResize,\n  allRowsSelected,\n  onAllRowsSelectionChange,\n  sortColumn,\n  sortDirection,\n  onSort\n}) {\n  function onPointerDown(event) {\n    if (event.pointerType === 'mouse' && event.buttons !== 1) {\n      return;\n    }\n\n    const {\n      currentTarget,\n      pointerId\n    } = event;\n    const {\n      right\n    } = currentTarget.getBoundingClientRect();\n    const offset = right - event.clientX;\n\n    if (offset > 11) {\n      return;\n    }\n\n    function onPointerMove(event) {\n      if (event.pointerId !== pointerId) return;\n\n      if (event.pointerType === 'mouse' && event.buttons !== 1) {\n        onPointerUp();\n        return;\n      }\n\n      const width = event.clientX + offset - currentTarget.getBoundingClientRect().left;\n\n      if (width > 0) {\n        onResize(column, width);\n      }\n    }\n\n    function onPointerUp() {\n      if (event.pointerId !== pointerId) return;\n      window.removeEventListener('pointermove', onPointerMove);\n      window.removeEventListener('pointerup', onPointerUp);\n    }\n\n    event.preventDefault();\n    window.addEventListener('pointermove', onPointerMove);\n    window.addEventListener('pointerup', onPointerUp);\n  }\n\n  function getCell() {\n    if (column.headerRenderer) {\n      return /*#__PURE__*/jsx(column.headerRenderer, {\n        column: column,\n        sortColumn: sortColumn,\n        sortDirection: sortDirection,\n        onSort: onSort,\n        allRowsSelected: allRowsSelected,\n        onAllRowsSelectionChange: onAllRowsSelectionChange\n      });\n    }\n\n    if (column.sortable) {\n      return /*#__PURE__*/jsx(SortableHeaderCell, {\n        column: column,\n        onSort: onSort,\n        sortColumn: sortColumn,\n        sortDirection: sortDirection,\n        children: column.name\n      });\n    }\n\n    return column.name;\n  }\n\n  const className = getCellClassname(column, column.headerCellClass, column.resizable && cellResizableClassname);\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"columnheader\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-sort\": sortColumn === column.key ? getAriaSort(sortDirection) : undefined,\n    className: className,\n    style: getCellStyle(column),\n    onPointerDown: column.resizable ? onPointerDown : undefined,\n    children: getCell()\n  });\n}\n\nfunction HeaderRow({\n  columns,\n  rows,\n  rowKeyGetter,\n  onSelectedRowsChange,\n  allRowsSelected,\n  onColumnResize,\n  sortColumn,\n  sortDirection,\n  onSort\n}) {\n  const handleAllRowsSelectionChange = useCallback(checked => {\n    if (!onSelectedRowsChange) return;\n    assertIsValidKeyGetter(rowKeyGetter);\n    const newSelectedRows = new Set(checked ? rows.map(rowKeyGetter) : undefined);\n    onSelectedRowsChange(newSelectedRows);\n  }, [onSelectedRowsChange, rows, rowKeyGetter]);\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": 1,\n    className: headerRowClassname,\n    children: columns.map(column => {\n      return /*#__PURE__*/jsx(HeaderCell, {\n        column: column,\n        onResize: onColumnResize,\n        allRowsSelected: allRowsSelected,\n        onAllRowsSelectionChange: handleAllRowsSelectionChange,\n        onSort: onSort,\n        sortColumn: sortColumn,\n        sortDirection: sortDirection\n      }, column.key);\n    })\n  });\n}\n\nconst HeaderRow$1 = /*#__PURE__*/memo(HeaderRow);\n\nfunction FilterRow({\n  columns,\n  filters,\n  onFiltersChange\n}) {\n  function onChange(key, value) {\n    const newFilters = { ...filters\n    };\n    newFilters[key] = value;\n    onFiltersChange == null ? void 0 : onFiltersChange(newFilters);\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": 2,\n    className: filterRowClassname,\n    children: columns.map(column => {\n      const {\n        key\n      } = column;\n      return /*#__PURE__*/jsx(\"div\", {\n        className: getCellClassname(column),\n        style: getCellStyle(column),\n        children: column.filterRenderer && /*#__PURE__*/jsx(column.filterRenderer, {\n          column: column,\n          value: filters == null ? void 0 : filters[column.key],\n          onChange: value => onChange(key, value)\n        })\n      }, key);\n    })\n  });\n}\n\nconst FilterRow$1 = /*#__PURE__*/memo(FilterRow);\nvar css_248z$3 = \".c1bmg16t700-canary38,.ccpfvsn700-canary38{background-color:#ccf}.c1bmg16t700-canary38.ccpfvsn700-canary38{background-color:#99f}.c12t67zz700-canary38{cursor:move;position:absolute;right:0;bottom:0;width:8px;height:8px;background-color:var(--selection-color)}.c12t67zz700-canary38:hover{width:16px;height:16px;border:2px solid var(--selection-color);background-color:var(--background-color)}\";\nstyleInject(css_248z$3);\nconst cellCopied = \"ccpfvsn700-canary38\";\nconst cellCopiedClassname = `rdg-cell-copied ${cellCopied}`;\nconst cellDraggedOver = \"c1bmg16t700-canary38\";\nconst cellDraggedOverClassname = `rdg-cell-dragged-over ${cellDraggedOver}`;\nconst cellDragHandle = \"c12t67zz700-canary38\";\nconst cellDragHandleClassname = `rdg-cell-drag-handle ${cellDragHandle}`;\n\nfunction Cell({\n  className,\n  column,\n  isCellSelected,\n  isCopied,\n  isDraggedOver,\n  isRowSelected,\n  row,\n  rowIdx,\n  dragHandleProps,\n  onRowClick,\n  onClick,\n  onDoubleClick,\n  onContextMenu,\n  onRowChange,\n  selectCell,\n  selectRow,\n  ...props\n}, ref) {\n  const {\n    cellClass\n  } = column;\n  className = getCellClassname(column, typeof cellClass === 'function' ? cellClass(row) : cellClass, className, isCellSelected && cellSelectedClassname, isCopied && cellCopiedClassname, isDraggedOver && cellDraggedOverClassname);\n\n  function selectCellWrapper(openEditor) {\n    selectCell({\n      idx: column.idx,\n      rowIdx\n    }, openEditor);\n  }\n\n  function handleClick(event) {\n    var _column$editorOptions;\n\n    selectCellWrapper((_column$editorOptions = column.editorOptions) == null ? void 0 : _column$editorOptions.editOnClick);\n    onRowClick == null ? void 0 : onRowClick(rowIdx, row, column);\n    onClick == null ? void 0 : onClick(event);\n  }\n\n  function handleContextMenu(event) {\n    selectCellWrapper();\n    onContextMenu == null ? void 0 : onContextMenu(event);\n  }\n\n  function handleDoubleClick(event) {\n    selectCellWrapper(true);\n    onDoubleClick == null ? void 0 : onDoubleClick(event);\n  }\n\n  function handleRowChange(newRow) {\n    onRowChange(rowIdx, newRow);\n  }\n\n  function onRowSelectionChange(checked, isShiftClick) {\n    selectRow({\n      rowIdx,\n      checked,\n      isShiftClick\n    });\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-selected\": isCellSelected,\n    ref: ref,\n    className: className,\n    style: getCellStyle(column),\n    onClick: handleClick,\n    onDoubleClick: handleDoubleClick,\n    onContextMenu: handleContextMenu,\n    ...props,\n    children: !column.rowGroup && /*#__PURE__*/jsxs(Fragment, {\n      children: [/*#__PURE__*/jsx(column.formatter, {\n        column: column,\n        rowIdx: rowIdx,\n        row: row,\n        isCellSelected: isCellSelected,\n        isRowSelected: isRowSelected,\n        onRowSelectionChange: onRowSelectionChange,\n        onRowChange: handleRowChange\n      }), dragHandleProps && /*#__PURE__*/jsx(\"div\", {\n        className: cellDragHandleClassname,\n        ...dragHandleProps\n      })]\n    })\n  });\n}\n\nconst Cell$1 = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(Cell));\nvar css_248z$2 = \".e1d24x2700-canary38{display:contents}\";\nstyleInject(css_248z$2);\nconst editorContainer = \"e1d24x2700-canary38\";\nconst editorContainerClassname = `rdg-editor-container ${editorContainer}`;\n\nfunction EditorContainer({\n  row,\n  column,\n  onRowChange,\n  ...props\n}) {\n  var _column$editorOptions;\n\n  const onClickCapture = useClickOutside(() => onRowChange(row, true));\n  if (column.editor === undefined) return null;\n  const editor = /*#__PURE__*/jsx(\"div\", {\n    className: editorContainerClassname,\n    onClickCapture: onClickCapture,\n    children: /*#__PURE__*/jsx(column.editor, {\n      row: row,\n      column: column,\n      onRowChange: onRowChange,\n      ...props\n    })\n  });\n\n  if ((_column$editorOptions = column.editorOptions) != null && _column$editorOptions.createPortal) {\n    return /*#__PURE__*/createPortal(editor, props.editorPortalTarget);\n  }\n\n  return editor;\n}\n\nvar css_248z$1 = \".c1tngyp1700-canary38{padding:0}\";\nstyleInject(css_248z$1);\nconst cellEditing = \"c1tngyp1700-canary38\";\nconst cellEditingClassname = `rdg-cell-editing ${cellEditing}`;\n\nfunction EditCell({\n  className,\n  column,\n  row,\n  rowIdx,\n  editorProps,\n  ...props\n}) {\n  const [dimensions, setDimensions] = useState(null);\n  const cellRef = useCallback(node => {\n    if (node !== null) {\n      const {\n        left,\n        top\n      } = node.getBoundingClientRect();\n      setDimensions({\n        left,\n        top\n      });\n    }\n  }, []);\n  const {\n    cellClass\n  } = column;\n  className = getCellClassname(column, cellSelectedClassname, cellEditingClassname, typeof cellClass === 'function' ? cellClass(row) : cellClass, className);\n\n  function getCellContent() {\n    var _document$scrollingEl;\n\n    if (dimensions === null) return;\n    const {\n      scrollTop: docTop,\n      scrollLeft: docLeft\n    } = (_document$scrollingEl = document.scrollingElement) != null ? _document$scrollingEl : document.documentElement;\n    const {\n      left,\n      top\n    } = dimensions;\n    const gridLeft = left + docLeft;\n    const gridTop = top + docTop;\n    return /*#__PURE__*/jsx(EditorContainer, { ...editorProps,\n      rowIdx: rowIdx,\n      column: column,\n      left: gridLeft,\n      top: gridTop\n    });\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-selected\": true,\n    ref: cellRef,\n    className: className,\n    style: getCellStyle(column),\n    ...props,\n    children: getCellContent()\n  });\n}\n\nfunction Row({\n  cellRenderer: CellRenderer = Cell$1,\n  className,\n  rowIdx,\n  isRowSelected,\n  copiedCellIdx,\n  draggedOverCellIdx,\n  row,\n  viewportColumns,\n  selectedCellProps,\n  onRowClick,\n  rowClass,\n  setDraggedOverRowIdx,\n  onMouseEnter,\n  top,\n  onRowChange,\n  selectCell,\n  selectRow,\n  'aria-rowindex': ariaRowIndex,\n  'aria-selected': ariaSelected,\n  ...props\n}, ref) {\n  function handleDragEnter(event) {\n    setDraggedOverRowIdx == null ? void 0 : setDraggedOverRowIdx(rowIdx);\n    onMouseEnter == null ? void 0 : onMouseEnter(event);\n  }\n\n  className = clsx(rowClassname, `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, rowClass == null ? void 0 : rowClass(row), className, isRowSelected && rowSelectedClassname, (selectedCellProps == null ? void 0 : selectedCellProps.idx) === -1 && groupRowSelectedClassname);\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": ariaRowIndex,\n    \"aria-selected\": ariaSelected,\n    ref: ref,\n    className: className,\n    onMouseEnter: handleDragEnter,\n    style: {\n      top\n    },\n    ...props,\n    children: viewportColumns.map(column => {\n      const isCellSelected = (selectedCellProps == null ? void 0 : selectedCellProps.idx) === column.idx;\n\n      if ((selectedCellProps == null ? void 0 : selectedCellProps.mode) === 'EDIT' && isCellSelected) {\n        return /*#__PURE__*/jsx(EditCell, {\n          rowIdx: rowIdx,\n          column: column,\n          row: row,\n          onKeyDown: selectedCellProps.onKeyDown,\n          editorProps: selectedCellProps.editorProps\n        }, column.key);\n      }\n\n      return /*#__PURE__*/jsx(CellRenderer, {\n        rowIdx: rowIdx,\n        column: column,\n        row: row,\n        isCopied: copiedCellIdx === column.idx,\n        isDraggedOver: draggedOverCellIdx === column.idx,\n        isCellSelected: isCellSelected,\n        isRowSelected: isRowSelected,\n        dragHandleProps: isCellSelected ? selectedCellProps.dragHandleProps : undefined,\n        onFocus: isCellSelected ? selectedCellProps.onFocus : undefined,\n        onKeyDown: isCellSelected ? selectedCellProps.onKeyDown : undefined,\n        onRowClick: onRowClick,\n        onRowChange: onRowChange,\n        selectCell: selectCell,\n        selectRow: selectRow\n      }, column.key);\n    })\n  });\n}\n\nconst Row$1 = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(Row));\n\nfunction GroupCell({\n  id,\n  rowIdx,\n  groupKey,\n  childRows,\n  isExpanded,\n  isCellSelected,\n  isRowSelected,\n  column,\n  groupColumnIndex,\n  selectRow,\n  toggleGroup: toggleGroupWrapper\n}) {\n  function toggleGroup() {\n    toggleGroupWrapper(id);\n  }\n\n  function onRowSelectionChange(checked) {\n    selectRow({\n      rowIdx,\n      checked,\n      isShiftClick: false\n    });\n  }\n\n  const isLevelMatching = column.rowGroup && groupColumnIndex === column.idx;\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    className: getCellClassname(column, isCellSelected && cellSelectedClassname),\n    style: { ...getCellStyle(column),\n      cursor: isLevelMatching ? 'pointer' : 'default'\n    },\n    onClick: isLevelMatching ? toggleGroup : undefined,\n    children: (!column.rowGroup || groupColumnIndex === column.idx) && column.groupFormatter && /*#__PURE__*/jsx(column.groupFormatter, {\n      groupKey: groupKey,\n      childRows: childRows,\n      column: column,\n      isExpanded: isExpanded,\n      isCellSelected: isCellSelected,\n      isRowSelected: isRowSelected,\n      onRowSelectionChange: onRowSelectionChange,\n      toggleGroup: toggleGroup\n    })\n  }, column.key);\n}\n\nconst GroupCell$1 = /*#__PURE__*/memo(GroupCell);\n\nfunction GroupedRow({\n  id,\n  groupKey,\n  viewportColumns,\n  childRows,\n  rowIdx,\n  top,\n  level,\n  isExpanded,\n  selectedCellIdx,\n  isRowSelected,\n  selectCell,\n  selectRow,\n  toggleGroup,\n  ...props\n}) {\n  const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? level + 1 : level;\n\n  function selectGroup() {\n    selectCell({\n      rowIdx,\n      idx: -1\n    });\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-level\": level,\n    \"aria-expanded\": isExpanded,\n    className: clsx(rowClassname, groupRowClassname, `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, isRowSelected && rowSelectedClassname, selectedCellIdx === -1 && groupRowSelectedClassname),\n    onClick: selectGroup,\n    style: {\n      top\n    },\n    ...props,\n    children: viewportColumns.map(column => /*#__PURE__*/jsx(GroupCell$1, {\n      id: id,\n      rowIdx: rowIdx,\n      groupKey: groupKey,\n      childRows: childRows,\n      isExpanded: isExpanded,\n      isRowSelected: isRowSelected,\n      isCellSelected: selectedCellIdx === column.idx,\n      column: column,\n      groupColumnIndex: idx,\n      selectRow: selectRow,\n      toggleGroup: toggleGroup\n    }, column.key))\n  });\n}\n\nconst GroupRowRenderer = /*#__PURE__*/memo(GroupedRow);\n\nfunction SummaryCell({\n  column,\n  row\n}) {\n  const {\n    summaryFormatter: SummaryFormatter,\n    summaryCellClass\n  } = column;\n  const className = getCellClassname(column, typeof summaryCellClass === 'function' ? summaryCellClass(row) : summaryCellClass);\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    className: className,\n    style: getCellStyle(column),\n    children: SummaryFormatter && /*#__PURE__*/jsx(SummaryFormatter, {\n      column: column,\n      row: row\n    })\n  });\n}\n\nconst SummaryCell$1 = /*#__PURE__*/memo(SummaryCell);\n\nfunction SummaryRow({\n  rowIdx,\n  row,\n  viewportColumns,\n  bottom,\n  'aria-rowindex': ariaRowIndex\n}) {\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": ariaRowIndex,\n    className: `${rowClassname} rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'} ${summaryRowClassname}`,\n    style: {\n      bottom\n    },\n    children: viewportColumns.map(column => /*#__PURE__*/jsx(SummaryCell$1, {\n      column: column,\n      row: row\n    }, column.key))\n  });\n}\n\nconst SummaryRow$1 = /*#__PURE__*/memo(SummaryRow);\n\nvar _globalThis$document;\n\nconst body = (_globalThis$document = globalThis.document) == null ? void 0 : _globalThis$document.body;\n\nfunction DataGrid({\n  columns: rawColumns,\n  rows: rawRows,\n  summaryRows,\n  rowKeyGetter,\n  onRowsChange,\n  rowHeight = 35,\n  headerRowHeight = rowHeight,\n  headerFiltersHeight = 45,\n  summaryRowHeight = rowHeight,\n  selectedRows,\n  onSelectedRowsChange,\n  sortColumn,\n  sortDirection,\n  onSort,\n  filters,\n  onFiltersChange,\n  defaultColumnOptions,\n  groupBy: rawGroupBy,\n  rowGrouper,\n  expandedGroupIds,\n  onExpandedGroupIdsChange,\n  rowRenderer: RowRenderer = Row$1,\n  emptyRowsRenderer: EmptyRowsRenderer,\n  onRowClick,\n  onScroll,\n  onColumnResize,\n  onSelectedCellChange,\n  onFill,\n  onPaste,\n  enableFilterRow = false,\n  cellNavigationMode = 'NONE',\n  editorPortalTarget = body,\n  className,\n  style,\n  rowClass,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  'aria-describedby': ariaDescribedBy\n}, ref) {\n  var _summaryRows$length;\n\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [columnWidths, setColumnWidths] = useState(() => new Map());\n  const [selectedPosition, setSelectedPosition] = useState({\n    idx: -1,\n    rowIdx: -1,\n    mode: 'SELECT'\n  });\n  const [copiedCell, setCopiedCell] = useState(null);\n  const [isDragging, setDragging] = useState(false);\n  const [draggedOverRowIdx, setOverRowIdx] = useState(undefined);\n  const focusSinkRef = useRef(null);\n  const prevSelectedPosition = useRef(selectedPosition);\n  const latestDraggedOverRowIdx = useRef(draggedOverRowIdx);\n  const lastSelectedRowIdx = useRef(-1);\n  const isCellFocusable = useRef(false);\n  const selectRowWrapper = useLatestFunc(selectRow);\n  const selectCellWrapper = useLatestFunc(selectCell);\n  const toggleGroupWrapper = useLatestFunc(toggleGroup);\n  const handleFormatterRowChangeWrapper = useLatestFunc(updateRow);\n  const [gridRef, gridWidth, gridHeight] = useGridDimensions();\n  const headerRowsCount = enableFilterRow ? 2 : 1;\n  const summaryRowsCount = (_summaryRows$length = summaryRows == null ? void 0 : summaryRows.length) != null ? _summaryRows$length : 0;\n  const totalHeaderHeight = headerRowHeight + (enableFilterRow ? headerFiltersHeight : 0);\n  const clientHeight = gridHeight - totalHeaderHeight - summaryRowsCount * summaryRowHeight;\n  const isSelectable = selectedRows !== undefined && onSelectedRowsChange !== undefined;\n  const {\n    columns,\n    viewportColumns,\n    layoutCssVars,\n    columnMetrics,\n    totalColumnWidth,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    groupBy\n  } = useViewportColumns({\n    rawColumns,\n    columnWidths,\n    scrollLeft,\n    viewportWidth: gridWidth,\n    defaultColumnOptions,\n    rawGroupBy: rowGrouper ? rawGroupBy : undefined\n  });\n  const {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    isGroupRow\n  } = useViewportRows({\n    rawRows,\n    groupBy,\n    rowGrouper,\n    rowHeight,\n    clientHeight,\n    scrollTop,\n    expandedGroupIds\n  });\n  const hasGroups = groupBy.length > 0 && typeof rowGrouper === 'function';\n  const minColIdx = hasGroups ? -1 : 0;\n  const enableCellDragAndDrop = hasGroups ? false : onFill !== undefined;\n  useLayoutEffect(() => {\n    if (selectedPosition === prevSelectedPosition.current || selectedPosition.mode === 'EDIT' || !isCellWithinBounds(selectedPosition)) return;\n    prevSelectedPosition.current = selectedPosition;\n    scrollToCell(selectedPosition);\n\n    if (isCellFocusable.current) {\n      isCellFocusable.current = false;\n      return;\n    }\n\n    focusSinkRef.current.focus({\n      preventScroll: true\n    });\n  });\n  useImperativeHandle(ref, () => ({\n    element: gridRef.current,\n\n    scrollToColumn(idx) {\n      scrollToCell({\n        idx\n      });\n    },\n\n    scrollToRow(rowIdx) {\n      const {\n        current\n      } = gridRef;\n      if (!current) return;\n      current.scrollTo({\n        top: rowIdx * rowHeight,\n        behavior: 'smooth'\n      });\n    },\n\n    selectCell\n  }));\n  const handleColumnResize = useCallback((column, width) => {\n    setColumnWidths(columnWidths => {\n      const newColumnWidths = new Map(columnWidths);\n      newColumnWidths.set(column.key, width);\n      return newColumnWidths;\n    });\n    onColumnResize == null ? void 0 : onColumnResize(column.idx, width);\n  }, [onColumnResize]);\n  const setDraggedOverRowIdx = useCallback(rowIdx => {\n    setOverRowIdx(rowIdx);\n    latestDraggedOverRowIdx.current = rowIdx;\n  }, []);\n\n  function selectRow({\n    rowIdx,\n    checked,\n    isShiftClick\n  }) {\n    if (!onSelectedRowsChange) return;\n    assertIsValidKeyGetter(rowKeyGetter);\n    const newSelectedRows = new Set(selectedRows);\n    const row = rows[rowIdx];\n\n    if (isGroupRow(row)) {\n      for (const childRow of row.childRows) {\n        const rowKey = rowKeyGetter(childRow);\n\n        if (checked) {\n          newSelectedRows.add(rowKey);\n        } else {\n          newSelectedRows.delete(rowKey);\n        }\n      }\n\n      onSelectedRowsChange(newSelectedRows);\n      return;\n    }\n\n    const rowKey = rowKeyGetter(row);\n\n    if (checked) {\n      newSelectedRows.add(rowKey);\n      const previousRowIdx = lastSelectedRowIdx.current;\n      lastSelectedRowIdx.current = rowIdx;\n\n      if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n        const step = Math.sign(rowIdx - previousRowIdx);\n\n        for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n          const row = rows[i];\n          if (isGroupRow(row)) continue;\n          newSelectedRows.add(rowKeyGetter(row));\n        }\n      }\n    } else {\n      newSelectedRows.delete(rowKey);\n      lastSelectedRowIdx.current = -1;\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }\n\n  function toggleGroup(expandedGroupId) {\n    if (!onExpandedGroupIdsChange) return;\n    const newExpandedGroupIds = new Set(expandedGroupIds);\n\n    if (newExpandedGroupIds.has(expandedGroupId)) {\n      newExpandedGroupIds.delete(expandedGroupId);\n    } else {\n      newExpandedGroupIds.add(expandedGroupId);\n    }\n\n    onExpandedGroupIdsChange(newExpandedGroupIds);\n  }\n\n  function onGridFocus() {\n    if (!isCellWithinBounds(selectedPosition)) {\n      const initialPosition = {\n        idx: 0,\n        rowIdx: 0,\n        mode: 'SELECT'\n      };\n\n      if (isCellWithinBounds(initialPosition)) {\n        setSelectedPosition(initialPosition);\n      }\n    } else {\n      scrollToCell(selectedPosition);\n    }\n  }\n\n  function handleKeyDown(event) {\n    const {\n      key,\n      keyCode\n    } = event;\n    const row = rows[selectedPosition.rowIdx];\n\n    if (onPaste && isCtrlKeyHeldDown(event) && isCellWithinBounds(selectedPosition) && !isGroupRow(row) && selectedPosition.idx !== -1 && selectedPosition.mode === 'SELECT') {\n      const cKey = 67;\n      const vKey = 86;\n\n      if (keyCode === cKey) {\n        handleCopy();\n        return;\n      }\n\n      if (keyCode === vKey) {\n        handlePaste();\n        return;\n      }\n    }\n\n    if (isCellWithinBounds(selectedPosition) && isGroupRow(row) && selectedPosition.idx === -1 && (key === 'ArrowLeft' && row.isExpanded || key === 'ArrowRight' && !row.isExpanded)) {\n      event.preventDefault();\n      toggleGroup(row.id);\n      return;\n    }\n\n    switch (event.key) {\n      case 'Escape':\n        setCopiedCell(null);\n        closeEditor();\n        return;\n\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'Tab':\n      case 'Home':\n      case 'End':\n      case 'PageUp':\n      case 'PageDown':\n        navigate(event);\n        break;\n\n      default:\n        handleCellInput(event);\n        break;\n    }\n  }\n\n  function handleFocus() {\n    isCellFocusable.current = true;\n  }\n\n  function handleScroll(event) {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll == null ? void 0 : onScroll(event);\n  }\n\n  function getRawRowIdx(rowIdx) {\n    return hasGroups ? rawRows.indexOf(rows[rowIdx]) : rowIdx;\n  }\n\n  function updateRow(rowIdx, row) {\n    if (typeof onRowsChange !== 'function') return;\n    const updatedRows = [...rawRows];\n    updatedRows[rowIdx] = row;\n    onRowsChange(updatedRows, {\n      indexes: [rowIdx],\n      column: columns[selectedPosition.idx]\n    });\n  }\n\n  function commitEditorChanges() {\n    var _columns$selectedPosi;\n\n    if (((_columns$selectedPosi = columns[selectedPosition.idx]) == null ? void 0 : _columns$selectedPosi.editor) === undefined || selectedPosition.mode === 'SELECT' || selectedPosition.row === selectedPosition.originalRow) {\n      return;\n    }\n\n    const rowIdx = getRawRowIdx(selectedPosition.rowIdx);\n    updateRow(rowIdx, selectedPosition.row);\n  }\n\n  function handleCopy() {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    setCopiedCell({\n      row: rawRows[getRawRowIdx(rowIdx)],\n      columnKey: columns[idx].key\n    });\n  }\n\n  function handlePaste() {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const targetRow = rawRows[getRawRowIdx(rowIdx)];\n\n    if (!onPaste || !onRowsChange || copiedCell === null || !isCellEditable(selectedPosition)) {\n      return;\n    }\n\n    const updatedTargetRow = onPaste({\n      sourceRow: copiedCell.row,\n      sourceColumnKey: copiedCell.columnKey,\n      targetRow,\n      targetColumnKey: columns[idx].key\n    });\n    updateRow(rowIdx, updatedTargetRow);\n  }\n\n  function handleCellInput(event) {\n    var _column$editorOptions;\n\n    if (!isCellWithinBounds(selectedPosition)) return;\n    const row = rows[selectedPosition.rowIdx];\n    if (isGroupRow(row)) return;\n    const {\n      key\n    } = event;\n    const column = columns[selectedPosition.idx];\n\n    if (selectedPosition.mode === 'EDIT') {\n      if (key === 'Enter') {\n        commitEditorChanges();\n        closeEditor();\n      }\n\n      return;\n    }\n\n    (_column$editorOptions = column.editorOptions) == null ? void 0 : _column$editorOptions.onCellKeyDown == null ? void 0 : _column$editorOptions.onCellKeyDown(event);\n    if (event.isDefaultPrevented()) return;\n\n    if (isCellEditable(selectedPosition) && isDefaultCellInput(event)) {\n      setSelectedPosition(({\n        idx,\n        rowIdx\n      }) => ({\n        idx,\n        rowIdx,\n        key,\n        mode: 'EDIT',\n        row,\n        originalRow: row\n      }));\n    }\n  }\n\n  function handleDragEnd() {\n    const overRowIdx = latestDraggedOverRowIdx.current;\n    if (overRowIdx === undefined || !onFill || !onRowsChange) return;\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const startRowIndex = rowIdx < overRowIdx ? rowIdx + 1 : overRowIdx;\n    const endRowIndex = rowIdx < overRowIdx ? overRowIdx + 1 : rowIdx;\n    const targetRows = rawRows.slice(startRowIndex, endRowIndex);\n    const column = columns[idx];\n    const updatedTargetRows = onFill({\n      columnKey: column.key,\n      sourceRow,\n      targetRows\n    });\n    const updatedRows = [...rawRows];\n    const indexes = [];\n\n    for (let i = startRowIndex; i < endRowIndex; i++) {\n      updatedRows[i] = updatedTargetRows[i - startRowIndex];\n      indexes.push(i);\n    }\n\n    onRowsChange(updatedRows, {\n      indexes,\n      column\n    });\n    setDraggedOverRowIdx(undefined);\n  }\n\n  function handleMouseDown(event) {\n    if (event.buttons !== 1) return;\n    setDragging(true);\n    window.addEventListener('mouseover', onMouseOver);\n    window.addEventListener('mouseup', onMouseUp);\n\n    function onMouseOver(event) {\n      if (event.buttons !== 1) onMouseUp();\n    }\n\n    function onMouseUp() {\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mouseup', onMouseUp);\n      setDragging(false);\n      handleDragEnd();\n    }\n  }\n\n  function handleDoubleClick(event) {\n    event.stopPropagation();\n    if (!onFill || !onRowsChange) return;\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const targetRows = rawRows.slice(rowIdx + 1);\n    const column = columns[idx];\n    const updatedTargetRows = onFill({\n      columnKey: column.key,\n      sourceRow,\n      targetRows\n    });\n    const updatedRows = [...rawRows];\n    const indexes = [];\n\n    for (let i = rowIdx + 1; i < updatedRows.length; i++) {\n      updatedRows[i] = updatedTargetRows[i - rowIdx - 1];\n      indexes.push(i);\n    }\n\n    onRowsChange(updatedRows, {\n      indexes,\n      column\n    });\n  }\n\n  function handleEditorRowChange(row, commitChanges) {\n    if (selectedPosition.mode === 'SELECT') return;\n\n    if (commitChanges) {\n      updateRow(getRawRowIdx(selectedPosition.rowIdx), row);\n      closeEditor();\n    } else {\n      setSelectedPosition(position => ({ ...position,\n        row\n      }));\n    }\n  }\n\n  function handleOnClose(commitChanges) {\n    if (commitChanges) {\n      commitEditorChanges();\n    }\n\n    closeEditor();\n  }\n\n  function isCellWithinBounds({\n    idx,\n    rowIdx\n  }) {\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= minColIdx && idx < columns.length;\n  }\n\n  function isCellEditable(position) {\n    return isCellWithinBounds(position) && isSelectedCellEditable({\n      columns,\n      rows,\n      selectedPosition: position,\n      isGroupRow\n    });\n  }\n\n  function selectCell(position, enableEditor = false) {\n    if (!isCellWithinBounds(position)) return;\n    commitEditorChanges();\n\n    if (enableEditor && isCellEditable(position)) {\n      const row = rows[position.rowIdx];\n      setSelectedPosition({ ...position,\n        mode: 'EDIT',\n        key: null,\n        row,\n        originalRow: row\n      });\n    } else {\n      setSelectedPosition({ ...position,\n        mode: 'SELECT'\n      });\n    }\n\n    onSelectedCellChange == null ? void 0 : onSelectedCellChange({ ...position\n    });\n  }\n\n  function closeEditor() {\n    if (selectedPosition.mode === 'SELECT') return;\n    setSelectedPosition(({\n      idx,\n      rowIdx\n    }) => ({\n      idx,\n      rowIdx,\n      mode: 'SELECT'\n    }));\n  }\n\n  function scrollToCell({\n    idx,\n    rowIdx\n  }) {\n    const {\n      current\n    } = gridRef;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      const {\n        clientWidth\n      } = current;\n      const {\n        left,\n        width\n      } = columnMetrics.get(columns[idx]);\n      const isCellAtLeftBoundary = left < scrollLeft + totalFrozenColumnWidth;\n      const isCellAtRightBoundary = left + width > clientWidth + scrollLeft;\n\n      if (isCellAtLeftBoundary) {\n        current.scrollLeft = left - totalFrozenColumnWidth;\n      } else if (isCellAtRightBoundary) {\n        current.scrollLeft = left + width - clientWidth;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      if (rowIdx * rowHeight < scrollTop) {\n        current.scrollTop = rowIdx * rowHeight;\n      } else if ((rowIdx + 1) * rowHeight > scrollTop + clientHeight) {\n        current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getNextPosition(key, ctrlKey, shiftKey) {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const row = rows[rowIdx];\n    const isRowSelected = isCellWithinBounds(selectedPosition) && idx === -1;\n\n    if (key === 'ArrowLeft' && isRowSelected && isGroupRow(row) && !row.isExpanded && row.level !== 0) {\n      let parentRowIdx = -1;\n\n      for (let i = selectedPosition.rowIdx - 1; i >= 0; i--) {\n        const parentRow = rows[i];\n\n        if (isGroupRow(parentRow) && parentRow.id === row.parentId) {\n          parentRowIdx = i;\n          break;\n        }\n      }\n\n      if (parentRowIdx !== -1) {\n        return {\n          idx,\n          rowIdx: parentRowIdx\n        };\n      }\n    }\n\n    switch (key) {\n      case 'ArrowUp':\n        return {\n          idx,\n          rowIdx: rowIdx - 1\n        };\n\n      case 'ArrowDown':\n        return {\n          idx,\n          rowIdx: rowIdx + 1\n        };\n\n      case 'ArrowLeft':\n        return {\n          idx: idx - 1,\n          rowIdx\n        };\n\n      case 'ArrowRight':\n        return {\n          idx: idx + 1,\n          rowIdx\n        };\n\n      case 'Tab':\n        if (selectedPosition.idx === -1 && selectedPosition.rowIdx === -1) {\n          return shiftKey ? {\n            idx: columns.length - 1,\n            rowIdx: rows.length - 1\n          } : {\n            idx: 0,\n            rowIdx: 0\n          };\n        }\n\n        return {\n          idx: idx + (shiftKey ? -1 : 1),\n          rowIdx\n        };\n\n      case 'Home':\n        if (isRowSelected) return {\n          idx,\n          rowIdx: 0\n        };\n        return ctrlKey ? {\n          idx: 0,\n          rowIdx: 0\n        } : {\n          idx: 0,\n          rowIdx\n        };\n\n      case 'End':\n        if (isRowSelected) return {\n          idx,\n          rowIdx: rows.length - 1\n        };\n        return ctrlKey ? {\n          idx: columns.length - 1,\n          rowIdx: rows.length - 1\n        } : {\n          idx: columns.length - 1,\n          rowIdx\n        };\n\n      case 'PageUp':\n        return {\n          idx,\n          rowIdx: rowIdx - Math.floor(clientHeight / rowHeight)\n        };\n\n      case 'PageDown':\n        return {\n          idx,\n          rowIdx: rowIdx + Math.floor(clientHeight / rowHeight)\n        };\n\n      default:\n        return selectedPosition;\n    }\n  }\n\n  function navigate(event) {\n    if (selectedPosition.mode === 'EDIT') {\n      var _columns$selectedPosi2, _columns$selectedPosi3;\n\n      const onNavigation = (_columns$selectedPosi2 = (_columns$selectedPosi3 = columns[selectedPosition.idx].editorOptions) == null ? void 0 : _columns$selectedPosi3.onNavigation) != null ? _columns$selectedPosi2 : onEditorNavigation;\n      if (!onNavigation(event)) return;\n    }\n\n    const {\n      key,\n      shiftKey\n    } = event;\n    let mode = cellNavigationMode;\n\n    if (key === 'Tab') {\n      if (canExitGrid({\n        shiftKey,\n        cellNavigationMode,\n        columns,\n        rowsCount: rows.length,\n        selectedPosition\n      })) {\n        commitEditorChanges();\n        return;\n      }\n\n      mode = cellNavigationMode === 'NONE' ? 'CHANGE_ROW' : cellNavigationMode;\n    }\n\n    event.preventDefault();\n    const ctrlKey = isCtrlKeyHeldDown(event);\n    let nextPosition = getNextPosition(key, ctrlKey, shiftKey);\n    nextPosition = getNextSelectedCellPosition({\n      columns,\n      rowsCount: rows.length,\n      cellNavigationMode: mode,\n      nextPosition\n    });\n    selectCell(nextPosition);\n  }\n\n  function getDraggedOverCellIdx(currentRowIdx) {\n    if (draggedOverRowIdx === undefined) return;\n    const {\n      rowIdx\n    } = selectedPosition;\n    const isDraggedOver = rowIdx < draggedOverRowIdx ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n    return isDraggedOver ? selectedPosition.idx : undefined;\n  }\n\n  function getSelectedCellProps(rowIdx) {\n    if (selectedPosition.rowIdx !== rowIdx) return;\n\n    if (selectedPosition.mode === 'EDIT') {\n      return {\n        mode: 'EDIT',\n        idx: selectedPosition.idx,\n        onKeyDown: handleKeyDown,\n        editorProps: {\n          editorPortalTarget,\n          rowHeight,\n          row: selectedPosition.row,\n          onRowChange: handleEditorRowChange,\n          onClose: handleOnClose\n        }\n      };\n    }\n\n    return {\n      mode: 'SELECT',\n      idx: selectedPosition.idx,\n      onFocus: handleFocus,\n      onKeyDown: handleKeyDown,\n      dragHandleProps: enableCellDragAndDrop && isCellEditable(selectedPosition) ? {\n        onMouseDown: handleMouseDown,\n        onDoubleClick: handleDoubleClick\n      } : undefined\n    };\n  }\n\n  function getViewportRows() {\n    const rowElements = [];\n    let startRowIndex = 0;\n\n    for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      const row = rows[rowIdx];\n      const top = rowIdx * rowHeight + totalHeaderHeight;\n\n      if (isGroupRow(row)) {\n        ({\n          startRowIndex\n        } = row);\n        rowElements.push( /*#__PURE__*/jsx(GroupRowRenderer, {\n          \"aria-level\": row.level + 1,\n          \"aria-setsize\": row.setSize,\n          \"aria-posinset\": row.posInSet + 1,\n          \"aria-rowindex\": headerRowsCount + startRowIndex + 1,\n          id: row.id,\n          groupKey: row.groupKey,\n          viewportColumns: viewportColumns,\n          childRows: row.childRows,\n          rowIdx: rowIdx,\n          top: top,\n          level: row.level,\n          isExpanded: row.isExpanded,\n          selectedCellIdx: selectedPosition.rowIdx === rowIdx ? selectedPosition.idx : undefined,\n          isRowSelected: isSelectable && row.childRows.every(cr => selectedRows == null ? void 0 : selectedRows.has(rowKeyGetter(cr))),\n          onFocus: selectedPosition.rowIdx === rowIdx ? handleFocus : undefined,\n          onKeyDown: selectedPosition.rowIdx === rowIdx ? handleKeyDown : undefined,\n          selectCell: selectCellWrapper,\n          selectRow: selectRowWrapper,\n          toggleGroup: toggleGroupWrapper\n        }, row.id));\n        continue;\n      }\n\n      startRowIndex++;\n      let key = hasGroups ? startRowIndex : rowIdx;\n      let isRowSelected = false;\n\n      if (typeof rowKeyGetter === 'function') {\n        var _selectedRows$has;\n\n        key = rowKeyGetter(row);\n        isRowSelected = (_selectedRows$has = selectedRows == null ? void 0 : selectedRows.has(key)) != null ? _selectedRows$has : false;\n      }\n\n      rowElements.push( /*#__PURE__*/jsx(RowRenderer, {\n        \"aria-rowindex\": headerRowsCount + (hasGroups ? startRowIndex : rowIdx) + 1,\n        \"aria-selected\": isSelectable ? isRowSelected : undefined,\n        rowIdx: rowIdx,\n        row: row,\n        viewportColumns: viewportColumns,\n        isRowSelected: isRowSelected,\n        onRowClick: onRowClick,\n        rowClass: rowClass,\n        top: top,\n        copiedCellIdx: copiedCell !== null && copiedCell.row === row ? columns.findIndex(c => c.key === copiedCell.columnKey) : undefined,\n        draggedOverCellIdx: getDraggedOverCellIdx(rowIdx),\n        setDraggedOverRowIdx: isDragging ? setDraggedOverRowIdx : undefined,\n        selectedCellProps: getSelectedCellProps(rowIdx),\n        onRowChange: handleFormatterRowChangeWrapper,\n        selectCell: selectCellWrapper,\n        selectRow: selectRowWrapper\n      }, key));\n    }\n\n    return rowElements;\n  }\n\n  if (selectedPosition.idx >= columns.length || selectedPosition.rowIdx >= rows.length) {\n    setSelectedPosition({\n      idx: -1,\n      rowIdx: -1,\n      mode: 'SELECT'\n    });\n    setDraggedOverRowIdx(undefined);\n  }\n\n  if (selectedPosition.mode === 'EDIT' && rows[selectedPosition.rowIdx] !== selectedPosition.originalRow) {\n    closeEditor();\n  }\n\n  return /*#__PURE__*/jsxs(\"div\", {\n    role: hasGroups ? 'treegrid' : 'grid',\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-multiselectable\": isSelectable ? true : undefined,\n    \"aria-colcount\": columns.length,\n    \"aria-rowcount\": headerRowsCount + rowsCount + summaryRowsCount,\n    className: clsx(rootClassname, className, isDragging && viewportDraggingClassname),\n    style: { ...style,\n      '--header-row-height': `${headerRowHeight}px`,\n      '--filter-row-height': `${headerFiltersHeight}px`,\n      '--row-width': `${totalColumnWidth}px`,\n      '--row-height': `${rowHeight}px`,\n      '--summary-row-height': `${summaryRowHeight}px`,\n      ...layoutCssVars\n    },\n    ref: gridRef,\n    onScroll: handleScroll,\n    children: [/*#__PURE__*/jsx(HeaderRow$1, {\n      rowKeyGetter: rowKeyGetter,\n      rows: rawRows,\n      columns: viewportColumns,\n      onColumnResize: handleColumnResize,\n      allRowsSelected: (selectedRows == null ? void 0 : selectedRows.size) === rawRows.length,\n      onSelectedRowsChange: onSelectedRowsChange,\n      sortColumn: sortColumn,\n      sortDirection: sortDirection,\n      onSort: onSort\n    }), enableFilterRow && /*#__PURE__*/jsx(FilterRow$1, {\n      columns: viewportColumns,\n      filters: filters,\n      onFiltersChange: onFiltersChange\n    }), rows.length === 0 && EmptyRowsRenderer ? /*#__PURE__*/jsx(EmptyRowsRenderer, {}) : /*#__PURE__*/jsxs(Fragment, {\n      children: [/*#__PURE__*/jsx(\"div\", {\n        ref: focusSinkRef,\n        tabIndex: 0,\n        className: focusSinkClassname,\n        onKeyDown: handleKeyDown,\n        onFocus: onGridFocus\n      }), /*#__PURE__*/jsx(\"div\", {\n        style: {\n          height: Math.max(rows.length * rowHeight, clientHeight)\n        }\n      }), getViewportRows(), summaryRows == null ? void 0 : summaryRows.map((row, rowIdx) => /*#__PURE__*/jsx(SummaryRow$1, {\n        \"aria-rowindex\": headerRowsCount + rowsCount + rowIdx + 1,\n        rowIdx: rowIdx,\n        row: row,\n        bottom: summaryRowHeight * (summaryRows.length - 1 - rowIdx),\n        viewportColumns: viewportColumns\n      }, rowIdx))]\n    })]\n  });\n}\n\nconst DataGrid$1 = /*#__PURE__*/forwardRef(DataGrid);\nvar css_248z = \".t16y9g8l700-canary38{-webkit-appearance:none;-moz-appearance:none;appearance:none;box-sizing:border-box;width:100%;height:100%;padding:0 6px;border:2px solid #ccc;vertical-align:top;color:var(--color);background-color:var(--background-color);font-family:inherit;font-size:var(--font-size)}.t16y9g8l700-canary38:focus{border-color:var(--selection-color);outline:none}.t16y9g8l700-canary38::-webkit-input-placeholder{color:#999;opacity:1}.t16y9g8l700-canary38::-moz-placeholder{color:#999;opacity:1}.t16y9g8l700-canary38:-ms-input-placeholder{color:#999;opacity:1}.t16y9g8l700-canary38::placeholder{color:#999;opacity:1}\";\nstyleInject(css_248z);\nconst textEditor = \"t16y9g8l700-canary38\";\nconst textEditorClassname = `rdg-text-editor ${textEditor}`;\n\nfunction autoFocusAndSelect(input) {\n  input == null ? void 0 : input.focus();\n  input == null ? void 0 : input.select();\n}\n\nfunction TextEditor({\n  row,\n  column,\n  onRowChange,\n  onClose\n}) {\n  return /*#__PURE__*/jsx(\"input\", {\n    className: textEditorClassname,\n    ref: autoFocusAndSelect,\n    value: row[column.key],\n    onChange: event => onRowChange({ ...row,\n      [column.key]: event.target.value\n    }),\n    onBlur: () => onClose(true)\n  });\n}\n\nexport default DataGrid$1;\nexport { Cell$1 as Cell, Row$1 as Row, SELECT_COLUMN_KEY, SelectCellFormatter, SelectColumn, SortableHeaderCell, TextEditor, ToggleGroupFormatter, ValueFormatter };","map":{"version":3,"sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/style/cell.ts","../src/style/core.ts","../src/style/grouprow.ts","../src/style/header.ts","../src/style/row.ts","../src/hooks/useClickOutside.ts","../src/hooks/useGridDimensions.ts","../src/hooks/useFocusRef.ts","../src/formatters/SelectCellFormatter.tsx","../src/formatters/ValueFormatter.tsx","../src/formatters/ToggleGroupFormatter.tsx","../src/utils/domUtils.ts","../src/Columns.tsx","../src/hooks/useViewportColumns.ts","../src/hooks/useViewportRows.ts","../src/hooks/useLatestFunc.ts","../src/headerCells/SortableHeaderCell.tsx","../src/utils/keyboardUtils.ts","../src/utils/selectedCellUtils.ts","../src/utils/index.ts","../src/HeaderCell.tsx","../src/HeaderRow.tsx","../src/FilterRow.tsx","../src/Cell.tsx","../src/editors/EditorContainer.tsx","../src/EditCell.tsx","../src/Row.tsx","../src/GroupCell.tsx","../src/GroupRow.tsx","../src/SummaryCell.tsx","../src/SummaryRow.tsx","../src/DataGrid.tsx","../src/editors/TextEditor.tsx"],"names":["cell","cellClassname","cellFrozen","cellFrozenClassname","cellFrozenLast","cellFrozenLastClassname","cellSelected","cellSelectedClassname","root","rootClassname","focusSink","focusSinkClassname","viewportDragging","viewportDraggingClassname","groupRow","groupRowClassname","groupRowSelected","groupRowSelectedClassname","headerRowAndFilterRow","headerRow","headerRowClassname","filterRow","filterRowClassname","row","rowClassname","rowSelected","rowSelectedClassname","summaryRow","summaryRowClassname","frameRequestRef","useRef","cancelAnimationFrame","onClickRef","useEffect","cancelAnimationFrameRequest","requestAnimationFrame","window","capture","gridRef","useState","useLayoutEffect","ResizeObserver","resizeObserver","clientHeight","setGridWidth","setGridHeight","ref","preventScroll","checkboxLabel","checkboxLabelClassname","checkboxInput","checkboxInputClassname","checkbox","checkboxClassname","checkboxLabelDisabled","checkboxLabelDisabledClassname","ariaLabelledBy","inputRef","useFocusRef","handleChange","e","onChange","clsx","disabled","onClick","props","groupCellContent","groupCellContentClassname","caret","caretClassname","toggleGroup","cellRef","handleKeyDown","key","d","isExpanded","event","SELECT_COLUMN_KEY","SelectColumn","name","width","maxWidth","resizable","sortable","frozen","headerRenderer","onAllRowsSelectionChange","formatter","onRowSelectionChange","groupFormatter","stopPropagation","rawGroupBy","minColumnWidth","defaultColumnOptions","defaultFormatter","defaultSortable","defaultResizable","groupBy","useMemo","lastFrozenColumnIndex","columns","rawColumn","rowGroup","column","idx","isLastFrozenColumn","frozenA","frozenB","aKey","bKey","columnMetrics","left","totalColumnWidth","totalFrozenColumnWidth","templateColumns","allocatedWidth","unassignedColumnsCount","getSpecifiedWidth","clampColumnWidth","unallocatedWidth","viewportWidth","unallocatedColumnWidth","columnMetric","layoutCssVars","i","viewportLeft","scrollLeft","viewportRight","lastColIdx","firstUnfrozenColumnIdx","Math","colVisibleStartIdx","colVisibleEndIdx","colOverscanStartIdx","colOverscanEndIdx","viewportColumns","colIdx","columnWidths","parseInt","minWidth","RENDER_BACTCH_SIZE","Array","expandedGroupIds","rawRows","groupRows","groupRowsCount","groups","Object","rowGrouper","remainingGroupByKeys","childRows","startRowIndex","childRowsCount","allGroupRows","flattenedRows","expandGroup","isReadonlyArray","id","parentId","groupKey","rows","setSize","keys","length","level","isGroupRow","overscanThreshold","rowVisibleStartIdx","scrollTop","rowVisibleEndIdx","rowOverscanStartIdx","rowOverscanEndIdx","useCallback","headerSortCell","headerSortCellClassname","headerSortName","headerSortNameClassname","children","sortDirection","sortColumn","sortText","onSort","sortDescendingFirst","direction","nonInputKeys","target","selectedPosition","nextPosition","cellNavigationMode","rowIdx","columnsCount","isAfterLastColumn","isBeforeFirstColumn","isLastRow","rowsCount","isFirstRow","shiftKey","atLastCellInRow","atFirstCellInRow","atLastRow","atFirstRow","gridColumnStart","cellResizable","cellResizableClassname","onPointerDown","pointerId","right","currentTarget","offset","clientX","onPointerMove","onPointerUp","onResize","getCell","className","getCellClassname","getAriaSort","getCellStyle","handleAllRowsSelectionChange","checked","assertIsValidKeyGetter","newSelectedRows","onSelectedRowsChange","memo","onFiltersChange","newFilters","filters","value","cellCopied","cellCopiedClassname","cellDraggedOver","cellDraggedOverClassname","cellDragHandle","cellDragHandleClassname","cellClass","isCellSelected","isCopied","isDraggedOver","selectCellWrapper","openEditor","selectCell","handleClick","onRowClick","handleContextMenu","onContextMenu","handleDoubleClick","onDoubleClick","handleRowChange","newRow","onRowChange","isShiftClick","selectRow","dragHandleProps","forwardRef","editorContainer","editorContainerClassname","onClickCapture","useClickOutside","undefined","editor","editorOptions","createPortal","cellEditing","cellEditingClassname","node","top","setDimensions","getCellContent","dimensions","docLeft","document","documentElement","gridLeft","gridTop","docTop","cellRenderer","CellRenderer","setDraggedOverRowIdx","onMouseEnter","isRowSelected","rowClass","selectedCellProps","editorProps","copiedCellIdx","draggedOverCellIdx","toggleGroupWrapper","isLevelMatching","groupColumnIndex","cursor","selectedCellIdx","summaryFormatter","summaryCellClass","SummaryFormatter","ariaRowIndex","bottom","body","globalThis","rowHeight","headerRowHeight","headerFiltersHeight","summaryRowHeight","rowRenderer","RowRenderer","emptyRowsRenderer","enableFilterRow","editorPortalTarget","ariaDescribedBy","mode","focusSinkRef","prevSelectedPosition","latestDraggedOverRowIdx","lastSelectedRowIdx","isCellFocusable","selectRowWrapper","useLatestFunc","handleFormatterRowChangeWrapper","useGridDimensions","headerRowsCount","summaryRowsCount","summaryRows","totalHeaderHeight","gridHeight","isSelectable","selectedRows","useViewportColumns","useViewportRows","hasGroups","minColIdx","enableCellDragAndDrop","onFill","isCellWithinBounds","scrollToCell","useImperativeHandle","element","scrollToColumn","scrollToRow","current","behavior","handleColumnResize","setColumnWidths","newColumnWidths","onColumnResize","setOverRowIdx","rowKey","rowKeyGetter","previousRowIdx","step","newExpandedGroupIds","onExpandedGroupIdsChange","initialPosition","setSelectedPosition","keyCode","onPaste","isCtrlKeyHeldDown","cKey","vKey","handleCopy","handlePaste","setCopiedCell","closeEditor","navigate","handleCellInput","setScrollTop","setScrollLeft","onScroll","updatedRows","onRowsChange","indexes","getRawRowIdx","updateRow","columnKey","targetRow","copiedCell","isCellEditable","updatedTargetRow","sourceRow","sourceColumnKey","targetColumnKey","commitEditorChanges","isDefaultCellInput","originalRow","overRowIdx","endRowIndex","targetRows","updatedTargetRows","setDragging","onMouseUp","handleDragEnd","position","isSelectedCellEditable","enableEditor","onSelectedCellChange","clientWidth","isCellAtLeftBoundary","isCellAtRightBoundary","parentRowIdx","parentRow","ctrlKey","onNavigation","canExitGrid","getNextPosition","getNextSelectedCellPosition","draggedOverRowIdx","currentRowIdx","onKeyDown","onClose","handleOnClose","onFocus","onMouseDown","rowElements","cr","c","getDraggedOverCellIdx","isDragging","getSelectedCellProps","_jsx","onGridFocus","height","getViewportRows","textEditor","textEditorClassname","input"],"mappings":";;;;;AAAA,SAAS,WAAT,CAAqB,GAArB,EAA0B,GAA1B,EAA+B;AAC7B,MAAK,GAAG,KAAK,KAAK,CAAlB,EAAsB,GAAG,GAAG,EAAN;AACtB,MAAI,QAAQ,GAAG,GAAG,CAAC,QAAnB;;AAEA,MAAI,CAAC,GAAD,IAAQ,OAAO,QAAP,KAAoB,WAAhC,EAA6C;AAAE;AAAS;;AAExD,MAAI,IAAI,GAAG,QAAQ,CAAC,IAAT,IAAiB,QAAQ,CAAC,oBAAT,CAA8B,MAA9B,EAAsC,CAAtC,CAA5B;AACA,MAAI,KAAK,GAAG,QAAQ,CAAC,aAAT,CAAuB,OAAvB,CAAZ;AACA,EAAA,KAAK,CAAC,IAAN,GAAa,UAAb;;AAEA,MAAI,QAAQ,KAAK,KAAjB,EAAwB;AACtB,QAAI,IAAI,CAAC,UAAT,EAAqB;AACnB,MAAA,IAAI,CAAC,YAAL,CAAkB,KAAlB,EAAyB,IAAI,CAAC,UAA9B;AACD,KAFD,MAEO;AACL,MAAA,IAAI,CAAC,WAAL,CAAiB,KAAjB;AACD;AACF,GAND,MAMO;AACL,IAAA,IAAI,CAAC,WAAL,CAAiB,KAAjB;AACD;;AAED,MAAI,KAAK,CAAC,UAAV,EAAsB;AACpB,IAAA,KAAK,CAAC,UAAN,CAAiB,OAAjB,GAA2B,GAA3B;AACD,GAFD,MAEO;AACL,IAAA,KAAK,CAAC,WAAN,CAAkB,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CAAlB;AACD;AACH;;;;ACvBO,MAAMA,IAAI,GAAV,qBAAA;AAcA,MAAMC,aAAa,GAAA,YAAeD,IAAlC,EAAA;AAEP,MAAME,UAAU,GAAhB,qBAAA;AAMO,MAAMC,mBAAmB,GAAA,mBAAsBD,UAA/C,EAAA;AAEA,MAAME,cAAc,GAApB,sBAAA;AAIA,MAAMC,uBAAuB,GAAA,wBAA2BD,cAAxD,EAAA;AAEP,MAAME,YAAY,GAAlB,qBAAA;AAIO,MAAMC,qBAAqB,GAAA,qBAAwBD,YAAnD,EAAA;;;ACDP,MAAME,IAAI,GAAV,sBAAA;AA0CO,MAAMC,aAAa,GAAA,OAAUD,IAA7B,EAAA;AAEP,MAAME,SAAS,GAAf,oBAAA;AASO,MAAMC,kBAAkB,GAAA,kBAAqBD,SAA7C,EAAA;AAEP,MAAME,gBAAgB,GAAtB,qBAAA;AAMO,MAAMC,yBAAyB,GAAA,yBAA4BD,gBAA3D,EAAA;;;AC5FP,MAAME,QAAQ,GAAd,sBAAA;AAUO,MAAMC,iBAAiB,GAAA,iBAAoBD,QAA3C,EAAA;AAEP,MAAME,gBAAgB,GAAtB,sBAAA;AAoBO,MAAMC,yBAAyB,GAAA,0BAA6BD,gBAA5D,EAAA;;;AClCP,MAAME,qBAAqB,GAA3B,sBAAA;AAYA,MAAMC,SAAS,GAAf,sBAAA;AAQO,MAAMC,kBAAkB,GAAA,kBAAqBF,qBAAAA,IAAyBC,SAAtE,EAAA;AAEP,MAAME,SAAS,GAAf,qBAAA;AAOO,MAAMC,kBAAkB,GAAA,kBAAqBJ,qBAAAA,IAAyBG,SAAtE,EAAA;;;AC5BA,MAAME,GAAG,GAAT,sBAAA;AAkBA,MAAMC,YAAY,GAAA,WAAcD,GAAhC,EAAA;AAEA,MAAME,WAAW,GAAjB,qBAAA;AAQA,MAAMC,oBAAoB,GAAA,oBAAuBD,WAAjD,EAAA;AAEP,MAAME,UAAU,GAAhB,sBAAA;AAYO,MAAMC,mBAAmB,GAAA,mBAAsBD,UAA/C,EAAA;;ACMA,SAAA,eAAA,CAAA,OAAA,EAA8C;AACnD,QAAME,eAAe,GAAGC,MAAxB,EAAA;;AAEA,WAAA,2BAAA,GAAuC;AACrC,QAAI,OAAOD,eAAe,CAAtB,OAAA,KAAJ,QAAA,EAAiD;AAC/CE,MAAAA,oBAAoB,CAACF,eAAe,CAApCE,OAAoB,CAApBA;AACAF,MAAAA,eAAe,CAAfA,OAAAA,GAAAA,SAAAA;AACD;AACF;;AAKD,QAAMG,UAAU,GAAGF,MAAM,CAAC,MAAY;AACpC,UAAM,IAAA,KAAA,CAAN,+CAAM,CAAN;AADF,GAAyB,CAAzB;AAIAG,EAAAA,SAAS,CAAC,MAAM;AACdD,IAAAA,UAAU,CAAVA,OAAAA,GAAAA,OAAAA;AADFC,GAAS,CAATA;AAIAA,EAAAA,SAAS,CAAC,MAAM;AACd,aAAA,cAAA,GAA0B;AACxBJ,MAAAA,eAAe,CAAfA,OAAAA,GAAAA,SAAAA;AACAG,MAAAA,UAAU,CAAVA,OAAAA;AACD;;AAED,aAAA,oBAAA,GAAgC;AAC9BE,MAAAA,2BAA2B;AAC3BL,MAAAA,eAAe,CAAfA,OAAAA,GAA0BM,qBAAqB,CAA/CN,cAA+C,CAA/CA;AACD;;AAEDO,IAAAA,MAAM,CAANA,gBAAAA,CAAAA,OAAAA,EAAAA,oBAAAA,EAAuD;AAAEC,MAAAA,OAAO,EAAE;AAAX,KAAvDD;AAEA,WAAO,MAAM;AACXA,MAAAA,MAAM,CAANA,mBAAAA,CAAAA,OAAAA,EAAAA,oBAAAA,EAA0D;AAAEC,QAAAA,OAAO,EAAE;AAAX,OAA1DD;AACAF,MAAAA,2BAA2B;AAF7B,KAAA;AAbO,GAAA,EAATD,EAAS,CAATA;AAmBA,SAAA,2BAAA;AACD;;AC1FM,SAAA,iBAAA,GAAoG;AACzG,QAAMK,OAAO,GAAGR,MAAM,CAAtB,IAAsB,CAAtB;AACA,QAAM,CAAA,SAAA,EAAA,YAAA,IAA4BS,QAAQ,CAA1C,CAA0C,CAA1C;AACA,QAAM,CAAA,UAAA,EAAA,aAAA,IAA8BA,QAAQ,CAA5C,CAA4C,CAA5C;AAEAC,EAAAA,eAAe,CAAC,MAAM;AACpB,UAAM;AAAEC,MAAAA;AAAF,QAAN,MAAA;AAIA,QAAIA,cAAc,IAAlB,IAAA,EAA4B;AAE5B,UAAMC,cAAc,GAAG,IAAA,cAAA,CAAmB,MAAM;AAG9C,YAAM;AAAA,QAAA,WAAA;AAAeC,QAAAA;AAAf,UAAgCL,OAAO,CAA7C,OAAA;AACAM,MAAAA,YAAY,CAAZA,WAAY,CAAZA;AACAC,MAAAA,aAAa,CAAbA,YAAa,CAAbA;AALF,KAAuB,CAAvB;AAQAH,IAAAA,cAAc,CAAdA,OAAAA,CAAuBJ,OAAO,CAA9BI,OAAAA;AAEA,WAAO,MAAM;AACXA,MAAAA,cAAc,CAAdA,UAAAA;AADF,KAAA;AAjBa,GAAA,EAAfF,EAAe,CAAfA;AAsBA,SAAO,CAAA,OAAA,EAAA,SAAA,EAAP,UAAO,CAAP;AACD;;AC5BM,SAAA,WAAA,CAAA,cAAA,EAAsF;AAC3F,QAAMM,GAAG,GAAGhB,MAAM,CAAlB,IAAkB,CAAlB;AACAU,EAAAA,eAAe,CAAC,MAAM;AAAA,QAAA,YAAA;;AACpB,QAAI,CAAJ,cAAA,EAAqB;AACrB,KAAA,YAAA,GAAA,GAAG,CAAH,OAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,YAAA,CAAA,KAAA,CAAmB;AAAEO,MAAAA,aAAa,EAAE;AAAjB,KAAnB,CAAA;AAFa,GAAA,EAGZ,CAHHP,cAGG,CAHY,CAAfA;AAKA,SAAA,GAAA;AACD;;;;ACND,MAAMQ,aAAa,GAAnB,sBAAA;AAaA,MAAMC,sBAAsB,GAAA,sBAAyBD,aAArD,EAAA;AAEA,MAAME,aAAa,GAAnB,sBAAA;AAMA,MAAMC,sBAAsB,GAAA,sBAAyBD,aAArD,EAAA;AAEA,MAAME,QAAQ,GAAd,qBAAA;AAiBA,MAAMC,iBAAiB,GAAA,gBAAmBD,QAA1C,EAAA;AAEA,MAAME,qBAAqB,GAA3B,sBAAA;AASA,MAAMC,8BAA8B,GAAA,+BAAkCD,qBAAtE,EAAA;;AAgBO,SAAA,mBAAA,CAA6B;AAAA,EAAA,KAAA;AAAA,EAAA,QAAA;AAAA,EAAA,cAAA;AAAA,EAAA,QAAA;AAAA,EAAA,OAAA;AAAA,EAAA,QAAA;gBAAA,SAAA;qBAQfE;AARe,CAA7B,EASsB;QACrBC,QAAQ,GAAGC,WAAW,CAAA,cAAA,C;;WAEnBC,Y,CAAaC,C,EAAwC;AAC5DC,IAAAA,QAAQ,CAACD,CAAC,CAADA,MAAAA,CAAD,OAAA,EAAoBA,CAAC,CAAF,WAACA,CAA5BC,QAAQ,CAARA;;;sBAIA,IAAA,CAAA,OAAA,EAAA;AAAO,IAAA,SAAA,EAAWC,IAAI,CAAA,sBAAA,EAA6DC,QAA7D,IAAtB,8BAAsB,CAAtB;AAAA,IAAA,QAAA,EAAA,CAAA,aACE,GAAA,CAAA,OAAA,EAAA;AACE,oBADF,SAAA;AAEE,yBAFF,cAAA;AAGE,MAAA,QAAA,EAHF,QAAA;AAIE,MAAA,GAAA,EAJF,QAAA;AAKE,MAAA,IAAA,EALF,UAAA;AAME,MAAA,SAAA,EANF,sBAAA;AAOE,MAAA,QAAA,EAPF,QAAA;AAQE,MAAA,OAAA,EARF,KAAA;AASE,MAAA,QAAA,EATF,YAAA;AAUE,MAAA,OAAA,EAASC;AAVX,KAAA,CADF,EAAA,aAaE,GAAA,CAAA,KAAA,EAAA;AAAK,MAAA,SAAA,EAAWX;AAAhB,KAAA,CAbF;AAAA,GAAA,C;;;ACtFG,SAAA,cAAA,CAAA,KAAA,EAA6D;AAClE,MAAI;AACF,WAAA,aAAO,GAAA,CAAA,QAAA,EAAA;AAAA,MAAA,QAAA,EAAGY,KAAK,CAALA,GAAAA,CAAUA,KAAK,CAALA,MAAAA,CAAVA,GAAAA;AAAH,KAAA,CAAP;AADF,GAAA,CAEE,MAAM;AACN,WAAA,IAAA;AACD;AACF;;;;ACJD,MAAMC,gBAAgB,GAAtB,qBAAA;AAIA,MAAMC,yBAAyB,GAAA,0BAA6BD,gBAA5D,EAAA;AAEA,MAAME,KAAK,GAAX,qBAAA;AAYA,MAAMC,cAAc,GAAA,aAAgBD,KAApC,EAAA;;AAEO,SAAA,oBAAA,CAAqC;AAAA,EAAA,QAAA;AAAA,EAAA,UAAA;AAAA,EAAA,cAAA;AAI1CE,EAAAA;AAJ0C,CAArC,EAKwB;QACvBC,OAAO,GAAGb,WAAW,CAAA,cAAA,C;;WAElBc,a,CAAc;AAAEC,IAAAA;AAAF,G,EAA+C;QAChEA,GAAG,KAAK,O,EAAS;AACnBH,MAAAA,WAAW;;;;QAITI,CAAC,GAAGC,UAAU,GAAA,mBAAA,GAAyB,mB;sBAG3C,IAAA,CAAA,MAAA,EAAA;AACE,IAAA,GAAA,EADF,OAAA;AAEE,IAAA,SAAA,EAFF,yBAAA;AAGE,IAAA,QAAA,EAAU,CAHZ,CAAA;AAIE,IAAA,SAAA,EAJF,aAAA;AAAA,IAAA,QAAA,EAAA,CAAA,QAAA,EAAA,aAOE,GAAA,CAAA,KAAA,EAAA;AAAK,MAAA,OAAA,EAAL,UAAA;AAAwB,MAAA,KAAA,EAAxB,IAAA;AAAmC,MAAA,MAAA,EAAnC,GAAA;AAA8C,MAAA,SAAA,EAA9C,cAAA;AAAA,MAAA,QAAA,EAAA,aACE,GAAA,CAAA,MAAA,EAAA;AAAM,QAAA,CAAA,EAAGD;AAAT,OAAA;AADF,KAAA,CAPF;AAAA,GAAA,C;;;ACzCG,SAAA,eAAA,CAAA,KAAA,EAAsD;AAC3DE,EAAAA,KAAK,CAALA,eAAAA;AACD;;MCEYC,iBAAiB,GAAG,Y;MAGpBC,YAA8B,GAAG;AAC5CL,EAAAA,GAAG,EADyC,iBAAA;AAE5CM,EAAAA,IAAI,EAFwC,EAAA;AAG5CC,EAAAA,KAAK,EAHuC,EAAA;AAI5CC,EAAAA,QAAQ,EAJoC,EAAA;AAK5CC,EAAAA,SAAS,EALmC,KAAA;AAM5CC,EAAAA,QAAQ,EANoC,KAAA;AAO5CC,EAAAA,MAAM,EAPsC,IAAA;;AAQ5CC,EAAAA,cAAc,CAAA,KAAA,EAAQ;AACpB,WAAA,aACE,GAAA,CAAA,mBAAA,EAAA;AACE,oBADF,YAAA;AAEE,MAAA,KAAK,EAAEpB,KAAK,CAFd,eAAA;AAGE,MAAA,QAAQ,EAAEA,KAAK,CAACqB;AAHlB,KAAA,CADF;AAT0C,GAAA;;AAiB5CC,EAAAA,SAAS,CAAA,KAAA,EAAQ;AACf,WAAA,aACE,GAAA,CAAA,mBAAA,EAAA;AACE,oBADF,QAAA;AAEE,MAAA,QAAQ,EAAE,CAFZ,CAAA;AAGE,MAAA,cAAc,EAAEtB,KAAK,CAHvB,cAAA;AAIE,MAAA,KAAK,EAAEA,KAAK,CAJd,aAAA;AAKE,MAAA,OAAO,EALT,eAAA;AAME,MAAA,QAAQ,EAAEA,KAAK,CAACuB;AANlB,KAAA,CADF;AAlB0C,GAAA;;AA6B5CC,EAAAA,cAAc,CAAA,KAAA,EAAQ;AACpB,WAAA,aACE,GAAA,CAAA,mBAAA,EAAA;AACE,oBADF,cAAA;AAEE,MAAA,QAAQ,EAAE,CAFZ,CAAA;AAGE,MAAA,cAAc,EAAExB,KAAK,CAHvB,cAAA;AAIE,MAAA,KAAK,EAAEA,KAAK,CAJd,aAAA;AAKE,MAAA,QAAQ,EAAEA,KAAK,CALjB,oBAAA;AAOE,MAAA,OAAO,EAAEyB;AAPX,KAAA,CADF;AAWD;;AAzC2C,C;;ACQvC,SAAA,kBAAA,CAAmC;AAAA,EAAA,UAAA;AAAA,EAAA,YAAA;AAAA,EAAA,aAAA;AAAA,EAAA,UAAA;AAAA,EAAA,oBAAA;AAMxCC,EAAAA;AANwC,CAAnC,EAOwB;AAAA,MAAA,qBAAA,EAAA,sBAAA,EAAA,sBAAA,EAAA,sBAAA;;AAC7B,QAAMC,cAAc,GAAA,CAAA,qBAAA,GAAGC,oBAAH,IAAA,IAAGA,GAAH,KAAA,CAAGA,GAAAA,oBAAoB,CAAvB,QAAA,KAAA,IAAA,GAAA,qBAAA,GAApB,EAAA;AACA,QAAMC,gBAAgB,GAAA,CAAA,sBAAA,GAAGD,oBAAH,IAAA,IAAGA,GAAH,KAAA,CAAGA,GAAAA,oBAAoB,CAAvB,SAAA,KAAA,IAAA,GAAA,sBAAA,GAAtB,cAAA;AACA,QAAME,eAAe,GAAA,CAAA,sBAAA,GAAGF,oBAAH,IAAA,IAAGA,GAAH,KAAA,CAAGA,GAAAA,oBAAoB,CAAvB,QAAA,KAAA,IAAA,GAAA,sBAAA,GAArB,KAAA;AACA,QAAMG,gBAAgB,GAAA,CAAA,sBAAA,GAAGH,oBAAH,IAAA,IAAGA,GAAH,KAAA,CAAGA,GAAAA,oBAAoB,CAAvB,SAAA,KAAA,IAAA,GAAA,sBAAA,GAAtB,KAAA;AAEA,QAAM;AAAA,IAAA,OAAA;AAAA,IAAA,qBAAA;AAAkCI,IAAAA;AAAlC,MAA8CC,OAAO,CAAC,MAAM;AAEhE,UAAMD,OAAiB,GAAvB,EAAA;AACA,QAAIE,qBAAqB,GAAG,CAA5B,CAAA;AAEA,UAAMC,OAAO,GAAG,UAAU,CAAV,GAAA,CAAeC,SAAS,IAAI;AAAA,UAAA,oBAAA,EAAA,mBAAA,EAAA,oBAAA,EAAA,oBAAA;;AAC1C,YAAMC,QAAQ,GAAA,CAAA,oBAAA,GAAGX,UAAH,IAAA,IAAGA,GAAH,KAAA,CAAGA,GAAAA,UAAU,CAAVA,QAAAA,CAAqBU,SAAS,CAAjC,GAAGV,CAAH,KAAA,IAAA,GAAA,oBAAA,GAAd,KAAA;AAEA,YAAMP,MAAM,GAAGkB,QAAQ,IAAID,SAAS,CAArBC,MAAAA,IAAf,KAAA;AAEA,YAAMC,MAA+B,GAAG,EACtC,GADsC,SAAA;AAEtCC,QAAAA,GAAG,EAFmC,CAAA;AAAA,QAAA,MAAA;AAItCC,QAAAA,kBAAkB,EAJoB,KAAA;AAAA,QAAA,QAAA;AAMtCtB,QAAAA,QAAQ,EAAA,CAAA,mBAAA,GAAEkB,SAAS,CAAX,QAAA,KAAA,IAAA,GAAA,mBAAA,GAN8B,eAAA;AAOtCnB,QAAAA,SAAS,EAAA,CAAA,oBAAA,GAAEmB,SAAS,CAAX,SAAA,KAAA,IAAA,GAAA,oBAAA,GAP6B,gBAAA;AAQtCd,QAAAA,SAAS,EAAA,CAAA,oBAAA,GAAEc,SAAS,CAAX,SAAA,KAAA,IAAA,GAAA,oBAAA,GAAyBP;AARI,OAAxC;;AAWA,UAAA,QAAA,EAAc;AAAA,YAAA,qBAAA;;AACZ,SAAA,qBAAA,GAAA,MAAM,CAAN,cAAA,KAAA,IAAA,GAAA,qBAAA,GAAA,MAAM,CAAN,cAAA,GAAA,oBAAA;AACD;;AAED,UAAA,MAAA,EAAY;AACVK,QAAAA,qBAAqB;AACtB;;AAED,aAAA,MAAA;AAxBF,KAAgB,CAAhB;AA2BAC,IAAAA,OAAO,CAAPA,IAAAA,CAAa,CAAC;AAAE3B,MAAAA,GAAG,EAAL,IAAA;AAAaW,MAAAA,MAAM,EAAEsB;AAArB,KAAD,EAAiC;AAAEjC,MAAAA,GAAG,EAAL,IAAA;AAAaW,MAAAA,MAAM,EAAEuB;AAArB,KAAjC,KAAoE;AAE/E,UAAIC,IAAI,KAAR,iBAAA,EAAgC,OAAO,CAAP,CAAA;AAChC,UAAIC,IAAI,KAAR,iBAAA,EAAgC,OAAA,CAAA;;AAGhC,UAAIlB,UAAJ,IAAA,IAAIA,IAAAA,UAAU,CAAVA,QAAAA,CAAJ,IAAIA,CAAJ,EAAgC;AAC9B,YAAIA,UAAU,CAAVA,QAAAA,CAAJ,IAAIA,CAAJ,EAA+B;AAC7B,iBAAOA,UAAU,CAAVA,OAAAA,CAAAA,IAAAA,IAA2BA,UAAU,CAAVA,OAAAA,CAAlC,IAAkCA,CAAlC;AACD;;AACD,eAAO,CAAP,CAAA;AACD;;AACD,UAAIA,UAAJ,IAAA,IAAIA,IAAAA,UAAU,CAAVA,QAAAA,CAAJ,IAAIA,CAAJ,EAAgC,OAAA,CAAA;;AAGhC,UAAA,OAAA,EAAa;AACX,YAAA,OAAA,EAAa,OAAA,CAAA;AACb,eAAO,CAAP,CAAA;AACD;;AACD,UAAA,OAAA,EAAa,OAAA,CAAA;AAGb,aAAA,CAAA;AAtBFS,KAAAA;AAyBAA,IAAAA,OAAO,CAAPA,OAAAA,CAAgB,CAAA,MAAA,EAAA,GAAA,KAAiB;AAC/BG,MAAAA,MAAM,CAANA,GAAAA,GAAAA,GAAAA;;AAEA,UAAIA,MAAM,CAAV,QAAA,EAAqB;AACnBN,QAAAA,OAAO,CAAPA,IAAAA,CAAaM,MAAM,CAAnBN,GAAAA;AACD;AALHG,KAAAA;;AAQA,QAAID,qBAAqB,KAAK,CAA9B,CAAA,EAAkC;AAChCC,MAAAA,OAAO,CAAPA,qBAAO,CAAPA,CAAAA,kBAAAA,GAAAA,IAAAA;AACD;;AAED,WAAO;AAAA,MAAA,OAAA;AAAA,MAAA,qBAAA;AAGLH,MAAAA;AAHK,KAAP;AArEyD,GAAA,EA0ExD,CAAA,UAAA,EAAA,gBAAA,EAAA,gBAAA,EAAA,eAAA,EA1EH,UA0EG,CA1EwD,CAA3D;AA4EA,QAAM;AAAA,IAAA,aAAA;AAAA,IAAA,gBAAA;AAAA,IAAA,sBAAA;AAA2Da,IAAAA;AAA3D,MAA6EZ,OAAO,CAAC,MAAM;AAC/F,UAAMY,aAAa,GAAG,IAAtB,GAAsB,EAAtB;AACA,QAAIC,IAAI,GAAR,CAAA;AACA,QAAIC,gBAAgB,GAApB,CAAA;AACA,QAAIC,sBAAsB,GAA1B,CAAA;AACA,QAAIC,eAAe,GAAnB,EAAA;AACA,QAAIC,cAAc,GAAlB,CAAA;AACA,QAAIC,sBAAsB,GAA1B,CAAA;;AAEA,SAAK,MAAL,MAAA,IAAA,OAAA,EAA8B;AAC5B,UAAIpC,KAAK,GAAGqC,iBAAiB,CAAA,MAAA,EAAA,YAAA,EAA7B,aAA6B,CAA7B;;AAEA,UAAIrC,KAAK,KAAT,SAAA,EAAyB;AACvBoC,QAAAA,sBAAsB;AADxB,OAAA,MAEO;AACLpC,QAAAA,KAAK,GAAGsC,gBAAgB,CAAA,KAAA,EAAA,MAAA,EAAxBtC,cAAwB,CAAxBA;AACAmC,QAAAA,cAAc,IAAdA,KAAAA;AACAL,QAAAA,aAAa,CAAbA,GAAAA,CAAAA,MAAAA,EAA0B;AAAA,UAAA,KAAA;AAASC,UAAAA,IAAI,EAAE;AAAf,SAA1BD;AACD;AACF;;AAED,UAAMS,gBAAgB,GAAGC,aAAa,GAAtC,cAAA;AACA,UAAMC,sBAAsB,GAAGF,gBAAgB,GAA/C,sBAAA;;AAEA,SAAK,MAAL,MAAA,IAAA,OAAA,EAA8B;AAC5B,UAAA,KAAA;;AACA,UAAIT,aAAa,CAAbA,GAAAA,CAAJ,MAAIA,CAAJ,EAA+B;AAC7B,cAAMY,YAAY,GAAGZ,aAAa,CAAbA,GAAAA,CAArB,MAAqBA,CAArB;AACAY,QAAAA,YAAY,CAAZA,IAAAA,GAAAA,IAAAA;AACA,SAAC;AAAE1C,UAAAA;AAAF,YAAD,YAAA;AAHF,OAAA,MAIO;AACLA,QAAAA,KAAK,GAAGsC,gBAAgB,CAAA,sBAAA,EAAA,MAAA,EAAxBtC,cAAwB,CAAxBA;AACA8B,QAAAA,aAAa,CAAbA,GAAAA,CAAAA,MAAAA,EAA0B;AAAA,UAAA,KAAA;AAASC,UAAAA;AAAT,SAA1BD;AACD;;AACDE,MAAAA,gBAAgB,IAAhBA,KAAAA;AACAD,MAAAA,IAAI,IAAJA,KAAAA;AACAG,MAAAA,eAAe,IAAK,GAAElC,KAAtBkC,KAAAA;AACD;;AAED,QAAIf,qBAAqB,KAAK,CAA9B,CAAA,EAAkC;AAChC,YAAMuB,YAAY,GAAGZ,aAAa,CAAbA,GAAAA,CAAkBV,OAAO,CAA9C,qBAA8C,CAAzBU,CAArB;AACAG,MAAAA,sBAAsB,GAAGS,YAAY,CAAZA,IAAAA,GAAoBA,YAAY,CAAzDT,KAAAA;AACD;;AAED,UAAMU,aAAqC,GAAG;AAC5C,4BAAsBT;AADsB,KAA9C;;AAIA,SAAK,IAAIU,CAAC,GAAV,CAAA,EAAgBA,CAAC,IAAjB,qBAAA,EAA4CA,CAA5C,EAAA,EAAiD;AAC/C,YAAMrB,MAAM,GAAGH,OAAO,CAAtB,CAAsB,CAAtB;AACAuB,MAAAA,aAAa,CAAE,iBAAgBpB,MAAM,CAAC9B,GAAtCkD,EAAa,CAAbA,GAAgD,GAAEb,aAAa,CAAbA,GAAAA,CAAAA,MAAAA,EAA2BC,IAA7EY,IAAAA;AACD;;AAED,WAAO;AAAA,MAAA,aAAA;AAAA,MAAA,gBAAA;AAAA,MAAA,sBAAA;AAA2Db,MAAAA;AAA3D,KAAP;AArDwF,GAAA,EAsDvF,CAAA,YAAA,EAAA,OAAA,EAAA,aAAA,EAAA,cAAA,EAtDH,qBAsDG,CAtDuF,CAA1F;AAwDA,QAAM,CAAA,mBAAA,EAAA,iBAAA,IAA2CZ,OAAO,CAAC,MAAwB;AAE/E,UAAM2B,YAAY,GAAGC,UAAU,GAA/B,sBAAA;AACA,UAAMC,aAAa,GAAGD,UAAU,GAAhC,aAAA;AAEA,UAAME,UAAU,GAAG5B,OAAO,CAAPA,MAAAA,GAAnB,CAAA;AACA,UAAM6B,sBAAsB,GAAGC,IAAI,CAAJA,GAAAA,CAAS/B,qBAAqB,GAA9B+B,CAAAA,EAA/B,UAA+BA,CAA/B;;AAGA,QAAIL,YAAY,IAAhB,aAAA,EAAmC;AACjC,aAAO,CAAA,sBAAA,EAAP,sBAAO,CAAP;AACD;;AAGD,QAAIM,kBAAkB,GAAtB,sBAAA;;AACA,WAAOA,kBAAkB,GAAzB,UAAA,EAAwC;AACtC,YAAM;AAAA,QAAA,IAAA;AAAQnD,QAAAA;AAAR,UAAkB8B,aAAa,CAAbA,GAAAA,CAAkBV,OAAO,CAAjD,kBAAiD,CAAzBU,CAAxB;;AAGA,UAAIC,IAAI,GAAJA,KAAAA,GAAJ,YAAA,EAAiC;AAC/B;AACD;;AACDoB,MAAAA,kBAAkB;AACnB;;AAGD,QAAIC,gBAAgB,GAApB,kBAAA;;AACA,WAAOA,gBAAgB,GAAvB,UAAA,EAAsC;AACpC,YAAM;AAAA,QAAA,IAAA;AAAQpD,QAAAA;AAAR,UAAkB8B,aAAa,CAAbA,GAAAA,CAAkBV,OAAO,CAAjD,gBAAiD,CAAzBU,CAAxB;;AAGA,UAAIC,IAAI,GAAJA,KAAAA,IAAJ,aAAA,EAAmC;AACjC;AACD;;AACDqB,MAAAA,gBAAgB;AACjB;;AAED,UAAMC,mBAAmB,GAAGH,IAAI,CAAJA,GAAAA,CAAAA,sBAAAA,EAAiCC,kBAAkB,GAA/E,CAA4BD,CAA5B;AACA,UAAMI,iBAAiB,GAAGJ,IAAI,CAAJA,GAAAA,CAAAA,UAAAA,EAAqBE,gBAAgB,GAA/D,CAA0BF,CAA1B;AAEA,WAAO,CAAA,mBAAA,EAAP,iBAAO,CAAP;AAxCsD,GAAA,EAyCrD,CAAA,OAAA,EAAA,aAAA,EAAA,qBAAA,EAAA,UAAA,EAAA,sBAAA,EAzCH,aAyCG,CAzCqD,CAAxD;AA2CA,QAAMK,eAAe,GAAGrC,OAAO,CAAC,MAA0C;AACxE,UAAMqC,eAA0C,GAAhD,EAAA;;AACA,SAAK,IAAIC,MAAM,GAAf,CAAA,EAAqBA,MAAM,IAA3B,iBAAA,EAAkDA,MAAlD,EAAA,EAA4D;AAC1D,YAAMjC,MAAM,GAAGH,OAAO,CAAtB,MAAsB,CAAtB;AAEA,UAAIoC,MAAM,GAANA,mBAAAA,IAAgC,CAACjC,MAAM,CAA3C,MAAA,EAAoD;AACpDgC,MAAAA,eAAe,CAAfA,IAAAA,CAAAA,MAAAA;AACD;;AAED,WAAA,eAAA;AAT6B,GAAA,EAU5B,CAAA,iBAAA,EAAA,mBAAA,EAVH,OAUG,CAV4B,CAA/B;AAYA,SAAO;AAAA,IAAA,OAAA;AAAA,IAAA,eAAA;AAAA,IAAA,aAAA;AAAA,IAAA,aAAA;AAAA,IAAA,gBAAA;AAAA,IAAA,qBAAA;AAAA,IAAA,sBAAA;AAA2HtC,IAAAA;AAA3H,GAAP;AACD;;AAED,SAAA,iBAAA,CACE;AAAA,EAAA,GAAA;AAAOjB,EAAAA;AAAP,CADF,EAAA,YAAA,EAAA,aAAA,EAIsB;AACpB,MAAIyD,YAAY,CAAZA,GAAAA,CAAJ,GAAIA,CAAJ,EAA2B;AAEzB,WAAOA,YAAY,CAAZA,GAAAA,CAAP,GAAOA,CAAP;AACD;;AACD,MAAI,OAAA,KAAA,KAAJ,QAAA,EAA+B;AAC7B,WAAA,KAAA;AACD;;AACD,MAAI,OAAA,KAAA,KAAA,QAAA,IAA6B,SAAA,IAAA,CAAjC,KAAiC,CAAjC,EAAuD;AACrD,WAAOP,IAAI,CAAJA,KAAAA,CAAWV,aAAa,GAAGkB,QAAQ,CAAA,KAAA,EAAxBlB,EAAwB,CAAxBA,GAAlB,GAAOU,CAAP;AACD;;AACD,SAAA,SAAA;AACD;;AAED,SAAA,gBAAA,CAAA,KAAA,EAEE;AAAA,EAAA,QAAA;AAAYjD,EAAAA;AAAZ,CAFF,EAAA,cAAA,EAIU;AACRD,EAAAA,KAAK,GAAGkD,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,EAAgBS,QAAhBT,IAAAA,IAAgBS,GAAhBT,QAAgBS,GAAxB3D,cAAQkD,CAARlD;;AAEA,MAAI,OAAA,QAAA,KAAJ,QAAA,EAAkC;AAChC,WAAOkD,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,EAAP,QAAOA,CAAP;AACD;;AAED,SAAA,KAAA;AACD;;ACrPD,MAAMU,kBAAkB,GAAxB,CAAA;;AAaA,SAAA,eAAA,CAAA,GAAA,EAAkE;AAChE,SAAOC,KAAK,CAALA,OAAAA,CAAP,GAAOA,CAAP;AACD;;AAEM,SAAA,eAAA,CAA4B;AAAA,EAAA,OAAA;AAAA,EAAA,SAAA;AAAA,EAAA,YAAA;AAAA,EAAA,SAAA;AAAA,EAAA,OAAA;AAAA,EAAA,UAAA;AAOjCC,EAAAA;AAPiC,CAA5B,EAQiB;AACtB,QAAM,CAAA,WAAA,EAAA,SAAA,IAA2B5C,OAAO,CAAC,MAAM;AAC7C,QAAID,OAAO,CAAPA,MAAAA,KAAAA,CAAAA,IAAwB,CAA5B,UAAA,EAAyC,OAAO,CAAA,SAAA,EAAY8C,OAAO,CAA1B,MAAO,CAAP;;AAEzC,UAAMC,SAAS,GAAG,CAAA,IAAA,EAAqB,CAAA,UAAA,EAAa,GAAlC,oBAAqB,CAArB,EAAA,aAAA,KAAyI;AACzJ,UAAIC,cAAc,GAAlB,CAAA;AACA,YAAMC,MAA4B,GAAlC,EAAA;;AACA,WAAK,MAAM,CAAA,GAAA,EAAX,SAAW,CAAX,IAA+BC,MAAM,CAANA,OAAAA,CAAeC,UAAU,CAAA,IAAA,EAAxD,UAAwD,CAAzBD,CAA/B,EAA6E;AAE3E,cAAM,CAAA,WAAA,EAAA,cAAA,IAAgCE,oBAAoB,CAApBA,MAAAA,KAAAA,CAAAA,GAClC,CAAA,SAAA,EAAYC,SAAS,CADaD,MAClC,CADkCA,GAElCL,SAAS,CAAA,SAAA,EAAA,oBAAA,EAAkCO,aAAa,GAAbA,cAAAA,GAF/C,CAEa,CAFb;AAGAL,QAAAA,MAAM,CAANA,GAAM,CAANA,GAAc;AAAA,UAAA,SAAA;AAAA,UAAA,WAAA;AAA0BK,UAAAA,aAAa,EAAEA,aAAa,GAAGN;AAAzD,SAAdC;AACAD,QAAAA,cAAc,IAAIO,cAAc,GAAhCP,CAAAA;AACD;;AAED,aAAO,CAAA,MAAA,EAAP,cAAO,CAAP;AAZF,KAAA;;AAeA,WAAOD,SAAS,CAAA,OAAA,EAAA,OAAA,EAAhB,CAAgB,CAAhB;AAlBsC,GAAA,EAmBrC,CAAA,OAAA,EAAA,UAAA,EAnBH,OAmBG,CAnBqC,CAAxC;AAqBA,QAAM,CAAA,IAAA,EAAA,YAAA,IAAuB9C,OAAO,CAAC,MAAM;AACzC,UAAMuD,YAAY,GAAG,IAArB,GAAqB,EAArB;AACA,QAAI,CAAJ,WAAA,EAAkB,OAAO,CAAA,OAAA,EAAP,YAAO,CAAP;AAElB,UAAMC,aAAqC,GAA3C,EAAA;;AACA,UAAMC,WAAW,GAAG,CAAA,IAAA,EAAA,QAAA,EAAA,KAAA,KAAkG;AACpH,UAAIC,eAAe,CAAnB,IAAmB,CAAnB,EAA2B;AACzBF,QAAAA,aAAa,CAAbA,IAAAA,CAAmB,GAAnBA,IAAAA;AACA;AACD;;AACDP,MAAAA,MAAM,CAANA,IAAAA,CAAAA,IAAAA,EAAAA,OAAAA,CAA0B,CAAA,QAAA,EAAA,QAAA,EAAA,IAAA,KAA8B;AAAA,YAAA,qBAAA;;AAEtD,cAAMU,EAAE,GAAGC,QAAQ,KAARA,SAAAA,GAA0B,GAAEA,QAAS,KAAIC,QAAzCD,EAAAA,GAAX,QAAA;AACA,cAAMnF,UAAU,GAAA,CAAA,qBAAA,GAAGmE,gBAAH,IAAA,IAAGA,GAAH,KAAA,CAAGA,GAAAA,gBAAgB,CAAhBA,GAAAA,CAAH,EAAGA,CAAH,KAAA,IAAA,GAAA,qBAAA,GAAhB,KAAA;AACA,cAAM;AAAA,UAAA,SAAA;AAAA,UAAA,WAAA;AAA0BS,UAAAA;AAA1B,YAA4CS,IAAI,CAAtD,QAAsD,CAAtD;AAEA,cAAMlJ,QAAqB,GAAG;AAAA,UAAA,EAAA;AAAA,UAAA,QAAA;AAAA,UAAA,QAAA;AAAA,UAAA,UAAA;AAAA,UAAA,SAAA;AAAA,UAAA,KAAA;AAAA,UAAA,QAAA;AAAA,UAAA,aAAA;AAS5BmJ,UAAAA,OAAO,EAAEC,IAAI,CAACC;AATc,SAA9B;AAWAT,QAAAA,aAAa,CAAbA,IAAAA,CAAAA,QAAAA;AACAD,QAAAA,YAAY,CAAZA,GAAAA,CAAAA,QAAAA;;AAEA,YAAA,UAAA,EAAgB;AACdE,UAAAA,WAAW,CAAA,WAAA,EAAA,EAAA,EAAkBS,KAAK,GAAlCT,CAAW,CAAXA;AACD;AAtBHR,OAAAA;AALF,KAAA;;AA+BAQ,IAAAA,WAAW,CAAA,WAAA,EAAA,SAAA,EAAXA,CAAW,CAAXA;AACA,WAAO,CAAA,aAAA,EAAP,YAAO,CAAP;AArCkC,GAAA,EAsCjC,CAAA,gBAAA,EAAA,WAAA,EAtCH,OAsCG,CAtCiC,CAApC;;AAwCA,QAAMU,UAAU,GAAO9I,GAAJ,IAAyCkI,YAAY,CAAZA,GAAAA,CAA5D,GAA4DA,CAA5D;;AAEA,QAAMa,iBAAiB,GAAvB,CAAA;AACA,QAAMC,kBAAkB,GAAGrC,IAAI,CAAJA,KAAAA,CAAWsC,SAAS,GAA/C,SAA2BtC,CAA3B;AACA,QAAMuC,gBAAgB,GAAGvC,IAAI,CAAJA,GAAAA,CAAS8B,IAAI,CAAJA,MAAAA,GAAT9B,CAAAA,EAA0BA,IAAI,CAAJA,KAAAA,CAAW,CAACsC,SAAS,GAAV,YAAA,IAA9D,SAAmDtC,CAA1BA,CAAzB;AACA,QAAMwC,mBAAmB,GAAGxC,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAYA,IAAI,CAAJA,KAAAA,CAAW,CAACqC,kBAAkB,GAAnB,iBAAA,IAAXrC,kBAAAA,IAAxC,kBAA4BA,CAA5B;AACA,QAAMyC,iBAAiB,GAAGzC,IAAI,CAAJA,GAAAA,CAAS8B,IAAI,CAAJA,MAAAA,GAAT9B,CAAAA,EAA0BA,IAAI,CAAJA,IAAAA,CAAU,CAACuC,gBAAgB,GAAjB,iBAAA,IAAVvC,kBAAAA,IAApD,kBAA0BA,CAA1B;AAEA,SAAO;AAAA,IAAA,mBAAA;AAAA,IAAA,iBAAA;AAAA,IAAA,IAAA;AAAA,IAAA,SAAA;AAKLmC,IAAAA;AALK,GAAP;AAOD;;ACrGM,SAAA,aAAA,CAAA,EAAA,EAAiE;AACtE,QAAMvH,GAAG,GAAGhB,MAAM,CAAlB,EAAkB,CAAlB;AAEAG,EAAAA,SAAS,CAAC,MAAM;AACda,IAAAA,GAAG,CAAHA,OAAAA,GAAAA,EAAAA;AADFb,GAAS,CAATA;AAIA,SAAO2I,WAAW,CAAC,CAAC,GAAD,IAAA,KAA4B;AAC7C9H,IAAAA,GAAG,CAAHA,OAAAA,CAAY,GAAZA,IAAAA;AADgB,GAAA,EAAlB,EAAkB,CAAlB;AAGD;;;;ACVD,MAAM+H,cAAc,GAApB,sBAAA;AAKA,MAAMC,uBAAuB,GAAA,wBAA2BD,cAAxD,EAAA;AAEA,MAAME,cAAc,GAApB,qBAAA;AAOA,MAAMC,uBAAuB,GAAA,wBAA2BD,cAAxD,EAAA;;AAae,SAAA,kBAAA,CAAmC;AAAA,EAAA,MAAA;AAAA,EAAA,MAAA;AAAA,EAAA,UAAA;AAAA,EAAA,aAAA;AAKhDE,EAAAA;AALgD,CAAnC,EAME;AACfC,EAAAA,aAAa,GAAGC,UAAU,KAAK5E,MAAM,CAArB4E,GAAAA,IAAAA,aAAAA,IAAhBD,MAAAA;MACIE,QAAQ,GAAG,E;;MACXF,aAAa,KAAK,K,EAAO;AAC3BE,IAAAA,QAAQ,GAARA,QAAAA;AADF,G,MAEO,IAAIF,aAAa,KAAjB,MAAA,EAA8B;AACnCE,IAAAA,QAAQ,GAARA,QAAAA;;;WAGOpH,O,GAAU;QACb,CAACqH,M,EAAQ;UACP;AAAEC,MAAAA;AAAF,QAA0B/E,M;QAC5BgF,S;;YACIL,a;WACD,K;AACHK,QAAAA,SAAS,GAAGD,mBAAmB,GAAA,MAAA,GAA/BC,MAAAA;;;WAEG,M;AACHA,QAAAA,SAAS,GAAGD,mBAAmB,GAAA,KAAA,GAA/BC,MAAAA;;;;AAGAA,QAAAA,SAAS,GAAGD,mBAAmB,GAAA,MAAA,GAA/BC,KAAAA;;;;AAGJF,IAAAA,MAAM,CAAC9E,MAAM,CAAP,GAAA,EAAN8E,SAAM,CAANA;;;sBAIA,IAAA,CAAA,MAAA,EAAA;AAAM,IAAA,SAAA,EAAN,uBAAA;AAA0C,IAAA,OAAA,EAA1C,OAAA;AAAA,IAAA,QAAA,EAAA,CAAA,aACE,GAAA,CAAA,MAAA,EAAA;AAAM,MAAA,SAAA,EAAN,uBAAA;AAAA,MAAA,QAAA,EAA2CJ;AAA3C,KAAA,CADF,EAAA,aAEE,GAAA,CAAA,MAAA,EAAA;AAAA,MAAA,QAAA,EAAOG;AAAP,KAAA,CAFF;AAAA,GAAA,C;;;AChEJ,MAAMI,YAAY,GAAG,IAAA,GAAA,CAAQ,CAAA,cAAA,EAAA,KAAA,EAAA,UAAA,EAAA,UAAA,EAAA,SAAA,EAAA,IAAA,EAAA,QAAA,EAAA,MAAA,EAAA,SAAA,EAAA,YAAA,EAAA,OAAA,EAAA,KAAA,EAAA,WAAA,EAAA,WAAA,EAAA,YAAA,EAAA,SAAA,EAAA,KAAA,EAAA,MAAA,EAAA,UAAA,EAAA,QAAA,EAAA,QAAA,EAAA,aAAA,EAAA,QAAA,EAAA,OAAA,EAAA,MAAA,EAAA,aAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,KAAA,EAAA,KAAA,EAA7B,KAA6B,CAAR,CAArB;;AAiDO,SAAA,iBAAA,CAAA,CAAA,EAA4D;AACjE,SAAO,CAAC5H,CAAC,CAADA,OAAAA,IAAaA,CAAC,CAAf,OAAA,KAA4BA,CAAC,CAADA,GAAAA,KAAnC,SAAA;AACD;;AAEM,SAAA,kBAAA,CAAA,KAAA,EAAiF;AACtF,SAAO,CAAC4H,YAAY,CAAZA,GAAAA,CAAiB5G,KAAK,CAA9B,GAAQ4G,CAAR;AACD;;AAQM,SAAA,kBAAA,CAA4B;AAAA,EAAA,GAAA;AAAOC,EAAAA;AAAP,CAA5B,EAA2F;AAChG,MAAIhH,GAAG,KAAHA,KAAAA,KAAkBgH,MAAM,YAANA,gBAAAA,IAAsCA,MAAM,YAA5CA,mBAAAA,IAA+EA,MAAM,YAA3G,iBAAIhH,CAAJ,EAA2I;AACzI,WAAOgH,MAAM,CAANA,OAAAA,CAAP,6FAAOA,CAAP;AACD;;AACD,SAAA,KAAA;AACD;;AC5DM,SAAA,sBAAA,CAAuC;AAAA,EAAA,gBAAA;AAAA,EAAA,OAAA;AAAA,EAAA,IAAA;AAAmCpB,EAAAA;AAAnC,CAAvC,EAAoI;AACzI,QAAM9D,MAAM,GAAGH,OAAO,CAACsF,gBAAgB,CAAvC,GAAsB,CAAtB;AACA,QAAMnK,GAAG,GAAGyI,IAAI,CAAC0B,gBAAgB,CAAjC,MAAgB,CAAhB;AACA,SAAOnF,MAAM,CAANA,MAAAA,IAAAA,IAAAA,IACF,CAACA,MAAM,CADLA,QAAAA,IAEF,CAAC8D,UAAU,CAFT9D,GAES,CAFTA,IAGF,CAAC,OAAOA,MAAM,CAAb,QAAA,KAAA,UAAA,GAAwCA,MAAM,CAANA,QAAAA,CAAxC,GAAwCA,CAAxC,GAA+DA,MAAM,CAAtE,QAAA,MAHL,KAAA;AAID;;AASM,SAAA,2BAAA,CAA4C;AAAA,EAAA,kBAAA;AAAA,EAAA,OAAA;AAAA,EAAA,SAAA;AAA0CoF,EAAAA;AAA1C,CAA5C,EAAwJ;AAC7J,MAAIC,kBAAkB,KAAtB,MAAA,EAAmC;AACjC,UAAM;AAAA,MAAA,GAAA;AAAOC,MAAAA;AAAP,QAAN,YAAA;AACA,UAAMC,YAAY,GAAG1F,OAAO,CAA5B,MAAA;AACA,UAAM2F,iBAAiB,GAAGvF,GAAG,KAA7B,YAAA;AACA,UAAMwF,mBAAmB,GAAGxF,GAAG,KAAK,CAApC,CAAA;;AAEA,QAAA,iBAAA,EAAuB;AACrB,UAAIoF,kBAAkB,KAAtB,YAAA,EAAyC;AACvC,cAAMK,SAAS,GAAGJ,MAAM,KAAKK,SAAS,GAAtC,CAAA;;AACA,YAAI,CAAJ,SAAA,EAAgB;AACd,iBAAO;AACL1F,YAAAA,GAAG,EADE,CAAA;AAELqF,YAAAA,MAAM,EAAEA,MAAM,GAAG;AAFZ,WAAP;AAID;AAPH,OAAA,MAQO;AACL,eAAO;AAAA,UAAA,MAAA;AAELrF,UAAAA,GAAG,EAAE;AAFA,SAAP;AAID;AAdH,KAAA,MAeO,IAAA,mBAAA,EAAyB;AAC9B,UAAIoF,kBAAkB,KAAtB,YAAA,EAAyC;AACvC,cAAMO,UAAU,GAAGN,MAAM,KAAzB,CAAA;;AACA,YAAI,CAAJ,UAAA,EAAiB;AACf,iBAAO;AACLA,YAAAA,MAAM,EAAEA,MAAM,GADT,CAAA;AAELrF,YAAAA,GAAG,EAAEsF,YAAY,GAAG;AAFf,WAAP;AAID;AAPH,OAAA,MAQO;AACL,eAAO;AAAA,UAAA,MAAA;AAELtF,UAAAA,GAAG,EAAEsF,YAAY,GAAG;AAFf,SAAP;AAID;AACF;AACF;;AAED,SAAA,YAAA;AACD;;AAUM,SAAA,WAAA,CAA4B;AAAA,EAAA,kBAAA;AAAA,EAAA,OAAA;AAAA,EAAA,SAAA;AAA0CJ,EAAAA,gBAAgB,EAAE;AAAA,IAAA,MAAA;AAAUlF,IAAAA;AAAV,GAA5D;AAA6E4F,EAAAA;AAA7E,CAA5B,EAAsJ;AAG3J,MAAIR,kBAAkB,KAAlBA,MAAAA,IAAiCA,kBAAkB,KAAvD,YAAA,EAA0E;AACxE,UAAMS,eAAe,GAAG7F,GAAG,KAAKJ,OAAO,CAAPA,MAAAA,GAAhC,CAAA;AACA,UAAMkG,gBAAgB,GAAG9F,GAAG,KAA5B,CAAA;AACA,UAAM+F,SAAS,GAAGV,MAAM,KAAKK,SAAS,GAAtC,CAAA;AACA,UAAMM,UAAU,GAAGX,MAAM,KAAzB,CAAA;AAEA,WAAOO,QAAQ,GAAGE,gBAAgB,IAAnB,UAAA,GAAoCD,eAAe,IAAlE,SAAA;AACD;;AAED,SAAA,KAAA;AACD;;AChFM,SAAA,sBAAA,CAAA,SAAA,EAAmG;AACxG,MAAI,OAAA,SAAA,KAAJ,UAAA,EAAqC;AACnC,UAAM,IAAA,KAAA,CAAN,uDAAM,CAAN;AACD;AACF;;AAEM,SAAA,YAAA,CAAA,MAAA,EAAmF;AACxF,SAAO,MAAM,CAAN,MAAA,GACH;AAAEtF,IAAAA,IAAI,EAAG,qBAAoBR,MAAM,CAAC9B,GAAI;AAAxC,GADG,GAEH;AAAEgI,IAAAA,eAAe,EAAElG,MAAM,CAANA,GAAAA,GAAa;AAAhC,GAFJ;AAGD;;AAEM,SAAA,gBAAA,CAAA,MAAA,EAAkE,GAAlE,YAAA,EAAoH;AACzH,SAAOzC,IAAI,CAAA,aAAA,EAKT,GALS,YAAA,EAEgByC,MAAM,CAFtB,MAEgBA,IAFhB,mBAAA,EAGoBA,MAAM,CAH1B,kBAGoBA,IAH/B,uBAAW,CAAX;AAOD;;;;ACtBD,MAAMmG,aAAa,GAAnB,qBAAA;AAYA,MAAMC,sBAAsB,GAAA,sBAAyBD,aAArD,EAAA;;AAEA,SAAA,WAAA,CAAA,aAAA,EAAoD;UAC1CxB,a;SACD,K;aACI,W;;SACJ,M;aACI,Y;;;aAEA,M;;;;AAiBE,SAAA,UAAA,CAA2B;AAAA,EAAA,MAAA;AAAA,EAAA,QAAA;AAAA,EAAA,eAAA;AAAA,EAAA,wBAAA;AAAA,EAAA,UAAA;AAAA,EAAA,aAAA;AAOxCG,EAAAA;AAPwC,CAA3B,EAQY;WAChBuB,a,CAAchI,K,EAA2C;QAC5DA,KAAK,CAALA,WAAAA,KAAAA,OAAAA,IAAiCA,KAAK,CAALA,OAAAA,KAAkB,C,EAAG;;;;UAIpD;AAAA,MAAA,aAAA;AAAiBiI,MAAAA;AAAjB,QAA+BjI,K;UAC/B;AAAEkI,MAAAA;AAAF,QAAYC,aAAa,CAAbA,qBAAAA,E;UACZC,MAAM,GAAGF,KAAK,GAAGlI,KAAK,CAACqI,O;;QAEzBD,MAAM,GAAG,E,EAAI;;;;aAIRE,a,CAActI,K,EAAqB;UACtCA,KAAK,CAALA,SAAAA,KAAoBiI,S,EAAW;;UAC/BjI,KAAK,CAALA,WAAAA,KAAAA,OAAAA,IAAiCA,KAAK,CAALA,OAAAA,KAAkB,C,EAAG;AACxDuI,QAAAA,WAAW;;;;YAGPnI,KAAK,GAAGJ,KAAK,CAALA,OAAAA,GAAAA,MAAAA,GAAyBmI,aAAa,CAAbA,qBAAAA,GAAsChG,I;;UACzE/B,KAAK,GAAG,C,EAAG;AACboI,QAAAA,QAAQ,CAAA,MAAA,EAARA,KAAQ,CAARA;;;;aAIKD,W,GAAc;UACjBvI,KAAK,CAALA,SAAAA,KAAoBiI,S,EAAW;AACnCzK,MAAAA,MAAM,CAANA,mBAAAA,CAAAA,aAAAA,EAAAA,aAAAA;AACAA,MAAAA,MAAM,CAANA,mBAAAA,CAAAA,WAAAA,EAAAA,WAAAA;;;AAGFwC,IAAAA,KAAK,CAALA,cAAAA;AACAxC,IAAAA,MAAM,CAANA,gBAAAA,CAAAA,aAAAA,EAAAA,aAAAA;AACAA,IAAAA,MAAM,CAANA,gBAAAA,CAAAA,WAAAA,EAAAA,WAAAA;;;WAGOiL,O,GAAU;QACb9G,MAAM,CAAClB,c,EAAgB;0BAEvB,GAAA,CAAC,MAAD,CAAA,cAAA,EAAA;AACE,QAAA,MAAA,EADF,MAAA;AAEE,QAAA,UAAA,EAFF,UAAA;AAGE,QAAA,aAAA,EAHF,aAAA;AAIE,QAAA,MAAA,EAJF,MAAA;AAKE,QAAA,eAAA,EALF,eAAA;AAME,QAAA,wBAAA,EAA0BC;AAN5B,OAAA,C;;;QAWAiB,MAAM,CAACpB,Q,EAAU;0BAEjB,GAAA,CAAA,kBAAA,EAAA;AACE,QAAA,MAAA,EADF,MAAA;AAEE,QAAA,MAAA,EAFF,MAAA;AAGE,QAAA,UAAA,EAHF,UAAA;AAIE,QAAA,aAAA,EAJF,aAAA;AAAA,QAAA,QAAA,EAMGoB,MAAM,CAACxB;AANV,OAAA,C;;;WAWGwB,MAAM,CAACxB,I;;;QAGVuI,SAAS,GAAGC,gBAAgB,CAAA,MAAA,EAAShH,MAAM,CAAf,eAAA,EACNA,MAAM,CADA,SACNA,IADM,sBAAA,C;sBAKhC,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAA,EADF,cAAA;AAEE,qBAAeA,MAAM,CAANA,GAAAA,GAFjB,CAAA;AAGE,iBAAW4E,UAAU,KAAK5E,MAAM,CAArB4E,GAAAA,GAA4BqC,WAAW,CAAvCrC,aAAuC,CAAvCA,GAHb,SAAA;AAIE,IAAA,SAAA,EAJF,SAAA;AAKE,IAAA,KAAA,EAAOsC,YAAY,CALrB,MAKqB,CALrB;AAME,IAAA,aAAA,EAAelH,MAAM,CAANA,SAAAA,GAAAA,aAAAA,GANjB,SAAA;AAAA,IAAA,QAAA,EAQG8G,OAAO;AARV,GAAA,C;;;ACtGJ,SAAA,SAAA,CAA0B;AAAA,EAAA,OAAA;AAAA,EAAA,IAAA;AAAA,EAAA,YAAA;AAAA,EAAA,oBAAA;AAAA,EAAA,eAAA;AAAA,EAAA,cAAA;AAAA,EAAA,UAAA;AAAA,EAAA,aAAA;AASxBhC,EAAAA;AATwB,CAA1B,EAU0B;AACxB,QAAMqC,4BAA4B,GAAG9C,WAAW,CAAE+C,OAAD,IAAsB;AACrE,QAAI,CAAJ,oBAAA,EAA2B;AAE3BC,IAAAA,sBAAsB,CAAtBA,YAAsB,CAAtBA;AAEA,UAAMC,eAAe,GAAG,IAAA,GAAA,CAAmBF,OAAO,GAAG3D,IAAI,CAAJA,GAAAA,CAAH,YAAGA,CAAH,GAAlD,SAAwB,CAAxB;AACA8D,IAAAA,oBAAoB,CAApBA,eAAoB,CAApBA;AAN8C,GAAA,EAO7C,CAAA,oBAAA,EAAA,IAAA,EAPH,YAOG,CAP6C,CAAhD;AASA,SAAA,aACE,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAI,EADN,KAAA;AAEE,qBAFF,CAAA;AAGE,IAAA,SAAS,EAHX,kBAAA;AAAA,IAAA,QAAA,EAKG,OAAO,CAAP,GAAA,CAAYvH,MAAM,IAAI;AACrB,aAAA,aACE,GAAA,CAAA,UAAA,EAAA;AAEE,QAAA,MAAM,EAFR,MAAA;AAGE,QAAA,QAAQ,EAHV,cAAA;AAIE,QAAA,eAAe,EAJjB,eAAA;AAKE,QAAA,wBAAwB,EAL1B,4BAAA;AAME,QAAA,MAAM,EANR,MAAA;AAOE,QAAA,UAAU,EAPZ,UAAA;AAQE,QAAA,aAAa,EAAE2E;AARjB,OAAA,EACO3E,MAAM,CAFf,GACE,CADF;AADD,KAAA;AALH,GAAA,CADF;AAsBD;;AAED,MAAA,WAAA,GAAA,aAAewH,IAAI,CAAnB,SAAmB,CAAnB;;ACnDA,SAAA,SAAA,CAA0B;AAAA,EAAA,OAAA;AAAA,EAAA,OAAA;AAGxBC,EAAAA;AAHwB,CAA1B,EAI0B;AACxB,WAAA,QAAA,CAAA,GAAA,EAAA,KAAA,EAA+C;AAC7C,UAAMC,UAAmB,GAAG,EAAE,GAAGC;AAAL,KAA5B;AACAD,IAAAA,UAAU,CAAVA,GAAU,CAAVA,GAAAA,KAAAA;AACAD,IAAAA,eAAe,IAAfA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,eAAe,CAAfA,UAAe,CAAfA;AACD;;AAED,SAAA,aACE,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAI,EADN,KAAA;AAEE,qBAFF,CAAA;AAGE,IAAA,SAAS,EAHX,kBAAA;AAAA,IAAA,QAAA,EAKG,OAAO,CAAP,GAAA,CAAYzH,MAAM,IAAI;AACrB,YAAM;AAAE9B,QAAAA;AAAF,UAAN,MAAA;AAEA,aAAA,aACE,GAAA,CAAA,KAAA,EAAA;AAEE,QAAA,SAAS,EAAE8I,gBAAgB,CAF7B,MAE6B,CAF7B;AAGE,QAAA,KAAK,EAAEE,YAAY,CAHrB,MAGqB,CAHrB;AAAA,QAAA,QAAA,EAKGlH,MAAM,CAANA,cAAAA,IAAAA,aACC,GAAA,CAAC,MAAD,CAAA,cAAA,EAAA;AACE,UAAA,MAAM,EADR,MAAA;AAEE,UAAA,KAAK,EAAE2H,OAAF,IAAA,IAAEA,GAAF,KAAA,CAAEA,GAAAA,OAAO,CAAG3H,MAAM,CAFzB,GAEgB,CAFhB;AAGE,UAAA,QAAQ,EAAE4H,KAAK,IAAItK,QAAQ,CAAA,GAAA,EAAA,KAAA;AAH7B,SAAA;AANJ,OAAA,EADF,GACE,CADF;AAHD,KAAA;AALH,GAAA,CADF;AA2BD;;AAED,MAAA,WAAA,GAAA,aAAekK,IAAI,CAAnB,SAAmB,CAAnB;;;AChDA,MAAMK,UAAU,GAAhB,qBAAA;AAIA,MAAMC,mBAAmB,GAAA,mBAAsBD,UAA/C,EAAA;AAEA,MAAME,eAAe,GAArB,sBAAA;AAQA,MAAMC,wBAAwB,GAAA,yBAA4BD,eAA1D,EAAA;AAEA,MAAME,cAAc,GAApB,sBAAA;AAiBA,MAAMC,uBAAuB,GAAA,wBAA2BD,cAAxD,EAAA;;AAEA,SAAA,IAAA,CAAqB;AAAA,EAAA,SAAA;AAAA,EAAA,MAAA;AAAA,EAAA,cAAA;AAAA,EAAA,QAAA;AAAA,EAAA,aAAA;AAAA,EAAA,aAAA;AAAA,EAAA,GAAA;AAAA,EAAA,MAAA;AAAA,EAAA,eAAA;AAAA,EAAA,UAAA;AAAA,EAAA,OAAA;AAAA,EAAA,aAAA;AAAA,EAAA,aAAA;AAAA,EAAA,WAAA;AAAA,EAAA,UAAA;AAAA,EAAA,SAAA;KAiBhBvK;AAjBgB,CAArB,EAAA,GAAA,EAkB6D;QACrD;AAAEyK,IAAAA;AAAF,MAAgBnI,M;AACtB+G,EAAAA,SAAS,GAAGC,gBAAgB,CAAA,MAAA,EAO1B,OAAA,SAAA,KAAA,UAAA,GAAkCmB,SAAS,CAA3C,GAA2C,CAA3C,GAP0B,SAAA,EAAA,SAAA,EAGCC,cAHD,IAAA,qBAAA,EAIDC,QAJC,IAAA,mBAAA,EAKIC,aALJ,IAA5BvB,wBAA4B,CAA5BA;;WAWSwB,iB,CAAkBC,U,EAAsB;AAC/CC,IAAAA,UAAU,CAAC;AAAExI,MAAAA,GAAG,EAAED,MAAM,CAAb,GAAA;AAAmBsF,MAAAA;AAAnB,KAAD,EAAVmD,UAAU,CAAVA;;;WAGOC,W,CAAYrK,K,EAAyC;AAAA,QAAA,qBAAA;;AAC5DkK,IAAAA,iBAAiB,CAAA,CAAA,qBAAA,GAACvI,MAAM,CAAP,aAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAACA,qBAAAA,CAAlBuI,WAAiB,CAAjBA;AACAI,IAAAA,UAAU,IAAVA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,UAAU,CAAA,MAAA,EAAA,GAAA,EAAVA,MAAU,CAAVA;AACAlL,IAAAA,OAAO,IAAPA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAPA,KAAO,CAAPA;;;WAGOmL,iB,CAAkBvK,K,EAAyC;AAClEkK,IAAAA,iBAAiB;AACjBM,IAAAA,aAAa,IAAbA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,aAAa,CAAbA,KAAa,CAAbA;;;WAGOC,iB,CAAkBzK,K,EAAyC;AAClEkK,IAAAA,iBAAiB,CAAjBA,IAAiB,CAAjBA;AACAQ,IAAAA,aAAa,IAAbA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,aAAa,CAAbA,KAAa,CAAbA;;;WAGOC,e,CAAgBC,M,EAAW;AAClCC,IAAAA,WAAW,CAAA,MAAA,EAAXA,MAAW,CAAXA;;;WAGOjK,oB,CAAqBmI,O,EAAkB+B,Y,EAAuB;AACrEC,IAAAA,SAAS,CAAC;AAAA,MAAA,MAAA;AAAA,MAAA,OAAA;AAAmBD,MAAAA;AAAnB,KAAD,CAATC;;;sBAIA,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAA,EADF,UAAA;AAEE,qBAAepJ,MAAM,CAANA,GAAAA,GAFjB,CAAA;qBAAA,cAAA;AAIE,IAAA,GAAA,EAJF,GAAA;AAKE,IAAA,SAAA,EALF,SAAA;AAME,IAAA,KAAA,EAAOkH,YAAY,CANrB,MAMqB,CANrB;AAOE,IAAA,OAAA,EAPF,WAAA;AAQE,IAAA,aAAA,EARF,iBAAA;AASE,IAAA,aAAA,EATF,iBAAA;AAAA,OAAA,KAAA;AAAA,IAAA,QAAA,EAYG,CAAClH,MAAM,CAAP,QAAA,IAAA,aACC,IAAA,CAAA,QAAA,EAAA;AAAA,MAAA,QAAA,EAAA,CAAA,aACE,GAAA,CAAC,MAAD,CAAA,SAAA,EAAA;AACE,QAAA,MAAA,EADF,MAAA;AAEE,QAAA,MAAA,EAFF,MAAA;AAGE,QAAA,GAAA,EAHF,GAAA;AAIE,QAAA,cAAA,EAJF,cAAA;AAKE,QAAA,aAAA,EALF,aAAA;AAME,QAAA,oBAAA,EANF,oBAAA;AAOE,QAAA,WAAA,EAAagJ;AAPf,OAAA,CADF,EAUGK,eAAe,IAAA,aACd,GAAA,CAAA,KAAA,EAAA;AAAK,QAAA,SAAA,EAAL,uBAAA;AAAA,WAA6CA;AAA7C,OAAA,CAXJ;AAAA,KAAA;AAbJ,GAAA,C;;;AAgCJ,MAAA,MAAA,GAAA,aAAe7B,IAAI,EAAA,aAAC8B,UAAU,CAA9B,IAA8B,CAAX,CAAnB;;;ACjIA,MAAMC,eAAe,GAArB,qBAAA;AAIA,MAAMC,wBAAwB,GAAA,wBAA2BD,eAAzD,EAAA;;AAEe,SAAA,eAAA,CAAgC;AAAA,EAAA,GAAA;AAAA,EAAA,MAAA;AAAA,EAAA,WAAA;KAI1C7L;AAJ0C,CAAhC,EAKQ;AAAA,MAAA,qBAAA;;QACf+L,cAAc,GAAGC,eAAe,CAAC,MAAMR,WAAW,CAAA,GAAA,EAAlB,IAAkB,CAAlB,C;MAClClJ,MAAM,CAANA,MAAAA,KAAkB2J,S,EAAW,OAAA,IAAA;QAE3BC,MAAM,GAAA,aACV,GAAA,CAAA,KAAA,EAAA;AAAK,IAAA,SAAA,EAAL,wBAAA;AAA0C,IAAA,cAAA,EAA1C,cAAA;AAAA,IAAA,QAAA,EAAA,aACE,GAAA,CAAC,MAAD,CAAA,MAAA,EAAA;AACE,MAAA,GAAA,EADF,GAAA;AAEE,MAAA,MAAA,EAFF,MAAA;AAGE,MAAA,WAAA,EAHF,WAAA;AAAA,SAIMlM;AAJN,KAAA;AADF,GAAA,C;;+BAUEsC,MAAM,CAAC6J,a,KAAAA,I,IAAP7J,qBAAAA,CAAsB8J,Y,EAAc;wBAC/BA,YAAY,CAAA,MAAA,EAASpM,KAAK,CAAd,kBAAA,C;;;SAGdkM,M;;;;;AC5BT,MAAMG,WAAW,GAAjB,sBAAA;AAIA,MAAMC,oBAAoB,GAAA,oBAAuBD,WAAjD,EAAA;;AAYe,SAAA,QAAA,CAAyB;AAAA,EAAA,SAAA;AAAA,EAAA,MAAA;AAAA,EAAA,GAAA;AAAA,EAAA,MAAA;AAAA,EAAA,WAAA;KAMnCrM;AANmC,CAAzB,EAOU;QACjB,CAAA,UAAA,EAAA,aAAA,IAA8B1B,QAAQ,CAAA,IAAA,C;QAEtCgC,OAAO,GAAGqG,WAAW,CAAC4F,IAAI,IAAI;QAC9BA,IAAI,KAAK,I,EAAM;YACX;AAAA,QAAA,IAAA;AAAQC,QAAAA;AAAR,UAAgBD,IAAI,CAAJA,qBAAAA,E;AACtBE,MAAAA,aAAa,CAAC;AAAA,QAAA,IAAA;AAAQD,QAAAA;AAAR,OAAD,CAAbC;;AAHuB,GAAA,EAAA,EAAA,C;QAOrB;AAAEhC,IAAAA;AAAF,MAAgBnI,M;AACtB+G,EAAAA,SAAS,GAAGC,gBAAgB,CAAA,MAAA,EAAA,qBAAA,EAAA,oBAAA,EAI1B,OAAA,SAAA,KAAA,UAAA,GAAkCmB,SAAS,CAA3C,GAA2C,CAA3C,GAJ0B,SAAA,EAA5BpB,SAA4B,CAA5BA;;WAQSqD,c,GAAiB;AAAA,QAAA,qBAAA;;QACpBC,UAAU,KAAK,I,EAAM;UACnB;AAAEpG,MAAAA,SAAS,EAAX,MAAA;AAAqB1C,MAAAA,UAAU,EAAE+I;AAAjC,QAAA,CAAA,qBAAA,GAA6CC,QAAQ,CAArD,gBAAA,KAAA,IAAA,GAAA,qBAAA,GAA0EA,QAAQ,CAACC,e;UACnF;AAAA,MAAA,IAAA;AAAQN,MAAAA;AAAR,QAAgBG,U;UAChBI,QAAQ,GAAGjK,IAAI,GAAG8J,O;UAClBI,OAAO,GAAGR,GAAG,GAAGS,M;wBAGpB,GAAA,CAAA,eAAA,EAAA,EAAA,GAAA,WAAA;AAEE,MAAA,MAAA,EAFF,MAAA;AAGE,MAAA,MAAA,EAHF,MAAA;AAIE,MAAA,IAAA,EAJF,QAAA;AAKE,MAAA,GAAA,EAAKD;AALP,KAAA,C;;;sBAWF,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAA,EADF,UAAA;AAEE,qBAAe1K,MAAM,CAANA,GAAAA,GAFjB,CAAA;qBAAA,IAAA;AAIE,IAAA,GAAA,EAJF,OAAA;AAKE,IAAA,SAAA,EALF,SAAA;AAME,IAAA,KAAA,EAAOkH,YAAY,CANrB,MAMqB,CANrB;AAAA,OAAA,KAAA;AAAA,IAAA,QAAA,EASGkD,cAAc;AATjB,GAAA,C;;;AC5DJ,SAAA,GAAA,CAA8B;AAC5BQ,EAAAA,YAAY,EAAEC,YAAY,GADE,MAAA;AAAA,EAAA,SAAA;AAAA,EAAA,MAAA;AAAA,EAAA,aAAA;AAAA,EAAA,aAAA;AAAA,EAAA,kBAAA;AAAA,EAAA,GAAA;AAAA,EAAA,eAAA;AAAA,EAAA,iBAAA;AAAA,EAAA,UAAA;AAAA,EAAA,QAAA;AAAA,EAAA,oBAAA;AAAA,EAAA,YAAA;AAAA,EAAA,GAAA;AAAA,EAAA,WAAA;AAAA,EAAA,UAAA;AAAA,EAAA,SAAA;AAkB5B,mBAlB4B,YAAA;AAmB5B,mBAnB4B,YAAA;AAoB5B,KAAGnN;AApByB,CAA9B,EAAA,GAAA,EAqB4D;AAC1D,WAAA,eAAA,CAAA,KAAA,EAAkE;AAChEoN,IAAAA,oBAAoB,IAApBA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,oBAAoB,CAApBA,MAAoB,CAApBA;AACAC,IAAAA,YAAY,IAAZA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,YAAY,CAAZA,KAAY,CAAZA;AACD;;AAEDhE,EAAAA,SAAS,GAAGxJ,IAAI,CAAA,YAAA,EAEb,WAAU+H,MAAM,GAANA,CAAAA,KAAAA,CAAAA,GAAAA,MAAAA,GAA4B,KAFzB,EAAA,EAMd2F,QANc,IAAA,IAMdA,GANc,KAAA,CAMdA,GAAAA,QAAQ,CANM,GAMN,CANM,EAAA,SAAA,EAGYD,aAHZ,IAAA,oBAAA,EAIiB,CAAA,iBAAiB,IAAjB,IAAA,GAAA,KAAA,CAAA,GAAA,iBAAiB,CAAjB,GAAA,MAA2B,CAJ5C,CAIiB,IAJjCjE,yBAAgB,CAAhBA;AAUA,SAAA,aACE,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAI,EADN,KAAA;AAEE,qBAFF,YAAA;AAGE,qBAHF,YAAA;AAIE,IAAA,GAAG,EAJL,GAAA;AAKE,IAAA,SAAS,EALX,SAAA;AAME,IAAA,YAAY,EANd,eAAA;AAOE,IAAA,KAAK,EAAE;AAAEmD,MAAAA;AAAF,KAPT;AAAA,OAAA,KAAA;AAAA,IAAA,QAAA,EAUG,eAAe,CAAf,GAAA,CAAoBlK,MAAM,IAAI;AAC7B,YAAMoI,cAAc,GAAG,CAAA,iBAAiB,IAAjB,IAAA,GAAA,KAAA,CAAA,GAAA,iBAAiB,CAAjB,GAAA,MAA2BpI,MAAM,CAAxD,GAAA;;AACA,UAAI,CAAA,iBAAiB,IAAjB,IAAA,GAAA,KAAA,CAAA,GAAA,iBAAiB,CAAjB,IAAA,MAAA,MAAA,IAAJ,cAAA,EAA0D;AACxD,eAAA,aACE,GAAA,CAAA,QAAA,EAAA;AAEE,UAAA,MAAM,EAFR,MAAA;AAGE,UAAA,MAAM,EAHR,MAAA;AAIE,UAAA,GAAG,EAJL,GAAA;AAKE,UAAA,SAAS,EAAEkL,iBAAiB,CAL9B,SAAA;AAME,UAAA,WAAW,EAAEA,iBAAiB,CAACC;AANjC,SAAA,EACOnL,MAAM,CAFf,GACE,CADF;AAUD;;AAED,aAAA,aACE,GAAA,CAAA,YAAA,EAAA;AAEE,QAAA,MAAM,EAFR,MAAA;AAGE,QAAA,MAAM,EAHR,MAAA;AAIE,QAAA,GAAG,EAJL,GAAA;AAKE,QAAA,QAAQ,EAAEoL,aAAa,KAAKpL,MAAM,CALpC,GAAA;AAME,QAAA,aAAa,EAAEqL,kBAAkB,KAAKrL,MAAM,CAN9C,GAAA;AAOE,QAAA,cAAc,EAPhB,cAAA;AAQE,QAAA,aAAa,EARf,aAAA;AASE,QAAA,eAAe,EAAEoI,cAAc,GAAI8C,iBAAD,CAAH,eAAA,GATjC,SAAA;AAUE,QAAA,OAAO,EAAE9C,cAAc,GAAI8C,iBAAD,CAAH,OAAA,GAVzB,SAAA;AAWE,QAAA,SAAS,EAAE9C,cAAc,GAAG8C,iBAAiB,CAApB,SAAA,GAX3B,SAAA;AAYE,QAAA,UAAU,EAZZ,UAAA;AAaE,QAAA,WAAW,EAbb,WAAA;AAcE,QAAA,UAAU,EAdZ,UAAA;AAeE,QAAA,SAAS,EAAE9B;AAfb,OAAA,EACOpJ,MAAM,CAFf,GACE,CADF;AAfD,KAAA;AAVH,GAAA,CADF;AAgDD;;AAED,MAAA,KAAA,GAAA,aAAewH,IAAI,EAAA,aAAC8B,UAAU,CAA9B,GAA8B,CAAX,CAAnB;;ACxEA,SAAA,SAAA,CAA0B;AAAA,EAAA,EAAA;AAAA,EAAA,MAAA;AAAA,EAAA,QAAA;AAAA,EAAA,SAAA;AAAA,EAAA,UAAA;AAAA,EAAA,cAAA;AAAA,EAAA,aAAA;AAAA,EAAA,MAAA;AAAA,EAAA,gBAAA;AAAA,EAAA,SAAA;AAWxBvL,EAAAA,WAAW,EAAEuN;AAXW,CAA1B,EAY0B;AACxB,WAAA,WAAA,GAAuB;AACrBA,IAAAA,kBAAkB,CAAlBA,EAAkB,CAAlBA;AACD;;AAED,WAAA,oBAAA,CAAA,OAAA,EAAgD;AAC9ClC,IAAAA,SAAS,CAAC;AAAA,MAAA,MAAA;AAAA,MAAA,OAAA;AAAmBD,MAAAA,YAAY,EAAE;AAAjC,KAAD,CAATC;AACD;;AAGD,QAAMmC,eAAe,GAAGvL,MAAM,CAANA,QAAAA,IAAmBwL,gBAAgB,KAAKxL,MAAM,CAAtE,GAAA;AAEA,SAAA,aACE,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAI,EADN,UAAA;AAEE,qBAAeA,MAAM,CAANA,GAAAA,GAFjB,CAAA;AAIE,IAAA,SAAS,EAAEgH,gBAAgB,CAAA,MAAA,EACAoB,cADA,IAJ7B,qBAI6B,CAJ7B;AAOE,IAAA,KAAK,EAAE,EACL,GAAGlB,YAAY,CADV,MACU,CADV;AAELuE,MAAAA,MAAM,EAAEF,eAAe,GAAA,SAAA,GAAe;AAFjC,KAPT;AAWE,IAAA,OAAO,EAAEA,eAAe,GAAA,WAAA,GAX1B,SAAA;AAAA,IAAA,QAAA,EAaG,CAAC,CAACvL,MAAM,CAAP,QAAA,IAAoBwL,gBAAgB,KAAKxL,MAAM,CAAhD,GAAA,KAAyDA,MAAM,CAA/D,cAAA,IAAA,aACC,GAAA,CAAC,MAAD,CAAA,cAAA,EAAA;AACE,MAAA,QAAQ,EADV,QAAA;AAEE,MAAA,SAAS,EAFX,SAAA;AAGE,MAAA,MAAM,EAHR,MAAA;AAIE,MAAA,UAAU,EAJZ,UAAA;AAKE,MAAA,cAAc,EALhB,cAAA;AAME,MAAA,aAAa,EANf,aAAA;AAOE,MAAA,oBAAoB,EAPtB,oBAAA;AAQE,MAAA,WAAW,EAAEjC;AARf,KAAA;AAdJ,GAAA,EAGOiC,MAAM,CAJf,GACE,CADF;AA4BD;;AAED,MAAA,WAAA,GAAA,aAAewH,IAAI,CAAnB,SAAmB,CAAnB;;ACtDA,SAAA,UAAA,CAA2B;AAAA,EAAA,EAAA;AAAA,EAAA,QAAA;AAAA,EAAA,eAAA;AAAA,EAAA,SAAA;AAAA,EAAA,MAAA;AAAA,EAAA,GAAA;AAAA,EAAA,KAAA;AAAA,EAAA,UAAA;AAAA,EAAA,eAAA;AAAA,EAAA,aAAA;AAAA,EAAA,UAAA;AAAA,EAAA,SAAA;AAAA,EAAA,WAAA;AAczB,KAAG9J;AAdsB,CAA3B,EAeiC;AAE/B,QAAMuC,GAAG,GAAG+B,eAAe,CAAfA,CAAe,CAAfA,CAAAA,GAAAA,KAAAA,iBAAAA,GAA+C6B,KAAK,GAApD7B,CAAAA,GAAZ,KAAA;;AAEA,WAAA,WAAA,GAAuB;AACrByG,IAAAA,UAAU,CAAC;AAAA,MAAA,MAAA;AAAUxI,MAAAA,GAAG,EAAE,CAAC;AAAhB,KAAD,CAAVwI;AACD;;AAED,SAAA,aACE,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAI,EADN,KAAA;AAEE,kBAFF,KAAA;AAGE,qBAHF,UAAA;AAIE,IAAA,SAAS,EAAElL,IAAI,CAAA,YAAA,EAAA,iBAAA,EAGZ,WAAU+H,MAAM,GAANA,CAAAA,KAAAA,CAAAA,GAAAA,MAAAA,GAA4B,KAH1B,EAAA,EAIa0F,aAJb,IAAA,oBAAA,EAKkBU,eAAe,KAAK,CALtC,CAKkBA,IATnC,yBAIiB,CAJjB;AAYE,IAAA,OAAO,EAZT,WAAA;AAaE,IAAA,KAAK,EAAE;AAAExB,MAAAA;AAAF,KAbT;AAAA,OAAA,KAAA;AAAA,IAAA,QAAA,EAgBGlI,eAAe,CAAfA,GAAAA,CAAoBhC,MAAM,IAAA,aACzB,GAAA,CAAA,WAAA,EAAA;AAEE,MAAA,EAAE,EAFJ,EAAA;AAGE,MAAA,MAAM,EAHR,MAAA;AAIE,MAAA,QAAQ,EAJV,QAAA;AAKE,MAAA,SAAS,EALX,SAAA;AAME,MAAA,UAAU,EANZ,UAAA;AAOE,MAAA,aAAa,EAPf,aAAA;AAQE,MAAA,cAAc,EAAE0L,eAAe,KAAK1L,MAAM,CAR5C,GAAA;AASE,MAAA,MAAM,EATR,MAAA;AAUE,MAAA,gBAAgB,EAVlB,GAAA;AAWE,MAAA,SAAS,EAXX,SAAA;AAYE,MAAA,WAAW,EAAEjC;AAZf,KAAA,EACOiC,MAAM,CAFdgC,GACC,CADDA;AAhBH,GAAA,CADF;AAmCD;;AAED,MAAA,gBAAA,GAAA,aAAewF,IAAI,CAAnB,UAAmB,CAAnB;;ACzEA,SAAA,WAAA,CAA4B;AAAA,EAAA,MAAA;AAE1BxM,EAAAA;AAF0B,CAA5B,EAG4B;AAC1B,QAAM;AAAE2Q,IAAAA,gBAAgB,EAAlB,gBAAA;AAAsCC,IAAAA;AAAtC,MAAN,MAAA;AACA,QAAM7E,SAAS,GAAGC,gBAAgB,CAAA,MAAA,EAChC,OAAA,gBAAA,KAAA,UAAA,GAAyC4E,gBAAgB,CAAzD,GAAyD,CAAzD,GADF,gBAAkC,CAAlC;AAIA,SAAA,aACE,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAI,EADN,UAAA;AAEE,qBAAe5L,MAAM,CAANA,GAAAA,GAFjB,CAAA;AAGE,IAAA,SAAS,EAHX,SAAA;AAIE,IAAA,KAAK,EAAEkH,YAAY,CAJrB,MAIqB,CAJrB;AAAA,IAAA,QAAA,EAMG2E,gBAAgB,IAAA,aAAI,GAAA,CAAA,gBAAA,EAAA;AAAkB,MAAA,MAAM,EAAxB,MAAA;AAAkC,MAAA,GAAG,EAAE7Q;AAAvC,KAAA;AANvB,GAAA,CADF;AAUD;;AAED,MAAA,aAAA,GAAA,aAAewM,IAAI,CAAnB,WAAmB,CAAnB;;AChBA,SAAA,UAAA,CAA2B;AAAA,EAAA,MAAA;AAAA,EAAA,GAAA;AAAA,EAAA,eAAA;AAAA,EAAA,MAAA;AAKzB,mBAAiBsE;AALQ,CAA3B,EAM2B;AACzB,SAAA,aACE,GAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAI,EADN,KAAA;AAEE,qBAFF,YAAA;AAGE,IAAA,SAAS,EAAG,GAAE7Q,YAAa,YAAWqK,MAAM,GAANA,CAAAA,KAAAA,CAAAA,GAAAA,MAAAA,GAA4B,KAAM,IAAGjK,mBAH7E,EAAA;AAIE,IAAA,KAAK,EAAE;AAAE0Q,MAAAA;AAAF,KAJT;AAAA,IAAA,QAAA,EAMG/J,eAAe,CAAfA,GAAAA,CAAoBhC,MAAM,IAAA,aACzB,GAAA,CAAA,aAAA,EAAA;AAEE,MAAA,MAAM,EAFR,MAAA;AAGE,MAAA,GAAG,EAAEhF;AAHP,KAAA,EACOgF,MAAM,CAFdgC,GACC,CADDA;AANH,GAAA,CADF;AAgBD;;AAED,MAAA,YAAA,GAAA,aAAewF,IAAI,CAAnB,UAAmB,CAAnB;;;;ACsBA,MAAMwE,IAAI,GAAA,CAAA,oBAAA,GAAGC,UAAU,CAAb,QAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAAGA,oBAAAA,CAAb,IAAA;;AA6GA,SAAA,QAAA,CAAyB;AAEvBpM,EAAAA,OAAO,EAFgB,UAAA;AAGvB4D,EAAAA,IAAI,EAHmB,OAAA;AAAA,EAAA,WAAA;AAAA,EAAA,YAAA;AAAA,EAAA,YAAA;AAQvByI,EAAAA,SAAS,GARc,EAAA;AASvBC,EAAAA,eAAe,GATQ,SAAA;AAUvBC,EAAAA,mBAAmB,GAVI,EAAA;AAWvBC,EAAAA,gBAAgB,GAXO,SAAA;AAAA,EAAA,YAAA;AAAA,EAAA,oBAAA;AAAA,EAAA,UAAA;AAAA,EAAA,aAAA;AAAA,EAAA,MAAA;AAAA,EAAA,OAAA;AAAA,EAAA,eAAA;AAAA,EAAA,oBAAA;AAqBvB3M,EAAAA,OAAO,EArBgB,UAAA;AAAA,EAAA,UAAA;AAAA,EAAA,gBAAA;AAAA,EAAA,wBAAA;AA0BvB4M,EAAAA,WAAW,EAAEC,WAAW,GA1BD,KAAA;AA2BvBC,EAAAA,iBAAiB,EA3BM,iBAAA;AAAA,EAAA,UAAA;AAAA,EAAA,QAAA;AAAA,EAAA,cAAA;AAAA,EAAA,oBAAA;AAAA,EAAA,MAAA;AAAA,EAAA,OAAA;AAoCvBC,EAAAA,eAAe,GApCQ,KAAA;AAqCvBpH,EAAAA,kBAAkB,GArCK,MAAA;AAuCvBqH,EAAAA,kBAAkB,GAvCK,IAAA;AAAA,EAAA,SAAA;AAAA,EAAA,KAAA;AAAA,EAAA,QAAA;AA4CvB,gBA5CuB,SAAA;AA6CvB,qBA7CuB,cAAA;AA8CvB,sBAAoBC;AA9CG,CAAzB,EAAA,GAAA,EA+CyD;AAAA,MAAA,mBAAA;;AAIvD,QAAM,CAAA,SAAA,EAAA,YAAA,IAA4B3Q,QAAQ,CAA1C,CAA0C,CAA1C;AACA,QAAM,CAAA,UAAA,EAAA,aAAA,IAA8BA,QAAQ,CAA5C,CAA4C,CAA5C;AACA,QAAM,CAAA,YAAA,EAAA,eAAA,IAAkCA,QAAQ,CAA8B,MAAM,IAApF,GAAoF,EAApC,CAAhD;AACA,QAAM,CAAA,gBAAA,EAAA,mBAAA,IAA0CA,QAAQ,CAAqC;AAAEiE,IAAAA,GAAG,EAAE,CAAP,CAAA;AAAWqF,IAAAA,MAAM,EAAE,CAAnB,CAAA;AAAuBsH,IAAAA,IAAI,EAAE;AAA7B,GAArC,CAAxD;AACA,QAAM,CAAA,UAAA,EAAA,aAAA,IAA8B5Q,QAAQ,CAA5C,IAA4C,CAA5C;AACA,QAAM,CAAA,UAAA,EAAA,WAAA,IAA4BA,QAAQ,CAA1C,KAA0C,CAA1C;AACA,QAAM,CAAA,iBAAA,EAAA,aAAA,IAAqCA,QAAQ,CAAnD,SAAmD,CAAnD;AAKA,QAAM6Q,YAAY,GAAGtR,MAAM,CAA3B,IAA2B,CAA3B;AACA,QAAMuR,oBAAoB,GAAGvR,MAAM,CAAnC,gBAAmC,CAAnC;AACA,QAAMwR,uBAAuB,GAAGxR,MAAM,CAAtC,iBAAsC,CAAtC;AACA,QAAMyR,kBAAkB,GAAGzR,MAAM,CAAC,CAAlC,CAAiC,CAAjC;AACA,QAAM0R,eAAe,GAAG1R,MAAM,CAA9B,KAA8B,CAA9B;AAKA,QAAM2R,gBAAgB,GAAGC,aAAa,CAAtC,SAAsC,CAAtC;AACA,QAAM5E,iBAAiB,GAAG4E,aAAa,CAAvC,UAAuC,CAAvC;AACA,QAAM7B,kBAAkB,GAAG6B,aAAa,CAAxC,WAAwC,CAAxC;AACA,QAAMC,+BAA+B,GAAGD,aAAa,CAArD,SAAqD,CAArD;AAKA,QAAM,CAAA,OAAA,EAAA,SAAA,EAAA,UAAA,IAAmCE,iBAAzC,EAAA;AACA,QAAMC,eAAe,GAAGb,eAAe,GAAA,CAAA,GAAvC,CAAA;AACA,QAAMc,gBAAgB,GAAA,CAAA,mBAAA,GAAGC,WAAH,IAAA,IAAGA,GAAH,KAAA,CAAGA,GAAAA,WAAW,CAAd,MAAA,KAAA,IAAA,GAAA,mBAAA,GAAtB,CAAA;AACA,QAAMC,iBAAiB,GAAGtB,eAAe,IAAIM,eAAe,GAAA,mBAAA,GAA5D,CAAyC,CAAzC;AACA,QAAMrQ,YAAY,GAAGsR,UAAU,GAAVA,iBAAAA,GAAiCH,gBAAgB,GAAtE,gBAAA;AACA,QAAMI,YAAY,GAAGC,YAAY,KAAZA,SAAAA,IAA8BrG,oBAAoB,KAAvE,SAAA;AAEA,QAAM;AAAA,IAAA,OAAA;AAAA,IAAA,eAAA;AAAA,IAAA,aAAA;AAAA,IAAA,aAAA;AAAA,IAAA,gBAAA;AAAA,IAAA,qBAAA;AAAA,IAAA,sBAAA;AAA2H7H,IAAAA;AAA3H,MAAuImO,kBAAkB,CAAC;AAAA,IAAA,UAAA;AAAA,IAAA,YAAA;AAAA,IAAA,UAAA;AAI9J5M,IAAAA,aAAa,EAJiJ,SAAA;AAAA,IAAA,oBAAA;AAM9J7B,IAAAA,UAAU,EAAEyD,UAAU,GAAA,UAAA,GAAgB8G;AANwH,GAAD,CAA/J;AASA,QAAM;AAAA,IAAA,mBAAA;AAAA,IAAA,iBAAA;AAAA,IAAA,IAAA;AAAA,IAAA,SAAA;AAA2D7F,IAAAA;AAA3D,MAA0EgK,eAAe,CAAC;AAAA,IAAA,OAAA;AAAA,IAAA,OAAA;AAAA,IAAA,UAAA;AAAA,IAAA,SAAA;AAAA,IAAA,YAAA;AAAA,IAAA,SAAA;AAO9FvL,IAAAA;AAP8F,GAAD,CAA/F;AAUA,QAAMwL,SAAS,GAAGrO,OAAO,CAAPA,MAAAA,GAAAA,CAAAA,IAAsB,OAAA,UAAA,KAAxC,UAAA;AACA,QAAMsO,SAAS,GAAGD,SAAS,GAAG,CAAH,CAAA,GAA3B,CAAA;AAGA,QAAME,qBAAqB,GAAGF,SAAS,GAAA,KAAA,GAAWG,MAAM,KAAxD,SAAA;AAKAjS,EAAAA,eAAe,CAAC,MAAM;AACpB,QAAIkJ,gBAAgB,KAAK2H,oBAAoB,CAAzC3H,OAAAA,IAAqDA,gBAAgB,CAAhBA,IAAAA,KAArDA,MAAAA,IAAyF,CAACgJ,kBAAkB,CAAhH,gBAAgH,CAAhH,EAAoI;AACpIrB,IAAAA,oBAAoB,CAApBA,OAAAA,GAAAA,gBAAAA;AACAsB,IAAAA,YAAY,CAAZA,gBAAY,CAAZA;;AAEA,QAAInB,eAAe,CAAnB,OAAA,EAA6B;AAC3BA,MAAAA,eAAe,CAAfA,OAAAA,GAAAA,KAAAA;AACA;AACD;;AACDJ,IAAAA,YAAY,CAAZA,OAAAA,CAAAA,KAAAA,CAA4B;AAAErQ,MAAAA,aAAa,EAAE;AAAjB,KAA5BqQ;AATF5Q,GAAe,CAAfA;AAYAoS,EAAAA,mBAAmB,CAAA,GAAA,EAAM,OAAO;AAC9BC,IAAAA,OAAO,EAAEvS,OAAO,CADc,OAAA;;AAE9BwS,IAAAA,cAAc,CAAA,GAAA,EAAc;AAC1BH,MAAAA,YAAY,CAAC;AAAEnO,QAAAA;AAAF,OAAD,CAAZmO;AAH4B,KAAA;;AAK9BI,IAAAA,WAAW,CAAA,MAAA,EAAiB;AAC1B,YAAM;AAAEC,QAAAA;AAAF,UAAN,OAAA;AACA,UAAI,CAAJ,OAAA,EAAc;AACdA,MAAAA,OAAO,CAAPA,QAAAA,CAAiB;AACfvE,QAAAA,GAAG,EAAE5E,MAAM,GADI,SAAA;AAEfoJ,QAAAA,QAAQ,EAAE;AAFK,OAAjBD;AAR4B,KAAA;;AAa9BhG,IAAAA;AAb8B,GAAP,CAAN,CAAnB4F;AAmBA,QAAMM,kBAAkB,GAAGtK,WAAW,CAAC,CAAA,MAAA,EAAA,KAAA,KAAoD;AACzFuK,IAAAA,eAAe,CAAC1M,YAAY,IAAI;AAC9B,YAAM2M,eAAe,GAAG,IAAA,GAAA,CAAxB,YAAwB,CAAxB;AACAA,MAAAA,eAAe,CAAfA,GAAAA,CAAoB7O,MAAM,CAA1B6O,GAAAA,EAAAA,KAAAA;AACA,aAAA,eAAA;AAHFD,KAAe,CAAfA;AAMAE,IAAAA,cAAc,IAAdA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,cAAc,CAAG9O,MAAM,CAAT,GAAA,EAAd8O,KAAc,CAAdA;AAPoC,GAAA,EAQnC,CARH,cAQG,CARmC,CAAtC;AAUA,QAAMhE,oBAAoB,GAAGzG,WAAW,CAAEiB,MAAD,IAAqB;AAC5DyJ,IAAAA,aAAa,CAAbA,MAAa,CAAbA;AACAhC,IAAAA,uBAAuB,CAAvBA,OAAAA,GAAAA,MAAAA;AAFsC,GAAA,EAAxC,EAAwC,CAAxC;;AAQA,WAAA,SAAA,CAAmB;AAAA,IAAA,MAAA;AAAA,IAAA,OAAA;AAAmB5D,IAAAA;AAAnB,GAAnB,EAAsE;AACpE,QAAI,CAAJ,oBAAA,EAA2B;AAE3B9B,IAAAA,sBAAsB,CAAtBA,YAAsB,CAAtBA;AACA,UAAMC,eAAe,GAAG,IAAA,GAAA,CAAxB,YAAwB,CAAxB;AACA,UAAMtM,GAAG,GAAGyI,IAAI,CAAhB,MAAgB,CAAhB;;AACA,QAAIK,UAAU,CAAd,GAAc,CAAd,EAAqB;AACnB,WAAK,MAAL,QAAA,IAAuB9I,GAAG,CAA1B,SAAA,EAAsC;AACpC,cAAMgU,MAAM,GAAGC,YAAY,CAA3B,QAA2B,CAA3B;;AACA,YAAA,OAAA,EAAa;AACX3H,UAAAA,eAAe,CAAfA,GAAAA,CAAAA,MAAAA;AADF,SAAA,MAEO;AACLA,UAAAA,eAAe,CAAfA,MAAAA,CAAAA,MAAAA;AACD;AACF;;AACDC,MAAAA,oBAAoB,CAApBA,eAAoB,CAApBA;AACA;AACD;;AAED,UAAMyH,MAAM,GAAGC,YAAY,CAA3B,GAA2B,CAA3B;;AACA,QAAA,OAAA,EAAa;AACX3H,MAAAA,eAAe,CAAfA,GAAAA,CAAAA,MAAAA;AACA,YAAM4H,cAAc,GAAGlC,kBAAkB,CAAzC,OAAA;AACAA,MAAAA,kBAAkB,CAAlBA,OAAAA,GAAAA,MAAAA;;AACA,UAAI7D,YAAY,IAAI+F,cAAc,KAAK,CAAnC/F,CAAAA,IAAyC+F,cAAc,KAA3D,MAAA,EAAwE;AACtE,cAAMC,IAAI,GAAGxN,IAAI,CAAJA,IAAAA,CAAU2D,MAAM,GAA7B,cAAa3D,CAAb;;AACA,aAAK,IAAIN,CAAC,GAAG6N,cAAc,GAA3B,IAAA,EAAoC7N,CAAC,KAArC,MAAA,EAAkDA,CAAC,IAAnD,IAAA,EAA6D;AAC3D,gBAAMrG,GAAG,GAAGyI,IAAI,CAAhB,CAAgB,CAAhB;AACA,cAAIK,UAAU,CAAd,GAAc,CAAd,EAAqB;AACrBwD,UAAAA,eAAe,CAAfA,GAAAA,CAAoB2H,YAAY,CAAhC3H,GAAgC,CAAhCA;AACD;AACF;AAXH,KAAA,MAYO;AACLA,MAAAA,eAAe,CAAfA,MAAAA,CAAAA,MAAAA;AACA0F,MAAAA,kBAAkB,CAAlBA,OAAAA,GAA6B,CAA7BA,CAAAA;AACD;;AAEDzF,IAAAA,oBAAoB,CAApBA,eAAoB,CAApBA;AACD;;AAED,WAAA,WAAA,CAAA,eAAA,EAA+C;AAC7C,QAAI,CAAJ,wBAAA,EAA+B;AAC/B,UAAM6H,mBAAmB,GAAG,IAAA,GAAA,CAA5B,gBAA4B,CAA5B;;AACA,QAAIA,mBAAmB,CAAnBA,GAAAA,CAAJ,eAAIA,CAAJ,EAA8C;AAC5CA,MAAAA,mBAAmB,CAAnBA,MAAAA,CAAAA,eAAAA;AADF,KAAA,MAEO;AACLA,MAAAA,mBAAmB,CAAnBA,GAAAA,CAAAA,eAAAA;AACD;;AACDC,IAAAA,wBAAwB,CAAxBA,mBAAwB,CAAxBA;AACD;;AAED,WAAA,WAAA,GAAuB;AACrB,QAAI,CAAClB,kBAAkB,CAAvB,gBAAuB,CAAvB,EAA2C;AAEzC,YAAMmB,eAAgC,GAAG;AAAErP,QAAAA,GAAG,EAAL,CAAA;AAAUqF,QAAAA,MAAM,EAAhB,CAAA;AAAqBsH,QAAAA,IAAI,EAAE;AAA3B,OAAzC;;AACA,UAAIuB,kBAAkB,CAAtB,eAAsB,CAAtB,EAAyC;AACvCoB,QAAAA,mBAAmB,CAAnBA,eAAmB,CAAnBA;AACD;AALH,KAAA,MAMO;AAELnB,MAAAA,YAAY,CAAZA,gBAAY,CAAZA;AACD;AACF;;AAED,WAAA,aAAA,CAAA,KAAA,EAAmE;AACjE,UAAM;AAAA,MAAA,GAAA;AAAOoB,MAAAA;AAAP,QAAN,KAAA;AACA,UAAMxU,GAAG,GAAGyI,IAAI,CAAC0B,gBAAgB,CAAjC,MAAgB,CAAhB;;AAEA,QACEsK,OAAO,IACJC,iBAAiB,CADpBD,KACoB,CADpBA,IAEGtB,kBAAkB,CAFrBsB,gBAEqB,CAFrBA,IAGG,CAAC3L,UAAU,CAHd2L,GAGc,CAHdA,IAIGtK,gBAAgB,CAAhBA,GAAAA,KAAyB,CAJ5BsK,CAAAA,IAKGtK,gBAAgB,CAAhBA,IAAAA,KANL,QAAA,EAOE;AAGA,YAAMwK,IAAI,GAAV,EAAA;AACA,YAAMC,IAAI,GAAV,EAAA;;AACA,UAAIJ,OAAO,KAAX,IAAA,EAAsB;AACpBK,QAAAA,UAAU;AACV;AACD;;AACD,UAAIL,OAAO,KAAX,IAAA,EAAsB;AACpBM,QAAAA,WAAW;AACX;AACD;AACF;;AAED,QACE3B,kBAAkB,CAAlBA,gBAAkB,CAAlBA,IACGrK,UAAU,CADbqK,GACa,CADbA,IAEGhJ,gBAAgB,CAAhBA,GAAAA,KAAyB,CAF5BgJ,CAAAA,KAKGjQ,GAAG,KAAHA,WAAAA,IAAuBlD,GAAG,CAA3B,UAACkD,IAEGA,GAAG,KAAHA,YAAAA,IAAwB,CAAClD,GAAG,CARpC,UACEmT,CADF,EASK;AACH9P,MAAAA,KAAK,CAALA,cAAAA;AACAN,MAAAA,WAAW,CAAC/C,GAAG,CAAf+C,EAAW,CAAXA;AACA;AACD;;AAED,YAAQM,KAAK,CAAb,GAAA;AACE,WAAA,QAAA;AACE0R,QAAAA,aAAa,CAAbA,IAAa,CAAbA;AACAC,QAAAA,WAAW;AACX;;AACF,WAAA,SAAA;AACA,WAAA,WAAA;AACA,WAAA,WAAA;AACA,WAAA,YAAA;AACA,WAAA,KAAA;AACA,WAAA,MAAA;AACA,WAAA,KAAA;AACA,WAAA,QAAA;AACA,WAAA,UAAA;AACEC,QAAAA,QAAQ,CAARA,KAAQ,CAARA;AACA;;AACF;AACEC,QAAAA,eAAe,CAAfA,KAAe,CAAfA;AACA;AAlBJ;AAoBD;;AAED,WAAA,WAAA,GAAuB;AACrBjD,IAAAA,eAAe,CAAfA,OAAAA,GAAAA,IAAAA;AACD;;AAED,WAAA,YAAA,CAAA,KAAA,EAA4D;AAC1D,UAAM;AAAA,MAAA,SAAA;AAAa1L,MAAAA;AAAb,QAA4BlD,KAAK,CAAvC,aAAA;AACA8R,IAAAA,YAAY,CAAZA,SAAY,CAAZA;AACAC,IAAAA,aAAa,CAAbA,UAAa,CAAbA;AACAC,IAAAA,QAAQ,IAARA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,QAAQ,CAARA,KAAQ,CAARA;AACD;;AAED,WAAA,YAAA,CAAA,MAAA,EAAsC;AACpC,WAAOtC,SAAS,GAAGvL,OAAO,CAAPA,OAAAA,CAAgBiB,IAAI,CAAvB,MAAuB,CAApBjB,CAAH,GAAhB,MAAA;AACD;;AAED,WAAA,SAAA,CAAA,MAAA,EAAA,GAAA,EAA2C;AACzC,QAAI,OAAA,YAAA,KAAJ,UAAA,EAAwC;AACxC,UAAM8N,WAAW,GAAG,CAAC,GAArB,OAAoB,CAApB;AACAA,IAAAA,WAAW,CAAXA,MAAW,CAAXA,GAAAA,GAAAA;AACAC,IAAAA,YAAY,CAAA,WAAA,EAAc;AACxBC,MAAAA,OAAO,EAAE,CADe,MACf,CADe;AAExBxQ,MAAAA,MAAM,EAAEH,OAAO,CAACsF,gBAAgB,CAAjB,GAAA;AAFS,KAAd,CAAZoL;AAID;;AAED,WAAA,mBAAA,GAA+B;AAAA,QAAA,qBAAA;;AAC7B,QACE,CAAA,CAAA,qBAAA,GAAA,OAAO,CAACpL,gBAAgB,CAAxB,GAAO,CAAP,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,qBAAA,CAAA,MAAA,MAAA,SAAA,IACGA,gBAAgB,CAAhBA,IAAAA,KADH,QAAA,IAEGA,gBAAgB,CAAhBA,GAAAA,KAAyBA,gBAAgB,CAH9C,WAAA,EAG4D;AAC1D;AACD;;AAED,UAAMG,MAAM,GAAGmL,YAAY,CAACtL,gBAAgB,CAA5C,MAA2B,CAA3B;AACAuL,IAAAA,SAAS,CAAA,MAAA,EAASvL,gBAAgB,CAAlCuL,GAAS,CAATA;AACD;;AAED,WAAA,UAAA,GAAsB;AACpB,UAAM;AAAA,MAAA,GAAA;AAAOpL,MAAAA;AAAP,QAAN,gBAAA;AACAyK,IAAAA,aAAa,CAAC;AAAE/U,MAAAA,GAAG,EAAEwH,OAAO,CAACiO,YAAY,CAA3B,MAA2B,CAAb,CAAd;AAAsCE,MAAAA,SAAS,EAAE9Q,OAAO,CAAPA,GAAO,CAAPA,CAAa3B;AAA9D,KAAD,CAAb6R;AACD;;AAED,WAAA,WAAA,GAAuB;AACrB,UAAM;AAAA,MAAA,GAAA;AAAOzK,MAAAA;AAAP,QAAN,gBAAA;AACA,UAAMsL,SAAS,GAAGpO,OAAO,CAACiO,YAAY,CAAtC,MAAsC,CAAb,CAAzB;;AACA,QACE,CAAA,OAAA,IACG,CADH,YAAA,IAEGI,UAAU,KAFb,IAAA,IAGG,CAACC,cAAc,CAJpB,gBAIoB,CAJpB,EAKE;AACA;AACD;;AAED,UAAMC,gBAAgB,GAAGtB,OAAO,CAAC;AAC/BuB,MAAAA,SAAS,EAAEH,UAAU,CADU,GAAA;AAE/BI,MAAAA,eAAe,EAAEJ,UAAU,CAFI,SAAA;AAAA,MAAA,SAAA;AAI/BK,MAAAA,eAAe,EAAErR,OAAO,CAAPA,GAAO,CAAPA,CAAa3B;AAJC,KAAD,CAAhC;AAOAwS,IAAAA,SAAS,CAAA,MAAA,EAATA,gBAAS,CAATA;AACD;;AAED,WAAA,eAAA,CAAA,KAAA,EAAqE;AAAA,QAAA,qBAAA;;AACnE,QAAI,CAACvC,kBAAkB,CAAvB,gBAAuB,CAAvB,EAA2C;AAC3C,UAAMnT,GAAG,GAAGyI,IAAI,CAAC0B,gBAAgB,CAAjC,MAAgB,CAAhB;AACA,QAAIrB,UAAU,CAAd,GAAc,CAAd,EAAqB;AACrB,UAAM;AAAE5F,MAAAA;AAAF,QAAN,KAAA;AACA,UAAM8B,MAAM,GAAGH,OAAO,CAACsF,gBAAgB,CAAvC,GAAsB,CAAtB;;AAEA,QAAIA,gBAAgB,CAAhBA,IAAAA,KAAJ,MAAA,EAAsC;AACpC,UAAIjH,GAAG,KAAP,OAAA,EAAqB;AAEnBiT,QAAAA,mBAAmB;AACnBnB,QAAAA,WAAW;AACZ;;AACD;AACD;;AAED,KAAA,qBAAA,GAAA,MAAM,CAAN,aAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAAA,qBAAA,CAAA,aAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,qBAAA,CAAA,aAAA,CAAA,KAAA,CAAA;AACA,QAAI3R,KAAK,CAAT,kBAAIA,EAAJ,EAAgC;;AAEhC,QAAIyS,cAAc,CAAdA,gBAAc,CAAdA,IAAoCM,kBAAkB,CAA1D,KAA0D,CAA1D,EAAmE;AACjE7B,MAAAA,mBAAmB,CAAC,CAAC;AAAA,QAAA,GAAA;AAAOjK,QAAAA;AAAP,OAAD,MAAsB;AAAA,QAAA,GAAA;AAAA,QAAA,MAAA;AAAA,QAAA,GAAA;AAIxCsH,QAAAA,IAAI,EAJoC,MAAA;AAAA,QAAA,GAAA;AAMxCyE,QAAAA,WAAW,EAAErW;AAN2B,OAAtB,CAAD,CAAnBuU;AAQD;AACF;;AAED,WAAA,aAAA,GAAyB;AACvB,UAAM+B,UAAU,GAAGvE,uBAAuB,CAA1C,OAAA;AACA,QAAIuE,UAAU,KAAVA,SAAAA,IAA4B,CAA5BA,MAAAA,IAAuC,CAA3C,YAAA,EAA0D;AAE1D,UAAM;AAAA,MAAA,GAAA;AAAOhM,MAAAA;AAAP,QAAN,gBAAA;AACA,UAAM0L,SAAS,GAAGxO,OAAO,CAAzB,MAAyB,CAAzB;AACA,UAAMQ,aAAa,GAAGsC,MAAM,GAANA,UAAAA,GAAsBA,MAAM,GAA5BA,CAAAA,GAAtB,UAAA;AACA,UAAMiM,WAAW,GAAGjM,MAAM,GAANA,UAAAA,GAAsBgM,UAAU,GAAhChM,CAAAA,GAApB,MAAA;AACA,UAAMkM,UAAU,GAAGhP,OAAO,CAAPA,KAAAA,CAAAA,aAAAA,EAAnB,WAAmBA,CAAnB;AACA,UAAMxC,MAAM,GAAGH,OAAO,CAAtB,GAAsB,CAAtB;AACA,UAAM4R,iBAAiB,GAAGvD,MAAM,CAAC;AAAEyC,MAAAA,SAAS,EAAE3Q,MAAM,CAAnB,GAAA;AAAA,MAAA,SAAA;AAAoCwR,MAAAA;AAApC,KAAD,CAAhC;AACA,UAAMlB,WAAW,GAAG,CAAC,GAArB,OAAoB,CAApB;AACA,UAAME,OAAiB,GAAvB,EAAA;;AAEA,SAAK,IAAInP,CAAC,GAAV,aAAA,EAA4BA,CAAC,GAA7B,WAAA,EAA6CA,CAA7C,EAAA,EAAkD;AAChDiP,MAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAiBmB,iBAAiB,CAACpQ,CAAC,GAApCiP,aAAkC,CAAlCA;AACAE,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,CAAAA;AACD;;AAEDD,IAAAA,YAAY,CAAA,WAAA,EAAc;AAAA,MAAA,OAAA;AAAWvQ,MAAAA;AAAX,KAAd,CAAZuQ;AACAzF,IAAAA,oBAAoB,CAApBA,SAAoB,CAApBA;AACD;;AAED,WAAA,eAAA,CAAA,KAAA,EAA8E;AAC5E,QAAIzM,KAAK,CAALA,OAAAA,KAAJ,CAAA,EAAyB;AACzBqT,IAAAA,WAAW,CAAXA,IAAW,CAAXA;AACA7V,IAAAA,MAAM,CAANA,gBAAAA,CAAAA,WAAAA,EAAAA,WAAAA;AACAA,IAAAA,MAAM,CAANA,gBAAAA,CAAAA,SAAAA,EAAAA,SAAAA;;AAEA,aAAA,WAAA,CAAA,KAAA,EAAwC;AAItC,UAAIwC,KAAK,CAALA,OAAAA,KAAJ,CAAA,EAAyBsT,SAAS;AACnC;;AAED,aAAA,SAAA,GAAqB;AACnB9V,MAAAA,MAAM,CAANA,mBAAAA,CAAAA,WAAAA,EAAAA,WAAAA;AACAA,MAAAA,MAAM,CAANA,mBAAAA,CAAAA,SAAAA,EAAAA,SAAAA;AACA6V,MAAAA,WAAW,CAAXA,KAAW,CAAXA;AACAE,MAAAA,aAAa;AACd;AACF;;AAED,WAAA,iBAAA,CAAA,KAAA,EAAoE;AAClEvT,IAAAA,KAAK,CAALA,eAAAA;AACA,QAAI,CAAA,MAAA,IAAW,CAAf,YAAA,EAA8B;AAE9B,UAAM;AAAA,MAAA,GAAA;AAAOiH,MAAAA;AAAP,QAAN,gBAAA;AACA,UAAM0L,SAAS,GAAGxO,OAAO,CAAzB,MAAyB,CAAzB;AACA,UAAMgP,UAAU,GAAGhP,OAAO,CAAPA,KAAAA,CAAc8C,MAAM,GAAvC,CAAmB9C,CAAnB;AACA,UAAMxC,MAAM,GAAGH,OAAO,CAAtB,GAAsB,CAAtB;AACA,UAAM4R,iBAAiB,GAAGvD,MAAM,CAAC;AAAEyC,MAAAA,SAAS,EAAE3Q,MAAM,CAAnB,GAAA;AAAA,MAAA,SAAA;AAAoCwR,MAAAA;AAApC,KAAD,CAAhC;AACA,UAAMlB,WAAW,GAAG,CAAC,GAArB,OAAoB,CAApB;AACA,UAAME,OAAiB,GAAvB,EAAA;;AAEA,SAAK,IAAInP,CAAC,GAAGiE,MAAM,GAAnB,CAAA,EAAyBjE,CAAC,GAAGiP,WAAW,CAAxC,MAAA,EAAiDjP,CAAjD,EAAA,EAAsD;AACpDiP,MAAAA,WAAW,CAAXA,CAAW,CAAXA,GAAiBmB,iBAAiB,CAACpQ,CAAC,GAADA,MAAAA,GAAnCiP,CAAkC,CAAlCA;AACAE,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,CAAAA;AACD;;AAEDD,IAAAA,YAAY,CAAA,WAAA,EAAc;AAAA,MAAA,OAAA;AAAWvQ,MAAAA;AAAX,KAAd,CAAZuQ;AACD;;AAED,WAAA,qBAAA,CAAA,GAAA,EAAA,aAAA,EAA0E;AACxE,QAAIpL,gBAAgB,CAAhBA,IAAAA,KAAJ,QAAA,EAAwC;;AACxC,QAAA,aAAA,EAAmB;AACjBuL,MAAAA,SAAS,CAACD,YAAY,CAACtL,gBAAgB,CAA9B,MAAa,CAAb,EAATuL,GAAS,CAATA;AACAV,MAAAA,WAAW;AAFb,KAAA,MAGO;AACLT,MAAAA,mBAAmB,CAACsC,QAAQ,KAAK,EAAE,GAAF,QAAA;AAAe7W,QAAAA;AAAf,OAAL,CAAT,CAAnBuU;AACD;AACF;;AAED,WAAA,aAAA,CAAA,aAAA,EAAgD;AAC9C,QAAA,aAAA,EAAmB;AACjB4B,MAAAA,mBAAmB;AACpB;;AACDnB,IAAAA,WAAW;AACZ;;AAKD,WAAA,kBAAA,CAA4B;AAAA,IAAA,GAAA;AAAO1K,IAAAA;AAAP,GAA5B,EAAgE;AAC9D,WAAOA,MAAM,IAANA,CAAAA,IAAeA,MAAM,GAAG7B,IAAI,CAA5B6B,MAAAA,IAAuCrF,GAAG,IAA1CqF,SAAAA,IAA2DrF,GAAG,GAAGJ,OAAO,CAA/E,MAAA;AACD;;AAED,WAAA,cAAA,CAAA,QAAA,EAAqD;AACnD,WAAOsO,kBAAkB,CAAlBA,QAAkB,CAAlBA,IACF2D,sBAAsB,CAAQ;AAAA,MAAA,OAAA;AAAA,MAAA,IAAA;AAAiB3M,MAAAA,gBAAgB,EAAjC,QAAA;AAA6CrB,MAAAA;AAA7C,KAAR,CAD3B;AAED;;AAED,WAAA,UAAA,CAAA,QAAA,EAAwCiO,YAAY,GAApD,KAAA,EAAoE;AAClE,QAAI,CAAC5D,kBAAkB,CAAvB,QAAuB,CAAvB,EAAmC;AACnCgD,IAAAA,mBAAmB;;AAEnB,QAAIY,YAAY,IAAIjB,cAAc,CAAlC,QAAkC,CAAlC,EAA8C;AAC5C,YAAM9V,GAAG,GAAGyI,IAAI,CAACoO,QAAQ,CAAzB,MAAgB,CAAhB;AACAtC,MAAAA,mBAAmB,CAAC,EAAE,GAAF,QAAA;AAAe3C,QAAAA,IAAI,EAAnB,MAAA;AAA6B1O,QAAAA,GAAG,EAAhC,IAAA;AAAA,QAAA,GAAA;AAA6CmT,QAAAA,WAAW,EAAErW;AAA1D,OAAD,CAAnBuU;AAFF,KAAA,MAGO;AACLA,MAAAA,mBAAmB,CAAC,EAAE,GAAF,QAAA;AAAe3C,QAAAA,IAAI,EAAE;AAArB,OAAD,CAAnB2C;AACD;;AACDyC,IAAAA,oBAAoB,IAApBA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,oBAAoB,CAAG,EAAE,GAAGH;AAAL,KAAH,CAApBG;AACD;;AAED,WAAA,WAAA,GAAuB;AACrB,QAAI7M,gBAAgB,CAAhBA,IAAAA,KAAJ,QAAA,EAAwC;AACxCoK,IAAAA,mBAAmB,CAAC,CAAC;AAAA,MAAA,GAAA;AAAOjK,MAAAA;AAAP,KAAD,MAAsB;AAAA,MAAA,GAAA;AAAA,MAAA,MAAA;AAAesH,MAAAA,IAAI,EAAE;AAArB,KAAtB,CAAD,CAAnB2C;AACD;;AAED,WAAA,YAAA,CAAsB;AAAA,IAAA,GAAA;AAAOjK,IAAAA;AAAP,GAAtB,EAAgE;AAC9D,UAAM;AAAEmJ,MAAAA;AAAF,QAAN,OAAA;AACA,QAAI,CAAJ,OAAA,EAAc;;AAEd,QAAI,OAAA,GAAA,KAAA,QAAA,IAA2BxO,GAAG,GAAlC,qBAAA,EAA4D;AAC1D,YAAM;AAAEgS,QAAAA;AAAF,UAAN,OAAA;AACA,YAAM;AAAA,QAAA,IAAA;AAAQxT,QAAAA;AAAR,UAAkB8B,aAAa,CAAbA,GAAAA,CAAkBV,OAAO,CAAjD,GAAiD,CAAzBU,CAAxB;AACA,YAAM2R,oBAAoB,GAAG1R,IAAI,GAAGe,UAAU,GAA9C,sBAAA;AACA,YAAM4Q,qBAAqB,GAAG3R,IAAI,GAAJA,KAAAA,GAAeyR,WAAW,GAAxD,UAAA;;AACA,UAAA,oBAAA,EAA0B;AACxBxD,QAAAA,OAAO,CAAPA,UAAAA,GAAqBjO,IAAI,GAAzBiO,sBAAAA;AADF,OAAA,MAEO,IAAA,qBAAA,EAA2B;AAChCA,QAAAA,OAAO,CAAPA,UAAAA,GAAqBjO,IAAI,GAAJA,KAAAA,GAArBiO,WAAAA;AACD;AACF;;AAED,QAAI,OAAA,MAAA,KAAJ,QAAA,EAAgC;AAC9B,UAAInJ,MAAM,GAANA,SAAAA,GAAJ,SAAA,EAAoC;AAElCmJ,QAAAA,OAAO,CAAPA,SAAAA,GAAoBnJ,MAAM,GAA1BmJ,SAAAA;AAFF,OAAA,MAGO,IAAI,CAACnJ,MAAM,GAAP,CAAA,IAAA,SAAA,GAA2BrB,SAAS,GAAxC,YAAA,EAAyD;AAE9DwK,QAAAA,OAAO,CAAPA,SAAAA,GAAoB,CAACnJ,MAAM,GAAP,CAAA,IAAA,SAAA,GAApBmJ,YAAAA;AACD;AACF;AACF;;AAED,WAAA,eAAA,CAAA,GAAA,EAAA,OAAA,EAAA,QAAA,EAAqF;AACnF,UAAM;AAAA,MAAA,GAAA;AAAOnJ,MAAAA;AAAP,QAAN,gBAAA;AACA,UAAMtK,GAAG,GAAGyI,IAAI,CAAhB,MAAgB,CAAhB;AACA,UAAMuH,aAAa,GAAGmD,kBAAkB,CAAlBA,gBAAkB,CAAlBA,IAAwClO,GAAG,KAAK,CAAtE,CAAA;;AAGA,QACE/B,GAAG,KAAHA,WAAAA,IAAAA,aAAAA,IAEG4F,UAAU,CAFb5F,GAEa,CAFbA,IAGG,CAAClD,GAAG,CAHPkD,UAAAA,IAIGlD,GAAG,CAAHA,KAAAA,KALL,CAAA,EAME;AACA,UAAIoX,YAAY,GAAG,CAAnB,CAAA;;AACA,WAAK,IAAI/Q,CAAC,GAAG8D,gBAAgB,CAAhBA,MAAAA,GAAb,CAAA,EAA0C9D,CAAC,IAA3C,CAAA,EAAkDA,CAAlD,EAAA,EAAuD;AACrD,cAAMgR,SAAS,GAAG5O,IAAI,CAAtB,CAAsB,CAAtB;;AACA,YAAIK,UAAU,CAAVA,SAAU,CAAVA,IAAyBuO,SAAS,CAATA,EAAAA,KAAiBrX,GAAG,CAAjD,QAAA,EAA4D;AAC1DoX,UAAAA,YAAY,GAAZA,CAAAA;AACA;AACD;AACF;;AACD,UAAIA,YAAY,KAAK,CAArB,CAAA,EAAyB;AACvB,eAAO;AAAA,UAAA,GAAA;AAAO9M,UAAAA,MAAM,EAAE8M;AAAf,SAAP;AACD;AACF;;AAED,YAAA,GAAA;AACE,WAAA,SAAA;AACE,eAAO;AAAA,UAAA,GAAA;AAAO9M,UAAAA,MAAM,EAAEA,MAAM,GAAG;AAAxB,SAAP;;AACF,WAAA,WAAA;AACE,eAAO;AAAA,UAAA,GAAA;AAAOA,UAAAA,MAAM,EAAEA,MAAM,GAAG;AAAxB,SAAP;;AACF,WAAA,WAAA;AACE,eAAO;AAAErF,UAAAA,GAAG,EAAEA,GAAG,GAAV,CAAA;AAAgBqF,UAAAA;AAAhB,SAAP;;AACF,WAAA,YAAA;AACE,eAAO;AAAErF,UAAAA,GAAG,EAAEA,GAAG,GAAV,CAAA;AAAgBqF,UAAAA;AAAhB,SAAP;;AACF,WAAA,KAAA;AACE,YAAIH,gBAAgB,CAAhBA,GAAAA,KAAyB,CAAzBA,CAAAA,IAA+BA,gBAAgB,CAAhBA,MAAAA,KAA4B,CAA/D,CAAA,EAAmE;AACjE,iBAAOU,QAAQ,GAAG;AAAE5F,YAAAA,GAAG,EAAEJ,OAAO,CAAPA,MAAAA,GAAP,CAAA;AAA2ByF,YAAAA,MAAM,EAAE7B,IAAI,CAAJA,MAAAA,GAAc;AAAjD,WAAH,GAA0D;AAAExD,YAAAA,GAAG,EAAL,CAAA;AAAUqF,YAAAA,MAAM,EAAE;AAAlB,WAAzE;AACD;;AACD,eAAO;AAAErF,UAAAA,GAAG,EAAEA,GAAG,IAAI4F,QAAQ,GAAG,CAAH,CAAA,GAAtB,CAAU,CAAV;AAAkCP,UAAAA;AAAlC,SAAP;;AACF,WAAA,MAAA;AAEE,YAAA,aAAA,EAAmB,OAAO;AAAA,UAAA,GAAA;AAAOA,UAAAA,MAAM,EAAE;AAAf,SAAP;AACnB,eAAOgN,OAAO,GAAG;AAAErS,UAAAA,GAAG,EAAL,CAAA;AAAUqF,UAAAA,MAAM,EAAE;AAAlB,SAAH,GAA2B;AAAErF,UAAAA,GAAG,EAAL,CAAA;AAAUqF,UAAAA;AAAV,SAAzC;;AACF,WAAA,KAAA;AAEE,YAAA,aAAA,EAAmB,OAAO;AAAA,UAAA,GAAA;AAAOA,UAAAA,MAAM,EAAE7B,IAAI,CAAJA,MAAAA,GAAc;AAA7B,SAAP;AACnB,eAAO6O,OAAO,GAAG;AAAErS,UAAAA,GAAG,EAAEJ,OAAO,CAAPA,MAAAA,GAAP,CAAA;AAA2ByF,UAAAA,MAAM,EAAE7B,IAAI,CAAJA,MAAAA,GAAc;AAAjD,SAAH,GAA0D;AAAExD,UAAAA,GAAG,EAAEJ,OAAO,CAAPA,MAAAA,GAAP,CAAA;AAA2ByF,UAAAA;AAA3B,SAAxE;;AACF,WAAA,QAAA;AACE,eAAO;AAAA,UAAA,GAAA;AAAOA,UAAAA,MAAM,EAAEA,MAAM,GAAG3D,IAAI,CAAJA,KAAAA,CAAWvF,YAAY,GAAvBuF,SAAAA;AAAxB,SAAP;;AACF,WAAA,UAAA;AACE,eAAO;AAAA,UAAA,GAAA;AAAO2D,UAAAA,MAAM,EAAEA,MAAM,GAAG3D,IAAI,CAAJA,KAAAA,CAAWvF,YAAY,GAAvBuF,SAAAA;AAAxB,SAAP;;AACF;AACE,eAAA,gBAAA;AA3BJ;AA6BD;;AAED,WAAA,QAAA,CAAA,KAAA,EAA8D;AAC5D,QAAIwD,gBAAgB,CAAhBA,IAAAA,KAAJ,MAAA,EAAsC;AAAA,UAAA,sBAAA,EAAA,sBAAA;;AACpC,YAAMoN,YAAY,GAAA,CAAA,sBAAA,GAAA,CAAA,sBAAA,GAAG1S,OAAO,CAACsF,gBAAgB,CAAxBtF,GAAO,CAAPA,CAAH,aAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAAGA,sBAAAA,CAAH,YAAA,KAAA,IAAA,GAAA,sBAAA,GAAlB,kBAAA;AACA,UAAI,CAAC0S,YAAY,CAAjB,KAAiB,CAAjB,EAA0B;AAC3B;;AACD,UAAM;AAAA,MAAA,GAAA;AAAO1M,MAAAA;AAAP,QAAN,KAAA;AACA,QAAI+G,IAAI,GAAR,kBAAA;;AACA,QAAI1O,GAAG,KAAP,KAAA,EAAmB;AAEjB,UAAIsU,WAAW,CAAC;AAAA,QAAA,QAAA;AAAA,QAAA,kBAAA;AAAA,QAAA,OAAA;AAAyC7M,QAAAA,SAAS,EAAElC,IAAI,CAAxD,MAAA;AAAiE0B,QAAAA;AAAjE,OAAD,CAAf,EAAsG;AACpGgM,QAAAA,mBAAmB;AAEnB;AACD;;AAEDvE,MAAAA,IAAI,GAAGvH,kBAAkB,KAAlBA,MAAAA,GAAAA,YAAAA,GAAPuH,kBAAAA;AAGD;;AAGDvO,IAAAA,KAAK,CAALA,cAAAA;AAEA,UAAMiU,OAAO,GAAG5C,iBAAiB,CAAjC,KAAiC,CAAjC;AACA,QAAItK,YAAY,GAAGqN,eAAe,CAAA,GAAA,EAAA,OAAA,EAAlC,QAAkC,CAAlC;AACArN,IAAAA,YAAY,GAAGsN,2BAA2B,CAAC;AAAA,MAAA,OAAA;AAEzC/M,MAAAA,SAAS,EAAElC,IAAI,CAF0B,MAAA;AAGzC4B,MAAAA,kBAAkB,EAHuB,IAAA;AAIzCD,MAAAA;AAJyC,KAAD,CAA1CA;AAOAqD,IAAAA,UAAU,CAAVA,YAAU,CAAVA;AACD;;AAED,WAAA,qBAAA,CAAA,aAAA,EAA0E;AACxE,QAAIkK,iBAAiB,KAArB,SAAA,EAAqC;AACrC,UAAM;AAAErN,MAAAA;AAAF,QAAN,gBAAA;AAEA,UAAMgD,aAAa,GAAGhD,MAAM,GAANA,iBAAAA,GAClBA,MAAM,GAANA,aAAAA,IAA0BsN,aAAa,IADrBtN,iBAAAA,GAElBA,MAAM,GAANA,aAAAA,IAA0BsN,aAAa,IAF3C,iBAAA;AAIA,WAAOtK,aAAa,GAAGnD,gBAAgB,CAAnB,GAAA,GAApB,SAAA;AACD;;AAED,WAAA,oBAAA,CAAA,MAAA,EAAgG;AAC9F,QAAIA,gBAAgB,CAAhBA,MAAAA,KAAJ,MAAA,EAAwC;;AAExC,QAAIA,gBAAgB,CAAhBA,IAAAA,KAAJ,MAAA,EAAsC;AACpC,aAAO;AACLyH,QAAAA,IAAI,EADC,MAAA;AAEL3M,QAAAA,GAAG,EAAEkF,gBAAgB,CAFhB,GAAA;AAGL0N,QAAAA,SAAS,EAHJ,aAAA;AAIL1H,QAAAA,WAAW,EAAE;AAAA,UAAA,kBAAA;AAAA,UAAA,SAAA;AAGXnQ,UAAAA,GAAG,EAAEmK,gBAAgB,CAHV,GAAA;AAIX+D,UAAAA,WAAW,EAJA,qBAAA;AAKX4J,UAAAA,OAAO,EAAEC;AALE;AAJR,OAAP;AAYD;;AAED,WAAO;AACLnG,MAAAA,IAAI,EADC,QAAA;AAEL3M,MAAAA,GAAG,EAAEkF,gBAAgB,CAFhB,GAAA;AAGL6N,MAAAA,OAAO,EAHF,WAAA;AAILH,MAAAA,SAAS,EAJJ,aAAA;AAKLxJ,MAAAA,eAAe,EAAE,qBAAqB,IAAIyH,cAAc,CAAvC,gBAAuC,CAAvC,GACb;AAAEmC,QAAAA,WAAW,EAAb,eAAA;AAAgClK,QAAAA,aAAa,EAAED;AAA/C,OADa,GAEba;AAPC,KAAP;AASD;;AAED,WAAA,eAAA,GAA2B;AACzB,UAAMuJ,WAAW,GAAjB,EAAA;AACA,QAAIlQ,aAAa,GAAjB,CAAA;;AACA,SAAK,IAAIsC,MAAM,GAAf,mBAAA,EAAuCA,MAAM,IAA7C,iBAAA,EAAoEA,MAApE,EAAA,EAA8E;AAC5E,YAAMtK,GAAG,GAAGyI,IAAI,CAAhB,MAAgB,CAAhB;AACA,YAAMyG,GAAG,GAAG5E,MAAM,GAANA,SAAAA,GAAZ,iBAAA;;AACA,UAAIxB,UAAU,CAAd,GAAc,CAAd,EAAqB;AACnB,SAAC;AAAEd,UAAAA;AAAF,YAAD,GAAA;AACAkQ,QAAAA,WAAW,CAAXA,IAAAA,EAAAA,aACE,GAAA,CAAA,gBAAA,EAAA;AACE,wBAAYlY,GAAG,CAAHA,KAAAA,GADd,CAAA;AAEE,0BAAcA,GAAG,CAFnB,OAAA;AAGE,2BAAeA,GAAG,CAAHA,QAAAA,GAHjB,CAAA;AAIE,2BAAesS,eAAe,GAAfA,aAAAA,GAJjB,CAAA;AAME,UAAA,EAAE,EAAEtS,GAAG,CANT,EAAA;AAOE,UAAA,QAAQ,EAAEA,GAAG,CAPf,QAAA;AAQE,UAAA,eAAe,EARjB,eAAA;AASE,UAAA,SAAS,EAAEA,GAAG,CAThB,SAAA;AAUE,UAAA,MAAM,EAVR,MAAA;AAWE,UAAA,GAAG,EAXL,GAAA;AAYE,UAAA,KAAK,EAAEA,GAAG,CAZZ,KAAA;AAaE,UAAA,UAAU,EAAEA,GAAG,CAbjB,UAAA;AAcE,UAAA,eAAe,EAAEmK,gBAAgB,CAAhBA,MAAAA,KAAAA,MAAAA,GAAqCA,gBAAgB,CAArDA,GAAAA,GAdnB,SAAA;AAeE,UAAA,aAAa,EAAEwI,YAAY,IAAI3S,GAAG,CAAHA,SAAAA,CAAAA,KAAAA,CAAoBmY,EAAE,IAAIvF,YAAJ,IAAA,IAAIA,GAAJ,KAAA,CAAIA,GAAAA,YAAY,CAAZA,GAAAA,CAAkBqB,YAAY,CAfzF,EAeyF,CAA9BrB,CAA1B5S,CAfjC;AAgBE,UAAA,OAAO,EAAEmK,gBAAgB,CAAhBA,MAAAA,KAAAA,MAAAA,GAAAA,WAAAA,GAhBX,SAAA;AAiBE,UAAA,SAAS,EAAEA,gBAAgB,CAAhBA,MAAAA,KAAAA,MAAAA,GAAAA,aAAAA,GAjBb,SAAA;AAkBE,UAAA,UAAU,EAlBZ,iBAAA;AAmBE,UAAA,SAAS,EAnBX,gBAAA;AAoBE,UAAA,WAAW,EAAEmG;AApBf,SAAA,EAKOtQ,GAAG,CANZkY,EACE,CADFA;AAwBA;AACD;;AAEDlQ,MAAAA,aAAa;AACb,UAAI9E,GAAc,GAAG6P,SAAS,GAAA,aAAA,GAA9B,MAAA;AACA,UAAI/C,aAAa,GAAjB,KAAA;;AACA,UAAI,OAAA,YAAA,KAAJ,UAAA,EAAwC;AAAA,YAAA,iBAAA;;AACtC9M,QAAAA,GAAG,GAAG+Q,YAAY,CAAlB/Q,GAAkB,CAAlBA;AACA8M,QAAAA,aAAa,GAAA,CAAA,iBAAA,GAAG4C,YAAH,IAAA,IAAGA,GAAH,KAAA,CAAGA,GAAAA,YAAY,CAAZA,GAAAA,CAAH,GAAGA,CAAH,KAAA,IAAA,GAAA,iBAAA,GAAb5C,KAAAA;AACD;;AAEDkI,MAAAA,WAAW,CAAXA,IAAAA,EAAAA,aACE,GAAA,CAAA,WAAA,EAAA;AACE,yBAAe5F,eAAe,IAAIS,SAAS,GAAA,aAAA,GAA5BT,MAAe,CAAfA,GADjB,CAAA;AAEE,yBAAeK,YAAY,GAAA,aAAA,GAF7B,SAAA;AAIE,QAAA,MAAM,EAJR,MAAA;AAKE,QAAA,GAAG,EALL,GAAA;AAME,QAAA,eAAe,EANjB,eAAA;AAOE,QAAA,aAAa,EAPf,aAAA;AAQE,QAAA,UAAU,EARZ,UAAA;AASE,QAAA,QAAQ,EATV,QAAA;AAUE,QAAA,GAAG,EAVL,GAAA;AAWE,QAAA,aAAa,EAAEkD,UAAU,KAAVA,IAAAA,IAAuBA,UAAU,CAAVA,GAAAA,KAAvBA,GAAAA,GAAgDhR,OAAO,CAAPA,SAAAA,CAAkBuT,CAAC,IAAIA,CAAC,CAADA,GAAAA,KAAUvC,UAAU,CAA3FA,SAAgDhR,CAAhDgR,GAXjB,SAAA;AAYE,QAAA,kBAAkB,EAAEwC,qBAAqB,CAZ3C,MAY2C,CAZ3C;AAaE,QAAA,oBAAoB,EAAEC,UAAU,GAAA,oBAAA,GAblC,SAAA;AAcE,QAAA,iBAAiB,EAAEC,oBAAoB,CAdzC,MAcyC,CAdzC;AAeE,QAAA,WAAW,EAfb,+BAAA;AAgBE,QAAA,UAAU,EAhBZ,iBAAA;AAiBE,QAAA,SAAS,EAAErG;AAjBb,OAAA,EADFgG,GACE,CADFA;AAqBD;;AAED,WAAA,WAAA;AACD;;AAGD,MAAI/N,gBAAgB,CAAhBA,GAAAA,IAAwBtF,OAAO,CAA/BsF,MAAAA,IAA0CA,gBAAgB,CAAhBA,MAAAA,IAA2B1B,IAAI,CAA7E,MAAA,EAAsF;AACpF8L,IAAAA,mBAAmB,CAAC;AAAEtP,MAAAA,GAAG,EAAE,CAAP,CAAA;AAAWqF,MAAAA,MAAM,EAAE,CAAnB,CAAA;AAAuBsH,MAAAA,IAAI,EAAE;AAA7B,KAAD,CAAnB2C;AACAzE,IAAAA,oBAAoB,CAApBA,SAAoB,CAApBA;AACD;;AAED,MAAI3F,gBAAgB,CAAhBA,IAAAA,KAAAA,MAAAA,IAAoC1B,IAAI,CAAC0B,gBAAgB,CAArB1B,MAAI,CAAJA,KAAkC0B,gBAAgB,CAA1F,WAAA,EAAwG;AAEtG6K,IAAAA,WAAW;AACZ;;AAED,SAAA,aACE,IAAA,CAAA,KAAA,EAAA;AACE,IAAA,IAAI,EAAEjC,SAAS,GAAA,UAAA,GADjB,MAAA;AAEE,kBAFF,SAAA;AAGE,uBAHF,cAAA;AAIE,wBAJF,eAAA;AAKE,4BAAsBJ,YAAY,GAAA,IAAA,GALpC,SAAA;AAME,qBAAe9N,OAAO,CANxB,MAAA;AAOE,qBAAeyN,eAAe,GAAfA,SAAAA,GAPjB,gBAAA;AAQE,IAAA,SAAS,EAAE/P,IAAI,CAAA,aAAA,EAAA,SAAA,EAA+C+V,UAA/C,IARjB,yBAQiB,CARjB;AASE,IAAA,KAAK,EAAE,EACL,GADK,KAAA;AAEL,6BAAwB,GAAEnH,eAFrB,IAAA;AAGL,6BAAwB,GAAEC,mBAHrB,IAAA;AAIL,qBAAgB,GAAE3L,gBAJb,IAAA;AAKL,sBAAiB,GAAEyL,SALd,IAAA;AAML,8BAAyB,GAAEG,gBANtB,IAAA;AAOL,SAAGjL;AAPE,KATT;AAkBE,IAAA,GAAG,EAlBL,OAAA;AAmBE,IAAA,QAAQ,EAnBV,YAAA;AAAA,IAAA,QAAA,EAAA,CAAA,aAqBE,GAAA,CAAA,WAAA,EAAA;AACE,MAAA,YAAY,EADd,YAAA;AAEE,MAAA,IAAI,EAFN,OAAA;AAGE,MAAA,OAAO,EAHT,eAAA;AAIE,MAAA,cAAc,EAJhB,kBAAA;AAKE,MAAA,eAAe,EAAE,CAAA,YAAY,IAAZ,IAAA,GAAA,KAAA,CAAA,GAAA,YAAY,CAAZ,IAAA,MAAuBoB,OAAO,CALjD,MAAA;AAME,MAAA,oBAAoB,EANtB,oBAAA;AAOE,MAAA,UAAU,EAPZ,UAAA;AAQE,MAAA,aAAa,EARf,aAAA;AASE,MAAA,MAAM,EAAEsC;AATV,KAAA,CArBF,EAgCG2H,eAAe,IAAA,aACd,GAAA,CAAA,WAAA,EAAA;AACE,MAAA,OAAO,EADT,eAAA;AAEE,MAAA,OAAO,EAFT,OAAA;AAGE,MAAA,eAAe,EAAEhF;AAHnB,KAAA,CAjCJ,EAuCGhE,IAAI,CAAJA,MAAAA,KAAAA,CAAAA,IAAAA,iBAAAA,GAAAA,aAAyC+P,GAAAA,CAAAA,iBAAAA,EAAzC/P,EAAyC+P,CAAzC/P,GAAAA,aACC,IAAA,CAAA,QAAA,EAAA;AAAA,MAAA,QAAA,EAAA,CAAA,aACE,GAAA,CAAA,KAAA,EAAA;AACE,QAAA,GAAG,EADL,YAAA;AAEE,QAAA,QAAQ,EAFV,CAAA;AAGE,QAAA,SAAS,EAHX,kBAAA;AAIE,QAAA,SAAS,EAJX,aAAA;AAKE,QAAA,OAAO,EAAEgQ;AALX,OAAA,CADF,EAAA,aAQE,GAAA,CAAA,KAAA,EAAA;AAAK,QAAA,KAAK,EAAE;AAAEC,UAAAA,MAAM,EAAE/R,IAAI,CAAJA,GAAAA,CAAS8B,IAAI,CAAJA,MAAAA,GAAT9B,SAAAA,EAAAA,YAAAA;AAAV;AAAZ,OAAA,CARF,EASGgS,eATH,EAAA,EAUG,WAVH,IAAA,IAUG,GAVH,KAAA,CAUG,GAAA,WAAW,CAAX,GAAA,CAAiB,CAAA,GAAA,EAAA,MAAA,KAAA,aAChB,GAAA,CAAA,YAAA,EAAA;AACE,yBAAerG,eAAe,GAAfA,SAAAA,GAAAA,MAAAA,GADjB,CAAA;AAGE,QAAA,MAAM,EAHR,MAAA;AAIE,QAAA,GAAG,EAJL,GAAA;AAKE,QAAA,MAAM,EAAEjB,gBAAgB,IAAImB,WAAW,CAAXA,MAAAA,GAAAA,CAAAA,GAL9B,MAK0B,CAL1B;AAME,QAAA,eAAe,EAAExL;AANnB,OAAA,EAXJ,MAWI,CADD,CAVH;AAAA,KAAA,CAxCJ;AAAA,GAAA,CADF;AAiED;;AAED,MAAA,UAAA,GAAA,aAAesH,UAAU,CAAzB,QAAyB,CAAzB;;;AC38BA,MAAMsK,UAAU,GAAhB,sBAAA;AA0BO,MAAMC,mBAAmB,GAAA,mBAAsBD,UAA/C,EAAA;;AAEP,SAAA,kBAAA,CAAA,KAAA,EAA4D;AAC1DE,EAAAA,KAAK,IAALA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,KAAK,CAALA,KAAAA,EAAAA;AACAA,EAAAA,KAAK,IAALA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,KAAK,CAALA,MAAAA,EAAAA;;;AAGa,SAAA,UAAA,CAAiD;AAAA,EAAA,GAAA;AAAA,EAAA,MAAA;AAAA,EAAA,WAAA;AAI9DhB,EAAAA;AAJ8D,CAAjD,EAKoB;sBAE/B,GAAA,CAAA,OAAA,EAAA;AACE,IAAA,SAAA,EADF,mBAAA;AAEE,IAAA,GAAA,EAFF,kBAAA;AAGE,IAAA,KAAA,EAAO9X,GAAG,CAACgF,MAAM,CAHnB,GAGY,CAHZ;AAIE,IAAA,QAAA,EAAU3B,KAAK,IAAI6K,WAAW,CAAC,EAAE,GAAF,GAAA;OAAWlJ,MAAM,CAAC9B,G,GAAMG,KAAK,CAALA,MAAAA,CAAauJ;AAArC,KAAD,CAJhC;AAKE,IAAA,MAAA,EAAQ,MAAMkL,OAAO,CAAA,IAAA;AALvB,GAAA,C","sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import { css } from '@linaria/core';\n\nexport const cell = css`\n  contain: strict;\n  contain: size layout style paint;\n  padding: 0 8px;\n  border-right: 1px solid var(--border-color);\n  border-bottom: 1px solid var(--border-color);\n  background-color: inherit;\n\n  white-space: nowrap;\n  overflow: hidden;\n  overflow: clip;\n  text-overflow: ellipsis;\n`;\n\nexport const cellClassname = `rdg-cell ${cell}`;\n\nconst cellFrozen = css`\n  position: sticky;\n  // Should have a higher value than 0 to show up above unfrozen cells\n  z-index: 1;\n`;\n\nexport const cellFrozenClassname = `rdg-cell-frozen ${cellFrozen}`;\n\nexport const cellFrozenLast = css`\n  box-shadow: 2px 0 5px -2px rgba(136, 136, 136, .3);\n`;\n\nexport const cellFrozenLastClassname = `rdg-cell-frozen-last ${cellFrozenLast}`;\n\nconst cellSelected = css`\n  box-shadow: inset 0 0 0 2px var(--selection-color);\n`;\n\nexport const cellSelectedClassname = `rdg-cell-selected ${cellSelected}`;\n","import { css } from '@linaria/core';\nimport { row } from './row';\n\nconst lightTheme = `\n  --color: #000;\n  --border-color: #ddd;\n  --summary-border-color: #aaa;\n  --background-color: hsl(0deg 0% 100%);\n  --header-background-color: hsl(0deg 0% 97.5%);\n  --row-hover-background-color: hsl(0deg 0% 96%);\n  --row-selected-background-color: hsl(207deg 76% 92%);\n  --row-selected-hover-background-color: hsl(207deg 76% 88%);\n\n  --checkbox-color: hsl(207deg 100% 29%);\n  --checkbox-focus-color: hsl(207deg 100% 69%);\n  --checkbox-disabled-border-color: #ccc;\n  --checkbox-disabled-background-color: #ddd;\n`;\n\nconst darkTheme = `\n  --color: #ddd;\n  --border-color: #444;\n  --summary-border-color: #555;\n  --background-color: hsl(0deg 0% 13%);\n  --header-background-color: hsl(0deg 0% 10.5%);\n  --row-hover-background-color: hsl(0deg 0% 9%);\n  --row-selected-background-color: hsl(207deg 76% 42%);\n  --row-selected-hover-background-color: hsl(207deg 76% 38%);\n\n  --checkbox-color: hsl(207deg 100% 79%);\n  --checkbox-focus-color: hsl(207deg 100% 89%);\n  --checkbox-disabled-border-color: #000;\n  --checkbox-disabled-background-color: #333;\n`;\n\nconst root = css`\n  ${lightTheme}\n  --selection-color: #66afe9;\n  --font-size: 14px;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  // We set a stacking context so internal elements don't render on top of external components.\n  contain: strict;\n  contain: size layout style paint;\n  content-visibility: auto;\n  height: 350px;\n  border: 1px solid var(--border-color);\n  box-sizing: border-box;\n  overflow: auto;\n  user-select: none;\n  background-color: var(--background-color);\n  color: var(--color);\n  font-size: var(--font-size);\n\n  // set stacking context in safari\n  @supports not (contain: strict) {\n    position: relative;\n    z-index: 0;\n  }\n\n  *,\n  *::before,\n  *::after {\n    box-sizing: inherit;\n  }\n\n  &.rdg-dark {\n    ${darkTheme}\n  }\n\n  @media (prefers-color-scheme: dark) {\n    &:not(.rdg-light) {\n      ${darkTheme}\n    }\n  }\n`;\n\nexport const rootClassname = `rdg ${root}`;\n\nconst focusSink = css`\n  position: sticky;\n  top: 0;\n  left: 0;\n  height: 0;\n  width: 0;\n  outline: 0;\n`;\n\nexport const focusSinkClassname = `rdg-focus-sink ${focusSink}`;\n\nconst viewportDragging = css`\n  &.${row} {\n    cursor: move;\n  }\n`;\n\nexport const viewportDraggingClassname = `rdg-viewport-dragging ${viewportDragging}`;\n","import { css } from '@linaria/core';\nimport { rowSelected } from './row';\nimport { cell, cellFrozenLast } from './cell';\n\nconst groupRow = css`\n  &:not(.${rowSelected}) {\n    background-color: var(--header-background-color);\n  }\n\n  > .${cell}:not(:last-child):not(.${cellFrozenLast}) {\n    border-right: none;\n  }\n`;\n\nexport const groupRowClassname = `rdg-group-row ${groupRow}`;\n\nconst groupRowSelected = css`\n  &::after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    box-shadow: inset 0 0 0 2px var(--selection-color);\n    pointer-events: none;\n    z-index: 2;\n  }\n\n  > .${cell}:first-child {\n    // preserve left border on the first frozen cell after scrolling to the right\n    box-shadow: inset 2px 0 0 0 var(--selection-color);\n  }\n`;\n\n// TODO: rename class\nexport const groupRowSelectedClassname = `rdg-group-row-selected ${groupRowSelected}`;\n","import { css } from '@linaria/core';\n\nconst headerRowAndFilterRow = css`\n  contain: strict;\n  contain: size layout style paint;\n  display: grid;\n  grid-template-columns: var(--template-columns);\n  width: var(--row-width);\n  position: sticky;\n  background-color: var(--header-background-color);\n  font-weight: bold;\n  z-index: 3;\n`;\n\nconst headerRow = css`\n  grid-template-rows: var(--header-row-height);\n  height: var(--header-row-height); // needed on Firefox\n  line-height: var(--header-row-height);\n  top: 0;\n  touch-action: none;\n`;\n\nexport const headerRowClassname = `rdg-header-row ${headerRowAndFilterRow} ${headerRow}`;\n\nconst filterRow = css`\n  grid-template-rows: var(--filter-row-height);\n  height: var(--filter-row-height); // needed on Firefox\n  line-height: var(--filter-row-height);\n  top: var(--header-row-height);\n`;\n\nexport const filterRowClassname = `rdg-filter-row ${headerRowAndFilterRow} ${filterRow}`;\n","import { css } from '@linaria/core';\nimport { cell } from './cell';\n\nexport const row = css`\n  contain: strict;\n  contain: size layout style paint;\n  display: grid;\n  grid-template-rows: var(--row-height);\n  grid-template-columns: var(--template-columns);\n  position: absolute;\n  left: 0;\n  width: var(--row-width);\n  height: var(--row-height); // needed on Firefox\n  line-height: var(--row-height);\n  background-color: var(--background-color);\n\n  &:hover {\n    background-color: var(--row-hover-background-color);\n  }\n`;\n\nexport const rowClassname = `rdg-row ${row}`;\n\nexport const rowSelected = css`\n  background-color: var(--row-selected-background-color);\n\n  &:hover {\n    background-color: var(--row-selected-hover-background-color);\n  }\n`;\n\nexport const rowSelectedClassname = `rdg-row-selected ${rowSelected}`;\n\nconst summaryRow = css`\n  position: sticky;\n  z-index: 3;\n  grid-template-rows: var(--summary-row-height);\n  height: var(--summary-row-height); // needed on Firefox\n  line-height: var(--summary-row-height);\n\n  > .${cell} {\n    border-top: 2px solid var(--summary-border-color);\n  }\n`;\n\nexport const summaryRowClassname = `rdg-summary-row ${summaryRow}`;\n","import { useRef, useEffect } from 'react';\n\n/**\n * Detecting outside click on a react component is surprisingly hard.\n * A general approach is to have a global click handler on the document\n * which checks if the click target is inside the editor container or\n * not using editorContainer.contains(e.target). This approach works well\n * until portals are used for editors. Portals render children into a DOM\n * node that exists outside the DOM hierarchy of the parent component so\n * editorContainer.contains(e.target) does not work. Here are some examples\n * of the DOM structure with different types of editors\n *\n *\n * SimpleEditor for example Texbox (No Portals)\n *   <div data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        <div simple-editor>..</div>\n *      </div>\n *   </div>\n *\n * ComplexEditor for example Modals (using Portals)\n *   <div data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        // Nothing here\n *      </div>\n *   </div>\n *   <div portal-created-by-the-editor>\n *     <div complex-editor>..</div>\n *   </div>\n *\n *\n * One approach to detect outside click is to use synthetic event bubbling through\n * portals. An event fired from inside a portal will propagate to ancestors\n * in the containing React tree, even if those elements are not ancestors\n * in the DOM tree. This means a click handler can be attached on the window\n * and on the editor container. The editor container can set a flag to notify\n * that the click was inside the editor and the window click handler can use\n * this flag to call onClickOutside. This approach however has a few caveats\n * - Click handler on the window is set using window.addEventListener\n * - Click handler on the editor container is set using onClick prop\n *\n * This means if a child component inside the editor calls e.stopPropagation\n * then the click handler on the editor container will not be called whereas\n * the document click handler will be called.\n * https://github.com/facebook/react/issues/12518\n *\n * To solve this issue onClickCapture event is used.\n */\n\nexport function useClickOutside(onClick: () => void) {\n  const frameRequestRef = useRef<number | undefined>();\n\n  function cancelAnimationFrameRequest() {\n    if (typeof frameRequestRef.current === 'number') {\n      cancelAnimationFrame(frameRequestRef.current);\n      frameRequestRef.current = undefined;\n    }\n  }\n\n  // We need to prevent the `useEffect` from cleaning up between re-renders,\n  // as `handleDocumentClick` might otherwise miss valid click events.\n  // To that end we instead access the latest `onClick` prop via a ref.\n  const onClickRef = useRef((): void => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    onClickRef.current = onClick;\n  });\n\n  useEffect(() => {\n    function onOutsideClick() {\n      frameRequestRef.current = undefined;\n      onClickRef.current();\n    }\n\n    function onWindowCaptureClick() {\n      cancelAnimationFrameRequest();\n      frameRequestRef.current = requestAnimationFrame(onOutsideClick);\n    }\n\n    window.addEventListener('click', onWindowCaptureClick, { capture: true });\n\n    return () => {\n      window.removeEventListener('click', onWindowCaptureClick, { capture: true });\n      cancelAnimationFrameRequest();\n    };\n  }, []);\n\n  return cancelAnimationFrameRequest;\n}\n","import { useRef, useState, useLayoutEffect } from 'react';\n\nexport function useGridDimensions(): [ref: React.RefObject<HTMLDivElement>, width: number, height: number] {\n  const gridRef = useRef<HTMLDivElement>(null);\n  const [gridWidth, setGridWidth] = useState(1);\n  const [gridHeight, setGridHeight] = useState(1);\n\n  useLayoutEffect(() => {\n    const { ResizeObserver } = window;\n\n    // don't break in jest/jsdom and browsers that don't support ResizeObserver\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (ResizeObserver == null) return;\n\n    const resizeObserver = new ResizeObserver(() => {\n      // Get dimensions without scrollbars.\n      // The dimensions given by the callback entries in Firefox do not substract the scrollbar sizes.\n      const { clientWidth, clientHeight } = gridRef.current!;\n      setGridWidth(clientWidth);\n      setGridHeight(clientHeight);\n    });\n\n    resizeObserver.observe(gridRef.current!);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  return [gridRef, gridWidth, gridHeight];\n}\n","import { useRef, useLayoutEffect } from 'react';\n\nexport function useFocusRef<T extends HTMLOrSVGElement>(isCellSelected: boolean | undefined) {\n  const ref = useRef<T>(null);\n  useLayoutEffect(() => {\n    if (!isCellSelected) return;\n    ref.current?.focus({ preventScroll: true });\n  }, [isCellSelected]);\n\n  return ref;\n}\n","import clsx from 'clsx';\nimport { css } from '@linaria/core';\nimport { useFocusRef } from '../hooks/useFocusRef';\n\nconst checkboxLabel = css`\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  margin-right: 1px; // align checkbox in row group cell\n`;\n\nconst checkboxLabelClassname = `rdg-checkbox-label ${checkboxLabel}`;\n\nconst checkboxInput = css`\n  all: unset;\n  width: 0;\n  margin: 0;\n`;\n\nconst checkboxInputClassname = `rdg-checkbox-input ${checkboxInput}`;\n\nconst checkbox = css`\n  content: '';\n  width: 20px;\n  height: 20px;\n  border: 2px solid var(--border-color);\n  background-color: var(--background-color);\n\n  .${checkboxInput}:checked + & {\n    background-color: var(--checkbox-color);\n    box-shadow: inset 0px 0px 0px 4px var(--background-color);\n  }\n\n  .${checkboxInput}:focus + & {\n    border-color: var(--checkbox-focus-color);\n  }\n`;\n\nconst checkboxClassname = `rdg-checkbox ${checkbox}`;\n\nconst checkboxLabelDisabled = css`\n  cursor: default;\n\n  .${checkbox} {\n    border-color: var(--checkbox-disabled-border-color);\n    background-color: var(--checkbox-disabled-background-color);\n  }\n`;\n\nconst checkboxLabelDisabledClassname = `rdg-checkbox-label-disabled ${checkboxLabelDisabled}`;\n\ntype SharedInputProps = Pick<React.InputHTMLAttributes<HTMLInputElement>,\n  | 'disabled'\n  | 'tabIndex'\n  | 'onClick'\n  | 'aria-label'\n  | 'aria-labelledby'\n>;\n\ninterface SelectCellFormatterProps extends SharedInputProps {\n  isCellSelected?: boolean;\n  value: boolean;\n  onChange: (value: boolean, isShiftClick: boolean) => void;\n}\n\nexport function SelectCellFormatter({\n  value,\n  tabIndex,\n  isCellSelected,\n  disabled,\n  onClick,\n  onChange,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy\n}: SelectCellFormatterProps) {\n  const inputRef = useFocusRef<HTMLInputElement>(isCellSelected);\n\n  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {\n    onChange(e.target.checked, (e.nativeEvent as MouseEvent).shiftKey);\n  }\n\n  return (\n    <label className={clsx(checkboxLabelClassname, { [checkboxLabelDisabledClassname]: disabled })}>\n      <input\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        tabIndex={tabIndex}\n        ref={inputRef}\n        type=\"checkbox\"\n        className={checkboxInputClassname}\n        disabled={disabled}\n        checked={value}\n        onChange={handleChange}\n        onClick={onClick}\n      />\n      <div className={checkboxClassname} />\n    </label>\n  );\n}\n","import type { FormatterProps } from '../types';\n\nexport function ValueFormatter<R, SR>(props: FormatterProps<R, SR>) {\n  try {\n    return <>{props.row[props.column.key as keyof R]}</>;\n  } catch {\n    return null;\n  }\n}\n","import { css } from '@linaria/core';\nimport type { GroupFormatterProps } from '../types';\nimport { useFocusRef } from '../hooks/useFocusRef';\n\nconst groupCellContent = css`\n  outline: none;\n`;\n\nconst groupCellContentClassname = `rdg-group-cell-content ${groupCellContent}`;\n\nconst caret = css`\n  margin-left: 4px;\n  stroke: currentColor;\n  stroke-width: 1.5px;\n  fill: transparent;\n  vertical-align: middle;\n\n  > path {\n    transition: d .1s;\n  }\n`;\n\nconst caretClassname = `rdg-caret ${caret}`;\n\nexport function ToggleGroupFormatter<R, SR>({\n  groupKey,\n  isExpanded,\n  isCellSelected,\n  toggleGroup\n}: GroupFormatterProps<R, SR>) {\n  const cellRef = useFocusRef<HTMLSpanElement>(isCellSelected);\n\n  function handleKeyDown({ key }: React.KeyboardEvent<HTMLSpanElement>) {\n    if (key === 'Enter') {\n      toggleGroup();\n    }\n  }\n\n  const d = isExpanded ? 'M1 1 L 7 7 L 13 1' : 'M1 7 L 7 1 L 13 7';\n\n  return (\n    <span\n      ref={cellRef}\n      className={groupCellContentClassname}\n      tabIndex={-1}\n      onKeyDown={handleKeyDown}\n    >\n      {groupKey}\n      <svg viewBox=\"0 0 14 8\" width=\"14\" height=\"8\" className={caretClassname}>\n        <path d={d} />\n      </svg>\n    </span>\n  );\n}\n","export function stopPropagation(event: React.SyntheticEvent) {\n  event.stopPropagation();\n}\n","import { SelectCellFormatter } from './formatters';\nimport type { Column } from './types';\nimport { stopPropagation } from './utils/domUtils';\n\nexport const SELECT_COLUMN_KEY = 'select-row';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const SelectColumn: Column<any, any> = {\n  key: SELECT_COLUMN_KEY,\n  name: '',\n  width: 35,\n  maxWidth: 35,\n  resizable: false,\n  sortable: false,\n  frozen: true,\n  headerRenderer(props) {\n    return (\n      <SelectCellFormatter\n        aria-label=\"Select All\"\n        value={props.allRowsSelected}\n        onChange={props.onAllRowsSelectionChange}\n      />\n    );\n  },\n  formatter(props) {\n    return (\n      <SelectCellFormatter\n        aria-label=\"Select\"\n        tabIndex={-1}\n        isCellSelected={props.isCellSelected}\n        value={props.isRowSelected}\n        onClick={stopPropagation}\n        onChange={props.onRowSelectionChange}\n      />\n    );\n  },\n  groupFormatter(props) {\n    return (\n      <SelectCellFormatter\n        aria-label=\"Select Group\"\n        tabIndex={-1}\n        isCellSelected={props.isCellSelected}\n        value={props.isRowSelected}\n        onChange={props.onRowSelectionChange}\n        // Stop propagation to prevent row selection\n        onClick={stopPropagation}\n      />\n    );\n  }\n};\n","import { useMemo } from 'react';\n\nimport type { CalculatedColumn, Column, ColumnMetric } from '../types';\nimport type { DataGridProps } from '../DataGrid';\nimport { ValueFormatter, ToggleGroupFormatter } from '../formatters';\nimport { SELECT_COLUMN_KEY } from '../Columns';\n\ninterface ViewportColumnsArgs<R, SR> extends Pick<DataGridProps<R, SR>, 'defaultColumnOptions'> {\n  rawColumns: readonly Column<R, SR>[];\n  rawGroupBy?: readonly string[];\n  viewportWidth: number;\n  scrollLeft: number;\n  columnWidths: ReadonlyMap<string, number>;\n}\n\nexport function useViewportColumns<R, SR>({\n  rawColumns,\n  columnWidths,\n  viewportWidth,\n  scrollLeft,\n  defaultColumnOptions,\n  rawGroupBy\n}: ViewportColumnsArgs<R, SR>) {\n  const minColumnWidth = defaultColumnOptions?.minWidth ?? 80;\n  const defaultFormatter = defaultColumnOptions?.formatter ?? ValueFormatter;\n  const defaultSortable = defaultColumnOptions?.sortable ?? false;\n  const defaultResizable = defaultColumnOptions?.resizable ?? false;\n\n  const { columns, lastFrozenColumnIndex, groupBy } = useMemo(() => {\n    // Filter rawGroupBy and ignore keys that do not match the columns prop\n    const groupBy: string[] = [];\n    let lastFrozenColumnIndex = -1;\n\n    const columns = rawColumns.map(rawColumn => {\n      const rowGroup = rawGroupBy?.includes(rawColumn.key) ?? false;\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      const frozen = rowGroup || rawColumn.frozen || false;\n\n      const column: CalculatedColumn<R, SR> = {\n        ...rawColumn,\n        idx: 0,\n        frozen,\n        isLastFrozenColumn: false,\n        rowGroup,\n        sortable: rawColumn.sortable ?? defaultSortable,\n        resizable: rawColumn.resizable ?? defaultResizable,\n        formatter: rawColumn.formatter ?? defaultFormatter\n      };\n\n      if (rowGroup) {\n        column.groupFormatter ??= ToggleGroupFormatter;\n      }\n\n      if (frozen) {\n        lastFrozenColumnIndex++;\n      }\n\n      return column;\n    });\n\n    columns.sort(({ key: aKey, frozen: frozenA }, { key: bKey, frozen: frozenB }) => {\n      // Sort select column first:\n      if (aKey === SELECT_COLUMN_KEY) return -1;\n      if (bKey === SELECT_COLUMN_KEY) return 1;\n\n      // Sort grouped columns second, following the groupBy order:\n      if (rawGroupBy?.includes(aKey)) {\n        if (rawGroupBy.includes(bKey)) {\n          return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n        }\n        return -1;\n      }\n      if (rawGroupBy?.includes(bKey)) return 1;\n\n      // Sort frozen columns third:\n      if (frozenA) {\n        if (frozenB) return 0;\n        return -1;\n      }\n      if (frozenB) return 1;\n\n      // Sort other columns last:\n      return 0;\n    });\n\n    columns.forEach((column, idx) => {\n      column.idx = idx;\n\n      if (column.rowGroup) {\n        groupBy.push(column.key);\n      }\n    });\n\n    if (lastFrozenColumnIndex !== -1) {\n      columns[lastFrozenColumnIndex].isLastFrozenColumn = true;\n    }\n\n    return {\n      columns,\n      lastFrozenColumnIndex,\n      groupBy\n    };\n  }, [rawColumns, defaultFormatter, defaultResizable, defaultSortable, rawGroupBy]);\n\n  const { layoutCssVars, totalColumnWidth, totalFrozenColumnWidth, columnMetrics } = useMemo(() => {\n    const columnMetrics = new Map<CalculatedColumn<R, SR>, ColumnMetric>();\n    let left = 0;\n    let totalColumnWidth = 0;\n    let totalFrozenColumnWidth = 0;\n    let templateColumns = '';\n    let allocatedWidth = 0;\n    let unassignedColumnsCount = 0;\n\n    for (const column of columns) {\n      let width = getSpecifiedWidth(column, columnWidths, viewportWidth);\n\n      if (width === undefined) {\n        unassignedColumnsCount++;\n      } else {\n        width = clampColumnWidth(width, column, minColumnWidth);\n        allocatedWidth += width;\n        columnMetrics.set(column, { width, left: 0 });\n      }\n    }\n\n    const unallocatedWidth = viewportWidth - allocatedWidth;\n    const unallocatedColumnWidth = unallocatedWidth / unassignedColumnsCount;\n\n    for (const column of columns) {\n      let width;\n      if (columnMetrics.has(column)) {\n        const columnMetric = columnMetrics.get(column)!;\n        columnMetric.left = left;\n        ({ width } = columnMetric);\n      } else {\n        width = clampColumnWidth(unallocatedColumnWidth, column, minColumnWidth);\n        columnMetrics.set(column, { width, left });\n      }\n      totalColumnWidth += width;\n      left += width;\n      templateColumns += `${width}px `;\n    }\n\n    if (lastFrozenColumnIndex !== -1) {\n      const columnMetric = columnMetrics.get(columns[lastFrozenColumnIndex])!;\n      totalFrozenColumnWidth = columnMetric.left + columnMetric.width;\n    }\n\n    const layoutCssVars: Record<string, string> = {\n      '--template-columns': templateColumns\n    };\n\n    for (let i = 0; i <= lastFrozenColumnIndex; i++) {\n      const column = columns[i];\n      layoutCssVars[`--frozen-left-${column.key}`] = `${columnMetrics.get(column)!.left}px`;\n    }\n\n    return { layoutCssVars, totalColumnWidth, totalFrozenColumnWidth, columnMetrics };\n  }, [columnWidths, columns, viewportWidth, minColumnWidth, lastFrozenColumnIndex]);\n\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo((): [number, number] => {\n    // get the viewport's left side and right side positions for non-frozen columns\n    const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    const viewportRight = scrollLeft + viewportWidth;\n    // get first and last non-frozen column indexes\n    const lastColIdx = columns.length - 1;\n    const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n    // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    }\n\n    // get the first visible non-frozen column index\n    let colVisibleStartIdx = firstUnfrozenColumnIdx;\n    while (colVisibleStartIdx < lastColIdx) {\n      const { left, width } = columnMetrics.get(columns[colVisibleStartIdx])!;\n      // if the right side of the columnn is beyond the left side of the available viewport,\n      // then it is the first column that's at least partially visible\n      if (left + width > viewportLeft) {\n        break;\n      }\n      colVisibleStartIdx++;\n    }\n\n    // get the last visible non-frozen column index\n    let colVisibleEndIdx = colVisibleStartIdx;\n    while (colVisibleEndIdx < lastColIdx) {\n      const { left, width } = columnMetrics.get(columns[colVisibleEndIdx])!;\n      // if the right side of the column is beyond or equal to the right side of the available viewport,\n      // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n      if (left + width >= viewportRight) {\n        break;\n      }\n      colVisibleEndIdx++;\n    }\n\n    const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [columns, columnMetrics, lastFrozenColumnIndex, scrollLeft, totalFrozenColumnWidth, viewportWidth]);\n\n  const viewportColumns = useMemo((): readonly CalculatedColumn<R, SR>[] => {\n    const viewportColumns: CalculatedColumn<R, SR>[] = [];\n    for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      const column = columns[colIdx];\n\n      if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n\n  return { columns, viewportColumns, layoutCssVars, columnMetrics, totalColumnWidth, lastFrozenColumnIndex, totalFrozenColumnWidth, groupBy };\n}\n\nfunction getSpecifiedWidth<R, SR>(\n  { key, width }: Column<R, SR>,\n  columnWidths: ReadonlyMap<string, number>,\n  viewportWidth: number\n): number | undefined {\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n  if (typeof width === 'number') {\n    return width;\n  }\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n  return undefined;\n}\n\nfunction clampColumnWidth<R, SR>(\n  width: number,\n  { minWidth, maxWidth }: Column<R, SR>,\n  minColumnWidth: number\n): number {\n  width = Math.max(width, minWidth ?? minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n}\n","import { useMemo } from 'react';\nimport type { GroupRow, GroupByDictionary } from '../types';\n\nconst RENDER_BACTCH_SIZE = 8;\n\ninterface ViewportRowsArgs<R> {\n  rawRows: readonly R[];\n  rowHeight: number;\n  clientHeight: number;\n  scrollTop: number;\n  groupBy: readonly string[];\n  rowGrouper?: (rows: readonly R[], columnKey: string) => Record<string, readonly R[]>;\n  expandedGroupIds?: ReadonlySet<unknown>;\n}\n\n// https://github.com/microsoft/TypeScript/issues/41808\nfunction isReadonlyArray(arr: unknown): arr is readonly unknown[] {\n  return Array.isArray(arr);\n}\n\nexport function useViewportRows<R>({\n  rawRows,\n  rowHeight,\n  clientHeight,\n  scrollTop,\n  groupBy,\n  rowGrouper,\n  expandedGroupIds\n}: ViewportRowsArgs<R>) {\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0 || !rowGrouper) return [undefined, rawRows.length];\n\n    const groupRows = (rows: readonly R[], [groupByKey, ...remainingGroupByKeys]: readonly string[], startRowIndex: number): [GroupByDictionary<R>, number] => {\n      let groupRowsCount = 0;\n      const groups: GroupByDictionary<R> = {};\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        // Recursively group each parent group\n        const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0\n          ? [childRows, childRows.length]\n          : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1); // 1 for parent row\n        groups[key] = { childRows, childGroups, startRowIndex: startRowIndex + groupRowsCount };\n        groupRowsCount += childRowsCount + 1; // 1 for parent row\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n\n  const [rows, allGroupRows] = useMemo(() => {\n    const allGroupRows = new Set<unknown>();\n    if (!groupedRows) return [rawRows, allGroupRows];\n\n    const flattenedRows: Array<R | GroupRow<R>> = [];\n    const expandGroup = (rows: GroupByDictionary<R> | readonly R[], parentId: string | undefined, level: number): void => {\n      if (isReadonlyArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        // TODO: should users have control over the generated key?\n        const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n        const isExpanded = expandedGroupIds?.has(id) ?? false;\n        const { childRows, childGroups, startRowIndex } = rows[groupKey];\n\n        const groupRow: GroupRow<R> = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, allGroupRows];\n  }, [expandedGroupIds, groupedRows, rawRows]);\n\n  const isGroupRow = <R>(row: unknown): row is GroupRow<R> => allGroupRows.has(row);\n\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rows.length - 1, Math.floor((scrollTop + clientHeight) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rows.length - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n\n  return {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    isGroupRow\n  };\n}\n","import { useRef, useEffect, useCallback } from 'react';\n\n// https://reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useLatestFunc<T extends (...args: any[]) => any>(fn: T) {\n  const ref = useRef(fn);\n\n  useEffect(() => {\n    ref.current = fn;\n  });\n\n  return useCallback((...args: Parameters<T>) => {\n    ref.current(...args);\n  }, []);\n}\n","import { css } from '@linaria/core';\nimport type { HeaderCellProps } from '../HeaderCell';\nimport type { SortDirection } from '../types';\n\nconst headerSortCell = css`\n  cursor: pointer;\n  display: flex;\n`;\n\nconst headerSortCellClassname = `rdg-header-sort-cell ${headerSortCell}`;\n\nconst headerSortName = css`\n  flex-grow: 1;\n  overflow: hidden;\n  overflow: clip;\n  text-overflow: ellipsis;\n`;\n\nconst headerSortNameClassname = `rdg-header-sort-name ${headerSortName}`;\n\ntype SharedHeaderCellProps<R, SR> = Pick<HeaderCellProps<R, SR>,\n  | 'column'\n  | 'sortColumn'\n  | 'sortDirection'\n  | 'onSort'\n>;\n\ninterface Props<R, SR> extends SharedHeaderCellProps<R, SR> {\n  children: React.ReactNode;\n}\n\nexport default function SortableHeaderCell<R, SR>({\n  column,\n  onSort,\n  sortColumn,\n  sortDirection,\n  children\n}: Props<R, SR>) {\n  sortDirection = sortColumn === column.key && sortDirection || 'NONE';\n  let sortText = '';\n  if (sortDirection === 'ASC') {\n    sortText = '\\u25B2';\n  } else if (sortDirection === 'DESC') {\n    sortText = '\\u25BC';\n  }\n\n  function onClick() {\n    if (!onSort) return;\n    const { sortDescendingFirst } = column;\n    let direction: SortDirection;\n    switch (sortDirection) {\n      case 'ASC':\n        direction = sortDescendingFirst ? 'NONE' : 'DESC';\n        break;\n      case 'DESC':\n        direction = sortDescendingFirst ? 'ASC' : 'NONE';\n        break;\n      default:\n        direction = sortDescendingFirst ? 'DESC' : 'ASC';\n        break;\n    }\n    onSort(column.key, direction);\n  }\n\n  return (\n    <span className={headerSortCellClassname} onClick={onClick}>\n      <span className={headerSortNameClassname}>{children}</span>\n      <span>{sortText}</span>\n    </span>\n  );\n}\n","// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\nconst nonInputKeys = new Set([\n  // Special keys\n  'Unidentified',\n  // Modifier keys\n  'Alt',\n  'AltGraph',\n  'CapsLock',\n  'Control',\n  'Fn',\n  'FnLock',\n  'Meta',\n  'NumLock',\n  'ScrollLock',\n  'Shift',\n  // Whitespace keys\n  'Tab',\n  // Navigation keys\n  'ArrowDown',\n  'ArrowLeft',\n  'ArrowRight',\n  'ArrowUp',\n  'End',\n  'Home',\n  'PageDown',\n  'PageUp',\n  // Editing\n  'Insert',\n  // UI keys\n  'ContextMenu',\n  'Escape',\n  'Pause',\n  'Play',\n  // Device keys\n  'PrintScreen',\n  // Function keys\n  'F1',\n  // 'F2', /!\\ specifically allowed, do not edit\n  'F3',\n  'F4',\n  'F5',\n  'F6',\n  'F7',\n  'F8',\n  'F9',\n  'F10',\n  'F11',\n  'F12'\n]);\n\nexport function isCtrlKeyHeldDown(e: React.KeyboardEvent): boolean {\n  return (e.ctrlKey || e.metaKey) && e.key !== 'Control';\n}\n\nexport function isDefaultCellInput(event: React.KeyboardEvent<HTMLDivElement>): boolean {\n  return !nonInputKeys.has(event.key);\n}\n\n/**\n * By default, the following navigation keys are enabled while an editor is open, under specific conditions:\n * - Tab:\n *   - The editor must be an <input>, a <textarea>, or a <select> element.\n *   - The editor element must be the only immediate child of the editor container/a label.\n */\nexport function onEditorNavigation({ key, target }: React.KeyboardEvent<HTMLDivElement>): boolean {\n  if (key === 'Tab' && (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement)) {\n    return target.matches('.rdg-editor-container > :only-child, .rdg-editor-container > label:only-child > :only-child');\n  }\n  return false;\n}\n","import type { CalculatedColumn, Position, GroupRow, CellNavigationMode } from '../types';\n\ninterface IsSelectedCellEditableOpts<R, SR> {\n  selectedPosition: Position;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rows: readonly (R | GroupRow<R>)[];\n  isGroupRow: (row: R | GroupRow<R>) => row is GroupRow<R>;\n}\n\nexport function isSelectedCellEditable<R, SR>({ selectedPosition, columns, rows, isGroupRow }: IsSelectedCellEditableOpts<R, SR>): boolean {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  return column.editor != null\n    && !column.rowGroup\n    && !isGroupRow(row)\n    && (typeof column.editable === 'function' ? column.editable(row) : column.editable) !== false;\n}\n\ninterface GetNextSelectedCellPositionOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  nextPosition: Position;\n}\n\nexport function getNextSelectedCellPosition<R, SR>({ cellNavigationMode, columns, rowsCount, nextPosition }: GetNextSelectedCellPositionOpts<R, SR>): Position {\n  if (cellNavigationMode !== 'NONE') {\n    const { idx, rowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isLastRow = rowIdx === rowsCount - 1;\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else {\n        return {\n          rowIdx,\n          idx: 0\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isFirstRow = rowIdx === 0;\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else {\n        return {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n  }\n\n  return nextPosition;\n}\n\ninterface CanExitGridOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  selectedPosition: Position;\n  shiftKey: boolean;\n}\n\nexport function canExitGrid<R, SR>({ cellNavigationMode, columns, rowsCount, selectedPosition: { rowIdx, idx }, shiftKey }: CanExitGridOpts<R, SR>): boolean {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === 'NONE' || cellNavigationMode === 'CHANGE_ROW') {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n","import clsx from 'clsx';\n\nimport type { CalculatedColumn } from '../types';\nimport { cellClassname, cellFrozenClassname, cellFrozenLastClassname } from '../style';\n\nexport * from './domUtils';\nexport * from './keyboardUtils';\nexport * from './selectedCellUtils';\n\nexport function assertIsValidKeyGetter<R>(keyGetter: unknown): asserts keyGetter is (row: R) => React.Key {\n  if (typeof keyGetter !== 'function') {\n    throw new Error('Please specify the rowKeyGetter prop to use selection');\n  }\n}\n\nexport function getCellStyle<R, SR>(column: CalculatedColumn<R, SR>): React.CSSProperties {\n  return column.frozen\n    ? { left: `var(--frozen-left-${column.key})` }\n    : { gridColumnStart: column.idx + 1 };\n}\n\nexport function getCellClassname<R, SR>(column: CalculatedColumn<R, SR>, ...extraClasses: Parameters<typeof clsx>): string {\n  return clsx(\n    cellClassname, {\n      [cellFrozenClassname]: column.frozen,\n      [cellFrozenLastClassname]: column.isLastFrozenColumn\n    },\n    ...extraClasses\n  );\n}\n","import { css } from '@linaria/core';\n\nimport type { CalculatedColumn, SortDirection } from './types';\nimport type { HeaderRowProps } from './HeaderRow';\nimport SortableHeaderCell from './headerCells/SortableHeaderCell';\nimport { getCellStyle, getCellClassname } from './utils';\n\nconst cellResizable = css`\n  &::after {\n    content: \"\";\n    cursor: col-resize;\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    width: 10px;\n  }\n`;\n\nconst cellResizableClassname = `rdg-cell-resizable ${cellResizable}`;\n\nfunction getAriaSort(sortDirection?: SortDirection) {\n  switch (sortDirection) {\n    case 'ASC':\n      return 'ascending';\n    case 'DESC':\n      return 'descending';\n    default:\n      return 'none';\n  }\n}\n\ntype SharedHeaderRowProps<R, SR> = Pick<HeaderRowProps<R, SR>,\n  | 'sortColumn'\n  | 'sortDirection'\n  | 'onSort'\n  | 'allRowsSelected'\n>;\n\nexport interface HeaderCellProps<R, SR> extends SharedHeaderRowProps<R, SR> {\n  column: CalculatedColumn<R, SR>;\n  onResize: (column: CalculatedColumn<R, SR>, width: number) => void;\n  onAllRowsSelectionChange: (checked: boolean) => void;\n}\n\nexport default function HeaderCell<R, SR>({\n  column,\n  onResize,\n  allRowsSelected,\n  onAllRowsSelectionChange,\n  sortColumn,\n  sortDirection,\n  onSort\n}: HeaderCellProps<R, SR>) {\n  function onPointerDown(event: React.PointerEvent<HTMLDivElement>) {\n    if (event.pointerType === 'mouse' && event.buttons !== 1) {\n      return;\n    }\n\n    const { currentTarget, pointerId } = event;\n    const { right } = currentTarget.getBoundingClientRect();\n    const offset = right - event.clientX;\n\n    if (offset > 11) { // +1px to account for the border size\n      return;\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      if (event.pointerId !== pointerId) return;\n      if (event.pointerType === 'mouse' && event.buttons !== 1) {\n        onPointerUp();\n        return;\n      }\n      const width = event.clientX + offset - currentTarget.getBoundingClientRect().left;\n      if (width > 0) {\n        onResize(column, width);\n      }\n    }\n\n    function onPointerUp() {\n      if (event.pointerId !== pointerId) return;\n      window.removeEventListener('pointermove', onPointerMove);\n      window.removeEventListener('pointerup', onPointerUp);\n    }\n\n    event.preventDefault();\n    window.addEventListener('pointermove', onPointerMove);\n    window.addEventListener('pointerup', onPointerUp);\n  }\n\n  function getCell() {\n    if (column.headerRenderer) {\n      return (\n        <column.headerRenderer\n          column={column}\n          sortColumn={sortColumn}\n          sortDirection={sortDirection}\n          onSort={onSort}\n          allRowsSelected={allRowsSelected}\n          onAllRowsSelectionChange={onAllRowsSelectionChange}\n        />\n      );\n    }\n\n    if (column.sortable) {\n      return (\n        <SortableHeaderCell\n          column={column}\n          onSort={onSort}\n          sortColumn={sortColumn}\n          sortDirection={sortDirection}\n        >\n          {column.name}\n        </SortableHeaderCell>\n      );\n    }\n\n    return column.name;\n  }\n\n  const className = getCellClassname(column, column.headerCellClass, {\n    [cellResizableClassname]: column.resizable\n  });\n\n  return (\n    <div\n      role=\"columnheader\"\n      aria-colindex={column.idx + 1}\n      aria-sort={sortColumn === column.key ? getAriaSort(sortDirection) : undefined}\n      className={className}\n      style={getCellStyle(column)}\n      onPointerDown={column.resizable ? onPointerDown : undefined}\n    >\n      {getCell()}\n    </div>\n  );\n}\n","import { useCallback, memo } from 'react';\n\nimport HeaderCell from './HeaderCell';\nimport type { CalculatedColumn } from './types';\nimport { assertIsValidKeyGetter } from './utils';\nimport type { DataGridProps } from './DataGrid';\nimport { headerRowClassname } from './style';\n\ntype SharedDataGridProps<R, SR> = Pick<DataGridProps<R, SR>,\n  | 'rows'\n  | 'onSelectedRowsChange'\n  | 'sortColumn'\n  | 'sortDirection'\n  | 'onSort'\n  | 'rowKeyGetter'\n>;\n\nexport interface HeaderRowProps<R, SR> extends SharedDataGridProps<R, SR> {\n  columns: readonly CalculatedColumn<R, SR>[];\n  allRowsSelected: boolean;\n  onColumnResize: (column: CalculatedColumn<R, SR>, width: number) => void;\n}\n\nfunction HeaderRow<R, SR>({\n  columns,\n  rows,\n  rowKeyGetter,\n  onSelectedRowsChange,\n  allRowsSelected,\n  onColumnResize,\n  sortColumn,\n  sortDirection,\n  onSort\n}: HeaderRowProps<R, SR>) {\n  const handleAllRowsSelectionChange = useCallback((checked: boolean) => {\n    if (!onSelectedRowsChange) return;\n\n    assertIsValidKeyGetter(rowKeyGetter);\n\n    const newSelectedRows = new Set<React.Key>(checked ? rows.map(rowKeyGetter) : undefined);\n    onSelectedRowsChange(newSelectedRows);\n  }, [onSelectedRowsChange, rows, rowKeyGetter]);\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={1} // aria-rowindex is 1 based\n      className={headerRowClassname}\n    >\n      {columns.map(column => {\n        return (\n          <HeaderCell<R, SR>\n            key={column.key}\n            column={column}\n            onResize={onColumnResize}\n            allRowsSelected={allRowsSelected}\n            onAllRowsSelectionChange={handleAllRowsSelectionChange}\n            onSort={onSort}\n            sortColumn={sortColumn}\n            sortDirection={sortDirection}\n          />\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(HeaderRow) as <R, SR>(props: HeaderRowProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\n\nimport { getCellStyle, getCellClassname } from './utils';\nimport type { CalculatedColumn, Filters } from './types';\nimport type { DataGridProps } from './DataGrid';\nimport { filterRowClassname } from './style';\n\ntype SharedDataGridProps<R, SR> = Pick<DataGridProps<R, SR>,\n  | 'filters'\n  | 'onFiltersChange'\n>;\n\ninterface FilterRowProps<R, SR> extends SharedDataGridProps<R, SR> {\n  columns: readonly CalculatedColumn<R, SR>[];\n}\n\nfunction FilterRow<R, SR>({\n  columns,\n  filters,\n  onFiltersChange\n}: FilterRowProps<R, SR>) {\n  function onChange(key: string, value: unknown) {\n    const newFilters: Filters = { ...filters };\n    newFilters[key] = value;\n    onFiltersChange?.(newFilters);\n  }\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={2}\n      className={filterRowClassname}\n    >\n      {columns.map(column => {\n        const { key } = column;\n\n        return (\n          <div\n            key={key}\n            className={getCellClassname(column)}\n            style={getCellStyle(column)}\n          >\n            {column.filterRenderer && (\n              <column.filterRenderer\n                column={column}\n                value={filters?.[column.key]}\n                onChange={value => onChange(key, value)}\n              />\n            )}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(FilterRow) as <R, SR>(props: FilterRowProps<R, SR>) => JSX.Element;\n","import { forwardRef, memo } from 'react';\nimport type { RefAttributes } from 'react';\nimport { css } from '@linaria/core';\n\nimport { cellSelectedClassname } from './style';\nimport { getCellStyle, getCellClassname } from './utils';\nimport type { CellRendererProps } from './types';\n\nconst cellCopied = css`\n  background-color: #ccccff;\n`;\n\nconst cellCopiedClassname = `rdg-cell-copied ${cellCopied}`;\n\nconst cellDraggedOver = css`\n  background-color: #ccccff;\n\n  &.${cellCopied} {\n    background-color: #9999ff;\n  }\n`;\n\nconst cellDraggedOverClassname = `rdg-cell-dragged-over ${cellDraggedOver}`;\n\nconst cellDragHandle = css`\n  cursor: move;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  width: 8px;\n  height: 8px;\n  background-color: var(--selection-color);\n\n  &:hover {\n    width: 16px;\n    height: 16px;\n    border: 2px solid var(--selection-color);\n    background-color: var(--background-color);\n  }\n`;\n\nconst cellDragHandleClassname = `rdg-cell-drag-handle ${cellDragHandle}`;\n\nfunction Cell<R, SR>({\n  className,\n  column,\n  isCellSelected,\n  isCopied,\n  isDraggedOver,\n  isRowSelected,\n  row,\n  rowIdx,\n  dragHandleProps,\n  onRowClick,\n  onClick,\n  onDoubleClick,\n  onContextMenu,\n  onRowChange,\n  selectCell,\n  selectRow,\n  ...props\n}: CellRendererProps<R, SR>, ref: React.Ref<HTMLDivElement>) {\n  const { cellClass } = column;\n  className = getCellClassname(\n    column,\n    {\n      [cellSelectedClassname]: isCellSelected,\n      [cellCopiedClassname]: isCopied,\n      [cellDraggedOverClassname]: isDraggedOver\n    },\n    typeof cellClass === 'function' ? cellClass(row) : cellClass,\n    className\n  );\n\n  function selectCellWrapper(openEditor?: boolean) {\n    selectCell({ idx: column.idx, rowIdx }, openEditor);\n  }\n\n  function handleClick(event: React.MouseEvent<HTMLDivElement>) {\n    selectCellWrapper(column.editorOptions?.editOnClick);\n    onRowClick?.(rowIdx, row, column);\n    onClick?.(event);\n  }\n\n  function handleContextMenu(event: React.MouseEvent<HTMLDivElement>) {\n    selectCellWrapper();\n    onContextMenu?.(event);\n  }\n\n  function handleDoubleClick(event: React.MouseEvent<HTMLDivElement>) {\n    selectCellWrapper(true);\n    onDoubleClick?.(event);\n  }\n\n  function handleRowChange(newRow: R) {\n    onRowChange(rowIdx, newRow);\n  }\n\n  function onRowSelectionChange(checked: boolean, isShiftClick: boolean) {\n    selectRow({ rowIdx, checked, isShiftClick });\n  }\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1} // aria-colindex is 1-based\n      aria-selected={isCellSelected}\n      ref={ref}\n      className={className}\n      style={getCellStyle(column)}\n      onClick={handleClick}\n      onDoubleClick={handleDoubleClick}\n      onContextMenu={handleContextMenu}\n      {...props}\n    >\n      {!column.rowGroup && (\n        <>\n          <column.formatter\n            column={column}\n            rowIdx={rowIdx}\n            row={row}\n            isCellSelected={isCellSelected}\n            isRowSelected={isRowSelected}\n            onRowSelectionChange={onRowSelectionChange}\n            onRowChange={handleRowChange}\n          />\n          {dragHandleProps && (\n            <div className={cellDragHandleClassname} {...dragHandleProps} />\n          )}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default memo(forwardRef(Cell)) as <R, SR = unknown>(props: CellRendererProps<R, SR> & RefAttributes<HTMLDivElement>) => JSX.Element;\n","import { createPortal } from 'react-dom';\nimport { css } from '@linaria/core';\n\nimport type { EditorProps } from '../types';\nimport { useClickOutside } from '../hooks';\n\nconst editorContainer = css`\n  display: contents;\n`;\n\nconst editorContainerClassname = `rdg-editor-container ${editorContainer}`;\n\nexport default function EditorContainer<R, SR>({\n  row,\n  column,\n  onRowChange,\n  ...props\n}: EditorProps<R, SR>) {\n  const onClickCapture = useClickOutside(() => onRowChange(row, true));\n  if (column.editor === undefined) return null;\n\n  const editor = (\n    <div className={editorContainerClassname} onClickCapture={onClickCapture}>\n      <column.editor\n        row={row}\n        column={column}\n        onRowChange={onRowChange}\n        {...props}\n      />\n    </div>\n  );\n\n  if (column.editorOptions?.createPortal) {\n    return createPortal(editor, props.editorPortalTarget);\n  }\n\n  return editor;\n}\n","import { useState, useCallback } from 'react';\nimport { css } from '@linaria/core';\n\nimport { cellSelectedClassname } from './style';\nimport EditorContainer from './editors/EditorContainer';\nimport { getCellStyle, getCellClassname } from './utils';\nimport type { CellRendererProps, SharedEditorProps, Omit } from './types';\n\nconst cellEditing = css`\n  padding: 0;\n`;\n\nconst cellEditingClassname = `rdg-cell-editing ${cellEditing}`;\n\ntype SharedCellRendererProps<R, SR> = Pick<CellRendererProps<R, SR>,\n  | 'rowIdx'\n  | 'row'\n  | 'column'\n>;\n\ninterface EditCellProps<R, SR> extends SharedCellRendererProps<R, SR>, Omit<React.HTMLAttributes<HTMLDivElement>, 'style' | 'children'> {\n  editorProps: SharedEditorProps<R>;\n}\n\nexport default function EditCell<R, SR>({\n  className,\n  column,\n  row,\n  rowIdx,\n  editorProps,\n  ...props\n}: EditCellProps<R, SR>) {\n  const [dimensions, setDimensions] = useState<{ left: number; top: number } | null>(null);\n\n  const cellRef = useCallback(node => {\n    if (node !== null) {\n      const { left, top } = node.getBoundingClientRect();\n      setDimensions({ left, top });\n    }\n  }, []);\n\n  const { cellClass } = column;\n  className = getCellClassname(\n    column,\n    cellSelectedClassname,\n    cellEditingClassname,\n    typeof cellClass === 'function' ? cellClass(row) : cellClass,\n    className\n  );\n\n  function getCellContent() {\n    if (dimensions === null) return;\n    const { scrollTop: docTop, scrollLeft: docLeft } = document.scrollingElement ?? document.documentElement;\n    const { left, top } = dimensions;\n    const gridLeft = left + docLeft;\n    const gridTop = top + docTop;\n\n    return (\n      <EditorContainer\n        {...editorProps}\n        rowIdx={rowIdx}\n        column={column}\n        left={gridLeft}\n        top={gridTop}\n      />\n    );\n  }\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1} // aria-colindex is 1-based\n      aria-selected\n      ref={cellRef}\n      className={className}\n      style={getCellStyle(column)}\n      {...props}\n    >\n      {getCellContent()}\n    </div>\n  );\n}\n","import { memo, forwardRef } from 'react';\nimport type { RefAttributes } from 'react';\nimport clsx from 'clsx';\n\nimport { groupRowSelectedClassname, rowClassname, rowSelectedClassname } from './style';\nimport Cell from './Cell';\nimport EditCell from './EditCell';\nimport type { RowRendererProps, SelectedCellProps } from './types';\n\nfunction Row<R, SR = unknown>({\n  cellRenderer: CellRenderer = Cell,\n  className,\n  rowIdx,\n  isRowSelected,\n  copiedCellIdx,\n  draggedOverCellIdx,\n  row,\n  viewportColumns,\n  selectedCellProps,\n  onRowClick,\n  rowClass,\n  setDraggedOverRowIdx,\n  onMouseEnter,\n  top,\n  onRowChange,\n  selectCell,\n  selectRow,\n  'aria-rowindex': ariaRowIndex,\n  'aria-selected': ariaSelected,\n  ...props\n}: RowRendererProps<R, SR>, ref: React.Ref<HTMLDivElement>) {\n  function handleDragEnter(event: React.MouseEvent<HTMLDivElement>) {\n    setDraggedOverRowIdx?.(rowIdx);\n    onMouseEnter?.(event);\n  }\n\n  className = clsx(\n    rowClassname,\n    `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, {\n      [rowSelectedClassname]: isRowSelected,\n      [groupRowSelectedClassname]: selectedCellProps?.idx === -1\n    },\n    rowClass?.(row),\n    className\n  );\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={ariaRowIndex}\n      aria-selected={ariaSelected}\n      ref={ref}\n      className={className}\n      onMouseEnter={handleDragEnter}\n      style={{ top }}\n      {...props}\n    >\n      {viewportColumns.map(column => {\n        const isCellSelected = selectedCellProps?.idx === column.idx;\n        if (selectedCellProps?.mode === 'EDIT' && isCellSelected) {\n          return (\n            <EditCell<R, SR>\n              key={column.key}\n              rowIdx={rowIdx}\n              column={column}\n              row={row}\n              onKeyDown={selectedCellProps.onKeyDown}\n              editorProps={selectedCellProps.editorProps}\n            />\n          );\n        }\n\n        return (\n          <CellRenderer\n            key={column.key}\n            rowIdx={rowIdx}\n            column={column}\n            row={row}\n            isCopied={copiedCellIdx === column.idx}\n            isDraggedOver={draggedOverCellIdx === column.idx}\n            isCellSelected={isCellSelected}\n            isRowSelected={isRowSelected}\n            dragHandleProps={isCellSelected ? (selectedCellProps as SelectedCellProps).dragHandleProps : undefined}\n            onFocus={isCellSelected ? (selectedCellProps as SelectedCellProps).onFocus : undefined}\n            onKeyDown={isCellSelected ? selectedCellProps!.onKeyDown : undefined}\n            onRowClick={onRowClick}\n            onRowChange={onRowChange}\n            selectCell={selectCell}\n            selectRow={selectRow}\n          />\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(forwardRef(Row)) as <R, SR = unknown>(props: RowRendererProps<R, SR> & RefAttributes<HTMLDivElement>) => JSX.Element;\n","import { memo } from 'react';\n\nimport { getCellStyle, getCellClassname } from './utils';\nimport type { CalculatedColumn } from './types';\nimport type { GroupRowRendererProps } from './GroupRow';\nimport { cellSelectedClassname } from './style';\n\ntype SharedGroupRowRendererProps<R, SR> = Pick<GroupRowRendererProps<R, SR>,\n  | 'id'\n  | 'rowIdx'\n  | 'groupKey'\n  | 'childRows'\n  | 'isExpanded'\n  | 'isRowSelected'\n  | 'selectRow'\n  | 'toggleGroup'\n>;\n\ninterface GroupCellProps<R, SR> extends SharedGroupRowRendererProps<R, SR> {\n  column: CalculatedColumn<R, SR>;\n  isCellSelected: boolean;\n  groupColumnIndex: number;\n}\n\nfunction GroupCell<R, SR>({\n  id,\n  rowIdx,\n  groupKey,\n  childRows,\n  isExpanded,\n  isCellSelected,\n  isRowSelected,\n  column,\n  groupColumnIndex,\n  selectRow,\n  toggleGroup: toggleGroupWrapper\n}: GroupCellProps<R, SR>) {\n  function toggleGroup() {\n    toggleGroupWrapper(id);\n  }\n\n  function onRowSelectionChange(checked: boolean) {\n    selectRow({ rowIdx, checked, isShiftClick: false });\n  }\n\n  // Only make the cell clickable if the group level matches\n  const isLevelMatching = column.rowGroup && groupColumnIndex === column.idx;\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1}\n      key={column.key}\n      className={getCellClassname(column, {\n        [cellSelectedClassname]: isCellSelected\n      })}\n      style={{\n        ...getCellStyle(column),\n        cursor: isLevelMatching ? 'pointer' : 'default'\n      }}\n      onClick={isLevelMatching ? toggleGroup : undefined}\n    >\n      {(!column.rowGroup || groupColumnIndex === column.idx) && column.groupFormatter && (\n        <column.groupFormatter\n          groupKey={groupKey}\n          childRows={childRows}\n          column={column}\n          isExpanded={isExpanded}\n          isCellSelected={isCellSelected}\n          isRowSelected={isRowSelected}\n          onRowSelectionChange={onRowSelectionChange}\n          toggleGroup={toggleGroup}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default memo(GroupCell) as <R, SR>(props: GroupCellProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\nimport clsx from 'clsx';\n\nimport { groupRowClassname, groupRowSelectedClassname, rowClassname, rowSelectedClassname } from './style';\nimport { SELECT_COLUMN_KEY } from './Columns';\nimport GroupCell from './GroupCell';\nimport type { CalculatedColumn, Position, SelectRowEvent, Omit } from './types';\n\nexport interface GroupRowRendererProps<R, SR = unknown> extends Omit<React.HTMLAttributes<HTMLDivElement>, 'style' | 'children'> {\n  id: string;\n  groupKey: unknown;\n  viewportColumns: readonly CalculatedColumn<R, SR>[];\n  childRows: readonly R[];\n  rowIdx: number;\n  top: number;\n  level: number;\n  selectedCellIdx?: number;\n  isExpanded: boolean;\n  isRowSelected: boolean;\n  selectCell: (position: Position, enableEditor?: boolean) => void;\n  selectRow: (selectRowEvent: SelectRowEvent) => void;\n  toggleGroup: (expandedGroupId: unknown) => void;\n}\n\nfunction GroupedRow<R, SR>({\n  id,\n  groupKey,\n  viewportColumns,\n  childRows,\n  rowIdx,\n  top,\n  level,\n  isExpanded,\n  selectedCellIdx,\n  isRowSelected,\n  selectCell,\n  selectRow,\n  toggleGroup,\n  ...props\n}: GroupRowRendererProps<R, SR>) {\n  // Select is always the first column\n  const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? level + 1 : level;\n\n  function selectGroup() {\n    selectCell({ rowIdx, idx: -1 });\n  }\n\n  return (\n    <div\n      role=\"row\"\n      aria-level={level}\n      aria-expanded={isExpanded}\n      className={clsx(\n        rowClassname,\n        groupRowClassname,\n        `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, {\n          [rowSelectedClassname]: isRowSelected,\n          [groupRowSelectedClassname]: selectedCellIdx === -1 // Select row if there is no selected cell\n        }\n      )}\n      onClick={selectGroup}\n      style={{ top }}\n      {...props}\n    >\n      {viewportColumns.map(column => (\n        <GroupCell<R, SR>\n          key={column.key}\n          id={id}\n          rowIdx={rowIdx}\n          groupKey={groupKey}\n          childRows={childRows}\n          isExpanded={isExpanded}\n          isRowSelected={isRowSelected}\n          isCellSelected={selectedCellIdx === column.idx}\n          column={column}\n          groupColumnIndex={idx}\n          selectRow={selectRow}\n          toggleGroup={toggleGroup}\n        />\n      ))}\n    </div>\n  );\n}\n\nexport default memo(GroupedRow) as <R, SR>(props: GroupRowRendererProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\n\nimport { getCellStyle, getCellClassname } from './utils';\nimport type { CellRendererProps } from './types';\n\ntype SharedCellRendererProps<R, SR> = Pick<CellRendererProps<R, SR>, 'column'>;\n\ninterface SummaryCellProps<R, SR> extends SharedCellRendererProps<R, SR> {\n  row: SR;\n}\n\nfunction SummaryCell<R, SR>({\n  column,\n  row\n}: SummaryCellProps<R, SR>) {\n  const { summaryFormatter: SummaryFormatter, summaryCellClass } = column;\n  const className = getCellClassname(column,\n    typeof summaryCellClass === 'function' ? summaryCellClass(row) : summaryCellClass\n  );\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1}\n      className={className}\n      style={getCellStyle(column)}\n    >\n      {SummaryFormatter && <SummaryFormatter column={column} row={row} />}\n    </div>\n  );\n}\n\nexport default memo(SummaryCell) as <R, SR>(props: SummaryCellProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\nimport { rowClassname, summaryRowClassname } from './style';\nimport SummaryCell from './SummaryCell';\nimport type { RowRendererProps } from './types';\n\ntype SharedRowRendererProps<R, SR> = Pick<RowRendererProps<R, SR>,\n  | 'viewportColumns'\n  | 'rowIdx'\n>;\n\ninterface SummaryRowProps<R, SR> extends SharedRowRendererProps<R, SR> {\n  'aria-rowindex': number;\n  row: SR;\n  bottom: number;\n}\n\nfunction SummaryRow<R, SR>({\n  rowIdx,\n  row,\n  viewportColumns,\n  bottom,\n  'aria-rowindex': ariaRowIndex\n}: SummaryRowProps<R, SR>) {\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={ariaRowIndex}\n      className={`${rowClassname} rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'} ${summaryRowClassname}`}\n      style={{ bottom }}\n    >\n      {viewportColumns.map(column => (\n        <SummaryCell<R, SR>\n          key={column.key}\n          column={column}\n          row={row}\n        />\n      ))}\n    </div>\n  );\n}\n\nexport default memo(SummaryRow) as <R, SR>(props: SummaryRowProps<R, SR>) => JSX.Element;\n","import {\n  forwardRef,\n  useState,\n  useRef,\n  useLayoutEffect,\n  useImperativeHandle,\n  useCallback\n} from 'react';\nimport type { RefAttributes } from 'react';\nimport clsx from 'clsx';\n\nimport { rootClassname, viewportDraggingClassname, focusSinkClassname } from './style';\nimport { useGridDimensions, useViewportColumns, useViewportRows, useLatestFunc } from './hooks';\nimport HeaderRow from './HeaderRow';\nimport FilterRow from './FilterRow';\nimport Row from './Row';\nimport GroupRowRenderer from './GroupRow';\nimport SummaryRow from './SummaryRow';\nimport {\n  assertIsValidKeyGetter,\n  onEditorNavigation,\n  getNextSelectedCellPosition,\n  isSelectedCellEditable,\n  canExitGrid,\n  isCtrlKeyHeldDown,\n  isDefaultCellInput\n} from './utils';\n\nimport type {\n  CalculatedColumn,\n  Column,\n  Filters,\n  Position,\n  RowRendererProps,\n  RowsChangeData,\n  SelectRowEvent,\n  SelectedCellProps,\n  EditCellProps,\n  FillEvent,\n  PasteEvent,\n  CellNavigationMode,\n  SortDirection\n} from './types';\n\ninterface SelectCellState extends Position {\n  mode: 'SELECT';\n}\n\ninterface EditCellState<R> extends Position {\n  mode: 'EDIT';\n  row: R;\n  originalRow: R;\n  key: string | null;\n}\n\ntype DefaultColumnOptions<R, SR> = Pick<Column<R, SR>,\n  | 'formatter'\n  | 'minWidth'\n  | 'resizable'\n  | 'sortable'\n>;\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nconst body = globalThis.document?.body;\n\nexport interface DataGridHandle {\n  element: HTMLDivElement | null;\n  scrollToColumn: (colIdx: number) => void;\n  scrollToRow: (rowIdx: number) => void;\n  selectCell: (position: Position, openEditor?: boolean) => void;\n}\n\ntype SharedDivProps = Pick<React.HTMLAttributes<HTMLDivElement>,\n  | 'aria-label'\n  | 'aria-labelledby'\n  | 'aria-describedby'\n  | 'className'\n  | 'style'\n>;\n\nexport interface DataGridProps<R, SR = unknown> extends SharedDivProps {\n  /**\n   * Grid and data Props\n   */\n  /** An array of objects representing each column on the grid */\n  columns: readonly Column<R, SR>[];\n  /** A function called for each rendered row that should return a plain key/value pair object */\n  rows: readonly R[];\n  /**\n   * Rows to be pinned at the bottom of the rows view for summary, the vertical scroll bar will not scroll these rows.\n   * Bottom horizontal scroll bar can move the row left / right. Or a customized row renderer can be used to disabled the scrolling support.\n   */\n  summaryRows?: readonly SR[];\n  /** The getter should return a unique key for each row */\n  rowKeyGetter?: (row: R) => React.Key;\n  onRowsChange?: (rows: R[], data: RowsChangeData<R, SR>) => void;\n\n  /**\n   * Dimensions props\n   */\n  /** The height of each row in pixels */\n  rowHeight?: number;\n  /** The height of the header row in pixels */\n  headerRowHeight?: number;\n  /** The height of the header filter row in pixels */\n  headerFiltersHeight?: number;\n  /** The height of each summary row in pixels */\n  summaryRowHeight?: number;\n\n  /**\n   * Feature props\n   */\n  /** Set of selected row keys */\n  selectedRows?: ReadonlySet<React.Key>;\n  /** Function called whenever row selection is changed */\n  onSelectedRowsChange?: (selectedRows: Set<React.Key>) => void;\n  /** The key of the column which is currently being sorted */\n  sortColumn?: string;\n  /** The direction to sort the sortColumn*/\n  sortDirection?: SortDirection;\n  /** Function called whenever grid is sorted*/\n  onSort?: (columnKey: string, direction: SortDirection) => void;\n  filters?: Readonly<Filters>;\n  onFiltersChange?: (filters: Filters) => void;\n  defaultColumnOptions?: DefaultColumnOptions<R, SR>;\n  groupBy?: readonly string[];\n  rowGrouper?: (rows: readonly R[], columnKey: string) => Record<string, readonly R[]>;\n  expandedGroupIds?: ReadonlySet<unknown>;\n  onExpandedGroupIdsChange?: (expandedGroupIds: Set<unknown>) => void;\n  onFill?: (event: FillEvent<R>) => R[];\n  onPaste?: (event: PasteEvent<R>) => R;\n\n  /**\n   * Custom renderers\n   */\n  rowRenderer?: React.ComponentType<RowRendererProps<R, SR>>;\n  emptyRowsRenderer?: React.ComponentType;\n\n  /**\n   * Event props\n   */\n  /** Function called whenever a row is clicked */\n  onRowClick?: (rowIdx: number, row: R, column: CalculatedColumn<R, SR>) => void;\n  /** Called when the grid is scrolled */\n  onScroll?: (event: React.UIEvent<HTMLDivElement>) => void;\n  /** Called when a column is resized */\n  onColumnResize?: (idx: number, width: number) => void;\n  /** Function called whenever selected cell is changed */\n  onSelectedCellChange?: (position: Position) => void;\n\n  /**\n   * Toggles and modes\n   */\n  /** Toggles whether filters row is displayed or not */\n  enableFilterRow?: boolean;\n  cellNavigationMode?: CellNavigationMode;\n\n  /**\n   * Miscellaneous\n   */\n  /** The node where the editor portal should mount. */\n  editorPortalTarget?: Element;\n  rowClass?: (row: R) => string | undefined;\n}\n\n/**\n * Main API Component to render a data grid of rows and columns\n *\n * @example\n *\n * <DataGrid columns={columns} rows={rows} />\n*/\nfunction DataGrid<R, SR>({\n  // Grid and data Props\n  columns: rawColumns,\n  rows: rawRows,\n  summaryRows,\n  rowKeyGetter,\n  onRowsChange,\n  // Dimensions props\n  rowHeight = 35,\n  headerRowHeight = rowHeight,\n  headerFiltersHeight = 45,\n  summaryRowHeight = rowHeight,\n  // Feature props\n  selectedRows,\n  onSelectedRowsChange,\n  sortColumn,\n  sortDirection,\n  onSort,\n  filters,\n  onFiltersChange,\n  defaultColumnOptions,\n  groupBy: rawGroupBy,\n  rowGrouper,\n  expandedGroupIds,\n  onExpandedGroupIdsChange,\n  // Custom renderers\n  rowRenderer: RowRenderer = Row,\n  emptyRowsRenderer: EmptyRowsRenderer,\n  // Event props\n  onRowClick,\n  onScroll,\n  onColumnResize,\n  onSelectedCellChange,\n  onFill,\n  onPaste,\n  // Toggles and modes\n  enableFilterRow = false,\n  cellNavigationMode = 'NONE',\n  // Miscellaneous\n  editorPortalTarget = body,\n  className,\n  style,\n  rowClass,\n  // ARIA\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  'aria-describedby': ariaDescribedBy\n}: DataGridProps<R, SR>, ref: React.Ref<DataGridHandle>) {\n  /**\n   * states\n   */\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [columnWidths, setColumnWidths] = useState<ReadonlyMap<string, number>>(() => new Map());\n  const [selectedPosition, setSelectedPosition] = useState<SelectCellState | EditCellState<R>>({ idx: -1, rowIdx: -1, mode: 'SELECT' });\n  const [copiedCell, setCopiedCell] = useState<{ row: R; columnKey: string } | null>(null);\n  const [isDragging, setDragging] = useState(false);\n  const [draggedOverRowIdx, setOverRowIdx] = useState<number | undefined>(undefined);\n\n  /**\n   * refs\n   */\n  const focusSinkRef = useRef<HTMLDivElement>(null);\n  const prevSelectedPosition = useRef(selectedPosition);\n  const latestDraggedOverRowIdx = useRef(draggedOverRowIdx);\n  const lastSelectedRowIdx = useRef(-1);\n  const isCellFocusable = useRef(false);\n\n  /**\n   * The identity of the wrapper function is stable so it won't break memoization\n   */\n  const selectRowWrapper = useLatestFunc(selectRow);\n  const selectCellWrapper = useLatestFunc(selectCell);\n  const toggleGroupWrapper = useLatestFunc(toggleGroup);\n  const handleFormatterRowChangeWrapper = useLatestFunc(updateRow);\n\n  /**\n   * computed values\n   */\n  const [gridRef, gridWidth, gridHeight] = useGridDimensions();\n  const headerRowsCount = enableFilterRow ? 2 : 1;\n  const summaryRowsCount = summaryRows?.length ?? 0;\n  const totalHeaderHeight = headerRowHeight + (enableFilterRow ? headerFiltersHeight : 0);\n  const clientHeight = gridHeight - totalHeaderHeight - summaryRowsCount * summaryRowHeight;\n  const isSelectable = selectedRows !== undefined && onSelectedRowsChange !== undefined;\n\n  const { columns, viewportColumns, layoutCssVars, columnMetrics, totalColumnWidth, lastFrozenColumnIndex, totalFrozenColumnWidth, groupBy } = useViewportColumns({\n    rawColumns,\n    columnWidths,\n    scrollLeft,\n    viewportWidth: gridWidth,\n    defaultColumnOptions,\n    rawGroupBy: rowGrouper ? rawGroupBy : undefined\n  });\n\n  const { rowOverscanStartIdx, rowOverscanEndIdx, rows, rowsCount, isGroupRow } = useViewportRows({\n    rawRows,\n    groupBy,\n    rowGrouper,\n    rowHeight,\n    clientHeight,\n    scrollTop,\n    expandedGroupIds\n  });\n\n  const hasGroups = groupBy.length > 0 && typeof rowGrouper === 'function';\n  const minColIdx = hasGroups ? -1 : 0;\n\n  // Cell drag is not supported on a treegrid\n  const enableCellDragAndDrop = hasGroups ? false : onFill !== undefined;\n\n  /**\n   * effects\n   */\n  useLayoutEffect(() => {\n    if (selectedPosition === prevSelectedPosition.current || selectedPosition.mode === 'EDIT' || !isCellWithinBounds(selectedPosition)) return;\n    prevSelectedPosition.current = selectedPosition;\n    scrollToCell(selectedPosition);\n\n    if (isCellFocusable.current) {\n      isCellFocusable.current = false;\n      return;\n    }\n    focusSinkRef.current!.focus({ preventScroll: true });\n  });\n\n  useImperativeHandle(ref, () => ({\n    element: gridRef.current,\n    scrollToColumn(idx: number) {\n      scrollToCell({ idx });\n    },\n    scrollToRow(rowIdx: number) {\n      const { current } = gridRef;\n      if (!current) return;\n      current.scrollTo({\n        top: rowIdx * rowHeight,\n        behavior: 'smooth'\n      });\n    },\n    selectCell\n  }));\n\n  /**\n  * callbacks\n  */\n  const handleColumnResize = useCallback((column: CalculatedColumn<R, SR>, width: number) => {\n    setColumnWidths(columnWidths => {\n      const newColumnWidths = new Map(columnWidths);\n      newColumnWidths.set(column.key, width);\n      return newColumnWidths;\n    });\n\n    onColumnResize?.(column.idx, width);\n  }, [onColumnResize]);\n\n  const setDraggedOverRowIdx = useCallback((rowIdx?: number) => {\n    setOverRowIdx(rowIdx);\n    latestDraggedOverRowIdx.current = rowIdx;\n  }, []);\n\n  /**\n  * event handlers\n  */\n  function selectRow({ rowIdx, checked, isShiftClick }: SelectRowEvent) {\n    if (!onSelectedRowsChange) return;\n\n    assertIsValidKeyGetter(rowKeyGetter);\n    const newSelectedRows = new Set(selectedRows);\n    const row = rows[rowIdx];\n    if (isGroupRow(row)) {\n      for (const childRow of row.childRows) {\n        const rowKey = rowKeyGetter(childRow);\n        if (checked) {\n          newSelectedRows.add(rowKey);\n        } else {\n          newSelectedRows.delete(rowKey);\n        }\n      }\n      onSelectedRowsChange(newSelectedRows);\n      return;\n    }\n\n    const rowKey = rowKeyGetter(row);\n    if (checked) {\n      newSelectedRows.add(rowKey);\n      const previousRowIdx = lastSelectedRowIdx.current;\n      lastSelectedRowIdx.current = rowIdx;\n      if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n        const step = Math.sign(rowIdx - previousRowIdx);\n        for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n          const row = rows[i];\n          if (isGroupRow(row)) continue;\n          newSelectedRows.add(rowKeyGetter(row));\n        }\n      }\n    } else {\n      newSelectedRows.delete(rowKey);\n      lastSelectedRowIdx.current = -1;\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }\n\n  function toggleGroup(expandedGroupId: unknown) {\n    if (!onExpandedGroupIdsChange) return;\n    const newExpandedGroupIds = new Set(expandedGroupIds);\n    if (newExpandedGroupIds.has(expandedGroupId)) {\n      newExpandedGroupIds.delete(expandedGroupId);\n    } else {\n      newExpandedGroupIds.add(expandedGroupId);\n    }\n    onExpandedGroupIdsChange(newExpandedGroupIds);\n  }\n\n  function onGridFocus() {\n    if (!isCellWithinBounds(selectedPosition)) {\n      // Tabbing into the grid should initiate keyboard navigation\n      const initialPosition: SelectCellState = { idx: 0, rowIdx: 0, mode: 'SELECT' };\n      if (isCellWithinBounds(initialPosition)) {\n        setSelectedPosition(initialPosition);\n      }\n    } else {\n      // otherwise if we already have a selected cell, we should scroll back to it when focusing the grid\n      scrollToCell(selectedPosition);\n    }\n  }\n\n  function handleKeyDown(event: React.KeyboardEvent<HTMLDivElement>) {\n    const { key, keyCode } = event;\n    const row = rows[selectedPosition.rowIdx];\n\n    if (\n      onPaste\n      && isCtrlKeyHeldDown(event)\n      && isCellWithinBounds(selectedPosition)\n      && !isGroupRow(row)\n      && selectedPosition.idx !== -1\n      && selectedPosition.mode === 'SELECT'\n    ) {\n      // event.key may differ by keyboard input language, so we use event.keyCode instead\n      // event.nativeEvent.code cannot be used either as it would break copy/paste for the DVORAK layout\n      const cKey = 67;\n      const vKey = 86;\n      if (keyCode === cKey) {\n        handleCopy();\n        return;\n      }\n      if (keyCode === vKey) {\n        handlePaste();\n        return;\n      }\n    }\n\n    if (\n      isCellWithinBounds(selectedPosition)\n      && isGroupRow(row)\n      && selectedPosition.idx === -1\n      && (\n        // Collapse the current group row if it is focused and is in expanded state\n        (key === 'ArrowLeft' && row.isExpanded)\n        // Expand the current group row if it is focused and is in collapsed state\n        || (key === 'ArrowRight' && !row.isExpanded)\n      )) {\n      event.preventDefault(); // Prevents scrolling\n      toggleGroup(row.id);\n      return;\n    }\n\n    switch (event.key) {\n      case 'Escape':\n        setCopiedCell(null);\n        closeEditor();\n        return;\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'Tab':\n      case 'Home':\n      case 'End':\n      case 'PageUp':\n      case 'PageDown':\n        navigate(event);\n        break;\n      default:\n        handleCellInput(event);\n        break;\n    }\n  }\n\n  function handleFocus() {\n    isCellFocusable.current = true;\n  }\n\n  function handleScroll(event: React.UIEvent<HTMLDivElement>) {\n    const { scrollTop, scrollLeft } = event.currentTarget;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll?.(event);\n  }\n\n  function getRawRowIdx(rowIdx: number) {\n    return hasGroups ? rawRows.indexOf(rows[rowIdx] as R) : rowIdx;\n  }\n\n  function updateRow(rowIdx: number, row: R) {\n    if (typeof onRowsChange !== 'function') return;\n    const updatedRows = [...rawRows];\n    updatedRows[rowIdx] = row;\n    onRowsChange(updatedRows, {\n      indexes: [rowIdx],\n      column: columns[selectedPosition.idx]\n    });\n  }\n\n  function commitEditorChanges() {\n    if (\n      columns[selectedPosition.idx]?.editor === undefined\n      || selectedPosition.mode === 'SELECT'\n      || selectedPosition.row === selectedPosition.originalRow) {\n      return;\n    }\n\n    const rowIdx = getRawRowIdx(selectedPosition.rowIdx);\n    updateRow(rowIdx, selectedPosition.row);\n  }\n\n  function handleCopy() {\n    const { idx, rowIdx } = selectedPosition;\n    setCopiedCell({ row: rawRows[getRawRowIdx(rowIdx)], columnKey: columns[idx].key });\n  }\n\n  function handlePaste() {\n    const { idx, rowIdx } = selectedPosition;\n    const targetRow = rawRows[getRawRowIdx(rowIdx)];\n    if (\n      !onPaste\n      || !onRowsChange\n      || copiedCell === null\n      || !isCellEditable(selectedPosition)\n    ) {\n      return;\n    }\n\n    const updatedTargetRow = onPaste({\n      sourceRow: copiedCell.row,\n      sourceColumnKey: copiedCell.columnKey,\n      targetRow,\n      targetColumnKey: columns[idx].key\n    });\n\n    updateRow(rowIdx, updatedTargetRow);\n  }\n\n  function handleCellInput(event: React.KeyboardEvent<HTMLDivElement>) {\n    if (!isCellWithinBounds(selectedPosition)) return;\n    const row = rows[selectedPosition.rowIdx];\n    if (isGroupRow(row)) return;\n    const { key } = event;\n    const column = columns[selectedPosition.idx];\n\n    if (selectedPosition.mode === 'EDIT') {\n      if (key === 'Enter') {\n        // Custom editors can listen for the event and stop propagation to prevent commit\n        commitEditorChanges();\n        closeEditor();\n      }\n      return;\n    }\n\n    column.editorOptions?.onCellKeyDown?.(event);\n    if (event.isDefaultPrevented()) return;\n\n    if (isCellEditable(selectedPosition) && isDefaultCellInput(event)) {\n      setSelectedPosition(({ idx, rowIdx }) => ({\n        idx,\n        rowIdx,\n        key,\n        mode: 'EDIT',\n        row,\n        originalRow: row\n      }));\n    }\n  }\n\n  function handleDragEnd() {\n    const overRowIdx = latestDraggedOverRowIdx.current;\n    if (overRowIdx === undefined || !onFill || !onRowsChange) return;\n\n    const { idx, rowIdx } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const startRowIndex = rowIdx < overRowIdx ? rowIdx + 1 : overRowIdx;\n    const endRowIndex = rowIdx < overRowIdx ? overRowIdx + 1 : rowIdx;\n    const targetRows = rawRows.slice(startRowIndex, endRowIndex);\n    const column = columns[idx];\n    const updatedTargetRows = onFill({ columnKey: column.key, sourceRow, targetRows });\n    const updatedRows = [...rawRows];\n    const indexes: number[] = [];\n\n    for (let i = startRowIndex; i < endRowIndex; i++) {\n      updatedRows[i] = updatedTargetRows[i - startRowIndex];\n      indexes.push(i);\n    }\n\n    onRowsChange(updatedRows, { indexes, column });\n    setDraggedOverRowIdx(undefined);\n  }\n\n  function handleMouseDown(event: React.MouseEvent<HTMLDivElement, MouseEvent>) {\n    if (event.buttons !== 1) return;\n    setDragging(true);\n    window.addEventListener('mouseover', onMouseOver);\n    window.addEventListener('mouseup', onMouseUp);\n\n    function onMouseOver(event: MouseEvent) {\n      // Trigger onMouseup in edge cases where we release the mouse button but `mouseup` isn't triggered,\n      // for example when releasing the mouse button outside the iframe the grid is rendered in.\n      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n      if (event.buttons !== 1) onMouseUp();\n    }\n\n    function onMouseUp() {\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mouseup', onMouseUp);\n      setDragging(false);\n      handleDragEnd();\n    }\n  }\n\n  function handleDoubleClick(event: React.MouseEvent<HTMLDivElement>) {\n    event.stopPropagation();\n    if (!onFill || !onRowsChange) return;\n\n    const { idx, rowIdx } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const targetRows = rawRows.slice(rowIdx + 1);\n    const column = columns[idx];\n    const updatedTargetRows = onFill({ columnKey: column.key, sourceRow, targetRows });\n    const updatedRows = [...rawRows];\n    const indexes: number[] = [];\n\n    for (let i = rowIdx + 1; i < updatedRows.length; i++) {\n      updatedRows[i] = updatedTargetRows[i - rowIdx - 1];\n      indexes.push(i);\n    }\n\n    onRowsChange(updatedRows, { indexes, column });\n  }\n\n  function handleEditorRowChange(row: Readonly<R>, commitChanges?: boolean) {\n    if (selectedPosition.mode === 'SELECT') return;\n    if (commitChanges) {\n      updateRow(getRawRowIdx(selectedPosition.rowIdx), row);\n      closeEditor();\n    } else {\n      setSelectedPosition(position => ({ ...position, row }));\n    }\n  }\n\n  function handleOnClose(commitChanges?: boolean) {\n    if (commitChanges) {\n      commitEditorChanges();\n    }\n    closeEditor();\n  }\n\n  /**\n   * utils\n   */\n  function isCellWithinBounds({ idx, rowIdx }: Position): boolean {\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= minColIdx && idx < columns.length;\n  }\n\n  function isCellEditable(position: Position): boolean {\n    return isCellWithinBounds(position)\n      && isSelectedCellEditable<R, SR>({ columns, rows, selectedPosition: position, isGroupRow });\n  }\n\n  function selectCell(position: Position, enableEditor = false): void {\n    if (!isCellWithinBounds(position)) return;\n    commitEditorChanges();\n\n    if (enableEditor && isCellEditable(position)) {\n      const row = rows[position.rowIdx] as R;\n      setSelectedPosition({ ...position, mode: 'EDIT', key: null, row, originalRow: row });\n    } else {\n      setSelectedPosition({ ...position, mode: 'SELECT' });\n    }\n    onSelectedCellChange?.({ ...position });\n  }\n\n  function closeEditor() {\n    if (selectedPosition.mode === 'SELECT') return;\n    setSelectedPosition(({ idx, rowIdx }) => ({ idx, rowIdx, mode: 'SELECT' }));\n  }\n\n  function scrollToCell({ idx, rowIdx }: Partial<Position>): void {\n    const { current } = gridRef;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      const { clientWidth } = current;\n      const { left, width } = columnMetrics.get(columns[idx])!;\n      const isCellAtLeftBoundary = left < scrollLeft + totalFrozenColumnWidth;\n      const isCellAtRightBoundary = left + width > clientWidth + scrollLeft;\n      if (isCellAtLeftBoundary) {\n        current.scrollLeft = left - totalFrozenColumnWidth;\n      } else if (isCellAtRightBoundary) {\n        current.scrollLeft = left + width - clientWidth;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      if (rowIdx * rowHeight < scrollTop) {\n        // at top boundary, scroll to the row's top\n        current.scrollTop = rowIdx * rowHeight;\n      } else if ((rowIdx + 1) * rowHeight > scrollTop + clientHeight) {\n        // at bottom boundary, scroll the next row's top to the bottom of the viewport\n        current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getNextPosition(key: string, ctrlKey: boolean, shiftKey: boolean): Position {\n    const { idx, rowIdx } = selectedPosition;\n    const row = rows[rowIdx];\n    const isRowSelected = isCellWithinBounds(selectedPosition) && idx === -1;\n\n    // If a group row is focused, and it is collapsed, move to the parent group row (if there is one).\n    if (\n      key === 'ArrowLeft'\n      && isRowSelected\n      && isGroupRow(row)\n      && !row.isExpanded\n      && row.level !== 0\n    ) {\n      let parentRowIdx = -1;\n      for (let i = selectedPosition.rowIdx - 1; i >= 0; i--) {\n        const parentRow = rows[i];\n        if (isGroupRow(parentRow) && parentRow.id === row.parentId) {\n          parentRowIdx = i;\n          break;\n        }\n      }\n      if (parentRowIdx !== -1) {\n        return { idx, rowIdx: parentRowIdx };\n      }\n    }\n\n    switch (key) {\n      case 'ArrowUp':\n        return { idx, rowIdx: rowIdx - 1 };\n      case 'ArrowDown':\n        return { idx, rowIdx: rowIdx + 1 };\n      case 'ArrowLeft':\n        return { idx: idx - 1, rowIdx };\n      case 'ArrowRight':\n        return { idx: idx + 1, rowIdx };\n      case 'Tab':\n        if (selectedPosition.idx === -1 && selectedPosition.rowIdx === -1) {\n          return shiftKey ? { idx: columns.length - 1, rowIdx: rows.length - 1 } : { idx: 0, rowIdx: 0 };\n        }\n        return { idx: idx + (shiftKey ? -1 : 1), rowIdx };\n      case 'Home':\n        // If row is selected then move focus to the first row\n        if (isRowSelected) return { idx, rowIdx: 0 };\n        return ctrlKey ? { idx: 0, rowIdx: 0 } : { idx: 0, rowIdx };\n      case 'End':\n        // If row is selected then move focus to the last row.\n        if (isRowSelected) return { idx, rowIdx: rows.length - 1 };\n        return ctrlKey ? { idx: columns.length - 1, rowIdx: rows.length - 1 } : { idx: columns.length - 1, rowIdx };\n      case 'PageUp':\n        return { idx, rowIdx: rowIdx - Math.floor(clientHeight / rowHeight) };\n      case 'PageDown':\n        return { idx, rowIdx: rowIdx + Math.floor(clientHeight / rowHeight) };\n      default:\n        return selectedPosition;\n    }\n  }\n\n  function navigate(event: React.KeyboardEvent<HTMLDivElement>) {\n    if (selectedPosition.mode === 'EDIT') {\n      const onNavigation = columns[selectedPosition.idx].editorOptions?.onNavigation ?? onEditorNavigation;\n      if (!onNavigation(event)) return;\n    }\n    const { key, shiftKey } = event;\n    let mode = cellNavigationMode;\n    if (key === 'Tab') {\n      // If we are in a position to leave the grid, stop editing but stay in that cell\n      if (canExitGrid({ shiftKey, cellNavigationMode, columns, rowsCount: rows.length, selectedPosition })) {\n        commitEditorChanges();\n        // Allow focus to leave the grid so the next control in the tab order can be focused\n        return;\n      }\n\n      mode = cellNavigationMode === 'NONE'\n        ? 'CHANGE_ROW'\n        : cellNavigationMode;\n    }\n\n    // Do not allow focus to leave\n    event.preventDefault();\n\n    const ctrlKey = isCtrlKeyHeldDown(event);\n    let nextPosition = getNextPosition(key, ctrlKey, shiftKey);\n    nextPosition = getNextSelectedCellPosition({\n      columns,\n      rowsCount: rows.length,\n      cellNavigationMode: mode,\n      nextPosition\n    });\n\n    selectCell(nextPosition);\n  }\n\n  function getDraggedOverCellIdx(currentRowIdx: number): number | undefined {\n    if (draggedOverRowIdx === undefined) return;\n    const { rowIdx } = selectedPosition;\n\n    const isDraggedOver = rowIdx < draggedOverRowIdx\n      ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx\n      : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n\n    return isDraggedOver ? selectedPosition.idx : undefined;\n  }\n\n  function getSelectedCellProps(rowIdx: number): SelectedCellProps | EditCellProps<R> | undefined {\n    if (selectedPosition.rowIdx !== rowIdx) return;\n\n    if (selectedPosition.mode === 'EDIT') {\n      return {\n        mode: 'EDIT',\n        idx: selectedPosition.idx,\n        onKeyDown: handleKeyDown,\n        editorProps: {\n          editorPortalTarget,\n          rowHeight,\n          row: selectedPosition.row,\n          onRowChange: handleEditorRowChange,\n          onClose: handleOnClose\n        }\n      };\n    }\n\n    return {\n      mode: 'SELECT',\n      idx: selectedPosition.idx,\n      onFocus: handleFocus,\n      onKeyDown: handleKeyDown,\n      dragHandleProps: enableCellDragAndDrop && isCellEditable(selectedPosition)\n        ? { onMouseDown: handleMouseDown, onDoubleClick: handleDoubleClick }\n        : undefined\n    };\n  }\n\n  function getViewportRows() {\n    const rowElements = [];\n    let startRowIndex = 0;\n    for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      const row = rows[rowIdx];\n      const top = rowIdx * rowHeight + totalHeaderHeight;\n      if (isGroupRow(row)) {\n        ({ startRowIndex } = row);\n        rowElements.push(\n          <GroupRowRenderer<R, SR>\n            aria-level={row.level + 1} // aria-level is 1-based\n            aria-setsize={row.setSize}\n            aria-posinset={row.posInSet + 1} // aria-posinset is 1-based\n            aria-rowindex={headerRowsCount + startRowIndex + 1} // aria-rowindex is 1 based\n            key={row.id}\n            id={row.id}\n            groupKey={row.groupKey}\n            viewportColumns={viewportColumns}\n            childRows={row.childRows}\n            rowIdx={rowIdx}\n            top={top}\n            level={row.level}\n            isExpanded={row.isExpanded}\n            selectedCellIdx={selectedPosition.rowIdx === rowIdx ? selectedPosition.idx : undefined}\n            isRowSelected={isSelectable && row.childRows.every(cr => selectedRows?.has(rowKeyGetter!(cr)))}\n            onFocus={selectedPosition.rowIdx === rowIdx ? handleFocus : undefined}\n            onKeyDown={selectedPosition.rowIdx === rowIdx ? handleKeyDown : undefined}\n            selectCell={selectCellWrapper}\n            selectRow={selectRowWrapper}\n            toggleGroup={toggleGroupWrapper}\n          />\n        );\n        continue;\n      }\n\n      startRowIndex++;\n      let key: React.Key = hasGroups ? startRowIndex : rowIdx;\n      let isRowSelected = false;\n      if (typeof rowKeyGetter === 'function') {\n        key = rowKeyGetter(row);\n        isRowSelected = selectedRows?.has(key) ?? false;\n      }\n\n      rowElements.push(\n        <RowRenderer\n          aria-rowindex={headerRowsCount + (hasGroups ? startRowIndex : rowIdx) + 1} // aria-rowindex is 1 based\n          aria-selected={isSelectable ? isRowSelected : undefined}\n          key={key}\n          rowIdx={rowIdx}\n          row={row}\n          viewportColumns={viewportColumns}\n          isRowSelected={isRowSelected}\n          onRowClick={onRowClick}\n          rowClass={rowClass}\n          top={top}\n          copiedCellIdx={copiedCell !== null && copiedCell.row === row ? columns.findIndex(c => c.key === copiedCell.columnKey) : undefined}\n          draggedOverCellIdx={getDraggedOverCellIdx(rowIdx)}\n          setDraggedOverRowIdx={isDragging ? setDraggedOverRowIdx : undefined}\n          selectedCellProps={getSelectedCellProps(rowIdx)}\n          onRowChange={handleFormatterRowChangeWrapper}\n          selectCell={selectCellWrapper}\n          selectRow={selectRowWrapper}\n        />\n      );\n    }\n\n    return rowElements;\n  }\n\n  // Reset the positions if the current values are no longer valid. This can happen if a column or row is removed\n  if (selectedPosition.idx >= columns.length || selectedPosition.rowIdx >= rows.length) {\n    setSelectedPosition({ idx: -1, rowIdx: -1, mode: 'SELECT' });\n    setDraggedOverRowIdx(undefined);\n  }\n\n  if (selectedPosition.mode === 'EDIT' && rows[selectedPosition.rowIdx] !== selectedPosition.originalRow) {\n    // Discard changes if rows are updated from outside\n    closeEditor();\n  }\n\n  return (\n    <div\n      role={hasGroups ? 'treegrid' : 'grid'}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-describedby={ariaDescribedBy}\n      aria-multiselectable={isSelectable ? true : undefined}\n      aria-colcount={columns.length}\n      aria-rowcount={headerRowsCount + rowsCount + summaryRowsCount}\n      className={clsx(rootClassname, { [viewportDraggingClassname]: isDragging }, className)}\n      style={{\n        ...style,\n        '--header-row-height': `${headerRowHeight}px`,\n        '--filter-row-height': `${headerFiltersHeight}px`,\n        '--row-width': `${totalColumnWidth}px`,\n        '--row-height': `${rowHeight}px`,\n        '--summary-row-height': `${summaryRowHeight}px`,\n        ...layoutCssVars\n      } as unknown as React.CSSProperties}\n      ref={gridRef}\n      onScroll={handleScroll}\n    >\n      <HeaderRow<R, SR>\n        rowKeyGetter={rowKeyGetter}\n        rows={rawRows}\n        columns={viewportColumns}\n        onColumnResize={handleColumnResize}\n        allRowsSelected={selectedRows?.size === rawRows.length}\n        onSelectedRowsChange={onSelectedRowsChange}\n        sortColumn={sortColumn}\n        sortDirection={sortDirection}\n        onSort={onSort}\n      />\n      {enableFilterRow && (\n        <FilterRow<R, SR>\n          columns={viewportColumns}\n          filters={filters}\n          onFiltersChange={onFiltersChange}\n        />\n      )}\n      {rows.length === 0 && EmptyRowsRenderer ? <EmptyRowsRenderer /> : (\n        <>\n          <div\n            ref={focusSinkRef}\n            tabIndex={0}\n            className={focusSinkClassname}\n            onKeyDown={handleKeyDown}\n            onFocus={onGridFocus}\n          />\n          <div style={{ height: Math.max(rows.length * rowHeight, clientHeight) }} />\n          {getViewportRows()}\n          {summaryRows?.map((row, rowIdx) => (\n            <SummaryRow<R, SR>\n              aria-rowindex={headerRowsCount + rowsCount + rowIdx + 1}\n              key={rowIdx}\n              rowIdx={rowIdx}\n              row={row}\n              bottom={summaryRowHeight * (summaryRows.length - 1 - rowIdx)}\n              viewportColumns={viewportColumns}\n            />\n          ))}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default forwardRef(DataGrid) as <R, SR = unknown>(props: DataGridProps<R, SR> & RefAttributes<DataGridHandle>) => JSX.Element;\n","import { css } from '@linaria/core';\nimport type { EditorProps } from '../types';\n\nconst textEditor = css`\n  appearance: none;\n\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  padding: 0px 6px 0 6px;\n  border: 2px solid #ccc;\n  vertical-align: top;\n  color: var(--color);\n  background-color: var(--background-color);\n\n  font-family: inherit;\n  font-size: var(--font-size);\n\n  &:focus {\n    border-color: var(--selection-color);\n    outline: none;\n  }\n\n  &::placeholder {\n    color: #999;\n    opacity: 1;\n  }\n`;\n\nexport const textEditorClassname = `rdg-text-editor ${textEditor}`;\n\nfunction autoFocusAndSelect(input: HTMLInputElement | null) {\n  input?.focus();\n  input?.select();\n}\n\nexport default function TextEditor<TRow, TSummaryRow = unknown>({\n  row,\n  column,\n  onRowChange,\n  onClose\n}: EditorProps<TRow, TSummaryRow>) {\n  return (\n    <input\n      className={textEditorClassname}\n      ref={autoFocusAndSelect}\n      value={row[column.key as keyof TRow] as unknown as string}\n      onChange={event => onRowChange({ ...row, [column.key]: event.target.value })}\n      onBlur={() => onClose(true)}\n    />\n  );\n}\n"]},"metadata":{},"sourceType":"module"}